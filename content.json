{"meta":{"title":"张向南的博客","subtitle":"progress everyday","description":"一块学习","author":"zhangxiangnan","url":"http://zhangxiangnan.com"},"pages":[{"title":"about","date":"2016-05-09T11:46:57.000Z","updated":"2019-02-28T08:27:46.000Z","comments":true,"path":"about/index.html","permalink":"http://zhangxiangnan.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2016-05-09T09:58:32.000Z","updated":"2019-02-27T05:39:45.000Z","comments":false,"path":"categories/index.html","permalink":"http://zhangxiangnan.com/categories/index.html","excerpt":"","text":""},{"title":"标签云","date":"2016-05-09T11:45:59.000Z","updated":"2019-02-28T08:26:21.000Z","comments":false,"path":"tags/index.html","permalink":"http://zhangxiangnan.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"lambda表达式入门","slug":"java/lambda表达式入门","date":"2018-02-05T11:47:07.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2018/02/05/java/lambda表达式入门/","link":"","permalink":"http://zhangxiangnan.com/2018/02/05/java/lambda表达式入门/","excerpt":"lambda表达式入门学习","text":"lambda表达式入门学习 lambda出现的背景如果匿名类的实现起来非常简单,如只有一个方法的接口,那么匿名类的语法使用起来看着会不清晰。 这些情形,看起来像是把功能当做参数传递到其他方法,如当点击按钮时应该执行的操作。Lambda表达式让我们能够把功能/函数/方法当做参数,或者代码当做数据来传递。 尽管匿名类比非匿名类简洁,但是对于只有一个方法的类,匿名类仍然有些烦琐。Lambda表达式让我们可以更简洁地表达单方法类的实例对象。 lambda表达式语法lambda表达式如(p,q) -&gt; System.out.print(“x”), 包含如下几部分: 圆括号里逗号分隔的一个或多个形参列表,注意: 形参的数据数据类型可以省略不写 当只有一个形参时,圆括号也可以省略不写,如p -&gt; System.out.print(“x”) 箭头标记 一个单独表达式或者代码块,如: p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25 如果是一个单独的表达式,jvm计算表达式的值并返回;此外,也可以使用return语句: p -&gt; { return p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25; } return语句不是一个表达式。在lambda表达式里,必须使用{}把return的语句块包起来,但若{}包的语句块中的方法为void方法,则可以省略{},如: email -&gt; System.out.println(email) lambda表达式看着很像一个方法声明,可以将lambda表达式认为是匿名的方法调用。 lambda表达式也可以有多个形参,如: public class Calculator { interface IntegerMath { int operation(int a, int b); } public int operateBinary(int a, int b, IntegerMath op) { return op.operation(a, b); } public static void main(String... args) { Calculator myApp = new Calculator(); IntegerMath addition = (a, b) -&gt; a + b; IntegerMath subtraction = (a, b) -&gt; a - b; System.out.println(&quot;40 + 2 = &quot; + myApp.operateBinary(40, 2, addition)); System.out.println(&quot;20 - 10 = &quot; + myApp.operateBinary(20, 10, subtraction)); } } lambda表达式理想用例创建找出符合某一个特征的人员的搜索方法(找出年龄大于指定值的人?)public static void printPersonsOlderThan(List&lt;Person&gt; roster, int age) { for (Person p : roster) { if (p.getAge() &gt;= age) { p.printPerson(); } } } 思考: 不支持泛型,改变Person类型就需要重写方法&amp;只支持大于某个年龄,想要找出小于某个年龄的就.. 创建更通用的搜索方法public static void printPersonsWithinAgeRange( List&lt;Person&gt; roster, int low, int high) { for (Person p : roster) { if (low &lt;= p.getAge() &amp;&amp; p.getAge() &lt; high) { p.printPerson(); } } } 思考:支持小于某个年龄,但是假如想找出某个指定性别、或者指定性别结合年龄条件? 假如Person类增加了关系、地域等属性呢?每种属性定义一个搜索方法也可以,但会散乱,可以将搜索条件单独隔离到其他方法里。 在局部类中指定搜索条件的代码public static void printPersons( List&lt;Person&gt; roster, CheckPerson tester) { for (Person p : roster) { if (tester.test(p)) { p.printPerson(); } } } interface CheckPerson { boolean test(Person p); } class CheckPersonSelectiveService implements CheckPerson { public boolean test(Person p) { return p.gender == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25; } } 调用: printPersons( roster, new CheckPersonEligibleForSelectiveService()); 思考:改变person类型不需要重写printPersons方法,但引入一个接口及每一种搜索一个局部实现类,可以将局部实现类改为匿名类。 匿名类中指定搜索条件代码printPersons( roster, new CheckPerson() { public boolean test(Person p) { return p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25; } } ); 思考:改为了匿名类,省去局部类的定义,但是匿名类仍然较烦琐,由于CheckPerson接口只有一个方法,则可以考虑使用lambda表达式替换 使用lambda表达式替换搜索代码CheckPerson是一个函数接口,函数接口是仅有一个抽象方法的任何接口(可能包含多个静态方法或默认方法)。由于函数接口仅有一个方法,因为实现该接口时可以忽略方法名称,如下: printPersons( roster, (Person p) -&gt; p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25 ); 思考:可以使用标准函数接口来进一步减少代码 使用lambda表达式的标准函数接口由于CheckPerson接口仅有一个方法,返回bool值,很简单,不必要在程序中自己定义,所以JDK在java.util.function中提供了若干标准函数接口,可以使用Predicate替换CheckPerson: interface Predicate&lt;T&gt; { boolean test(T t); } 这是一个泛型接口,替换CheckPerson,如下: public static void printPersonsWithPredicate( List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester) { for (Person p : roster) { if (tester.test(p)) { p.printPerson(); } } } 经过匿名类替换+使用lambda表达式,调用方式如下: printPersonsWithPredicate( roster, p -&gt; p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25 ); 整个程序中使用lambda表达式 再考虑这个方法: public static void printPersonsWithPredicate( List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester) { for (Person p : roster) { if (tester.test(p)) { p.printPerson(); } } } p.printPerson()是一个void方法,对p操作,假如不是执行printPerson操作而是执行其他类似void操作,那么就需要修改printPersonsWithPredicate方法,考虑将这个操作使用 lambda表达式,JDK提供了Consumer标准函数接口,可改进如下: public static void processPersons( List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester, Consumer&lt;Person&gt; block) { for (Person p : roster) { if (tester.test(p)) { block.accept(p); } } } 调用: processPersons( roster, p -&gt; p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25, p -&gt; p.printPerson() ); 假如想验证人员身份或获取联系信息呢?需要一个函数接口,其有一个抽象方法,返回一个值,The Function&lt;T,R&gt;标准接口有一个R apply(T t)方法,应用到如下示例: public static void processPersonsWithFunction( List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester, Function&lt;Person, String&gt; mapper, Consumer&lt;String&gt; block) { for (Person p : roster) { if (tester.test(p)) { String data = mapper.apply(p); block.accept(data); } } } 调用(获取每一个人的邮箱信息,并打印): processPersonsWithFunction( roster, p -&gt; p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25, p -&gt; p.getEmailAddress(), email -&gt; System.out.println(email) ); 使用泛型使扩展性更强processPersonsWithFunction方法的泛型版本如下: public static &lt;X, Y&gt; void processElements( Iterable&lt;X&gt; source, Predicate&lt;X&gt; tester, Function &lt;X, Y&gt; mapper, Consumer&lt;Y&gt; block) { for (X p : source) { if (tester.test(p)) { Y data = mapper.apply(p); block.accept(data); } } } 调用: processElements( roster, p -&gt; p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25, p -&gt; p.getEmailAddress(), email -&gt; System.out.println(email) ); 聚合操作如下聚合操作: roster .stream() .filter( p -&gt; p.getGender() == Person.Sex.MALE &amp;&amp; p.getAge() &gt;= 18 &amp;&amp; p.getAge() &lt;= 25) .map(p -&gt; p.getEmailAddress()) .forEach(email -&gt; System.out.println(email)); filter、map、foreach都是聚合操作,聚会操作从stream流中获取元素,而不是从集合中。 流是一系列元素,跟集合不同,流不是存储元素的数据结构,流从数据源如集合中通过管道/流水线传输元素。 管道/流水线是一系列流操作,一系列聚合操作,如filter-map-foreach。聚合操作通常接受lambda表达式作为参数,来自定义行为。 管道/流水线包含以下几部分: 数据源可以是一个集合、数组、一个生成器函数、I/O channel等 0步或多步中间操作如filter就是中间操作,生成一个符合过滤条件的元素组成的新流 一个结束操作如forEach生成一个非流的结果,如void、基本类型数据、一个集合。聚合操作与迭代的区别聚合操作如forEach,与迭代器看起来类似,但是有一个根本区别: 聚合操作使用内部迭代聚合操作使用内部迭代,只需要提供迭代集合,内部迭代可以是顺序迭代,也可以是并行迭代(并行计算,合并结果);迭代器是外部迭代,需要提供迭代集合与迭代方式,是顺序迭代方式。 聚合操作从流获取数据来处理聚合操作从流获取数据,非集合,所以聚合操作也称为流操作。 支持传递代码/行为为参数(lambada表达式作为参数) 归约操作 double average = roster .stream() .filter(p -&gt; p.getGender() == Person.Sex.MALE) .mapToInt(Person::getAge) .average() .getAsDouble(); JDK有很多结束操作,如average、sum、min、max、count,这些操作通过组合流的元素内容来返回一个值,这些操作叫做归约操作(reduction operations)。JDK也有返回一个集合的归约操作,很多归约操作都是执行一个指定的任务,如计算平均值,元素分组。JDK提供了通用的归约操作,Stream.reduce&amp;Stream.collect Stream.reduceStream.reduce是通用的归约操作,如下例则使用了Stream.sum 归约操作: Integer totalAge = roster .stream() .mapToInt(Person::getAge) .sum(); 使用Stream.reduce实现相同的逻辑如下: Integer totalAgeReduce = roster .stream() .map(Person::getAge) .reduce( 0, (a, b) -&gt; a + b); reduce操作有2个参数: - 第一个为标识元素 是归约的初始值和当流中无元素时的默认返回值 - 累加器函数 累加器函数有2个参数,归约的部分结果值和流中的下一个要计算的元素 reduce操作每次都返回一个新值,累加器每次处理完一个元素后也是返回一个新值,所以如果想要归约流的元素为一个更复杂的对象,如集合,由于每次会返回一个新的集合,性能低下,可以用Stream.collect Stream.collectreduce方法每处理一个元素会新建一个值,collect方法则是修改、转换一个已经存在的值。考虑如何计算流中元素的平均值?需要两份数据,一个是所有元素的个数,一个是其和,和reduce方法以及其他所有归约方法一样,collect也只返回一个值,可以创建一个新的数据类型,包含这两个计数,如下: class Averager implements IntConsumer { private int total = 0; private int count = 0; public double average() { return count &gt; 0 ? ((double) total)/count : 0; } public void accept(int i) { total += i; count++; } public void combine(Averager other) { total += other.total; count += other.count; } } Averager averageCollect = roster.stream() .filter(p -&gt; p.getGender() == Person.Sex.MALE) .map(Person::getAge) .collect(Averager::new, Averager::accept, Averager::combine); System.out.println(&quot;Average age of male members: &quot; + averageCollect.average()); 该例collect方法有三个参数: - supplier 结果容器创建函数,工厂方法,为collect操作创建一个新实例,创建结果容器的实例,本例则是创建Averager的实例。 - accumulator 累加器函数合并一个流元素到结果容器中,本例中,即修改Averager的2个计数 - combiner 合并函数将两个结果容器的内容进行合并,本例中,为对两个Averager容器中的2个计数进行合并相加。 注意: - supplier是一个lambda表达式或者方法引用,而非reduce操作中的identity元素是一个值。 - accumulator累加器和combiner合并函数不返回值 - 可以结合并行流使用collect操作 尽管JDK提供了average操作来计算平均值,当我们需要计算流中元素的几个值时就可以使用collect操作+自定义类。collect操作最适合集合,如下: List&lt;String&gt; namesOfMaleMembersCollect = roster .stream() .filter(p -&gt; p.getGender() == Person.Sex.MALE) .map(p -&gt; p.getName()) .collect(Collectors.toList()); 该例collect只需要一个Collector类型参数,该类封装了collect操作所需的三个参数(supplier、accumulator、combiner),Collectors类包含许多有用的操作,如累加元素到集合,根据不同条件分类元素等。Collectors.toList返回的Collector会累加流元素到一个新list。 按性别分类: Map&lt;Person.Sex, List&lt;Person&gt;&gt; byGender = roster .stream() .collect( Collectors.groupingBy(Person::getGender)); groupingBy方法根据指定的分类函数(getGener)来分类,返回的map的key为getGender的返回值。 获取集合中的成员姓名并按性别分类: Map&lt;Person.Sex, List&lt;String&gt;&gt; namesByGender = roster .stream() .collect( Collectors.groupingBy( Person::getGender, Collectors.mapping( Person::getName, Collectors.toList()))); 本例的groupingBy方法有2个参数,一个分类函数,一个Collector实例,Collector参数称为下游收集器,该收集器应用到另一个收集器的结果。 因此,groupingBy操作使你可以应用collect方法到groupingBy操作创建的List结果值上。 该例中,collector mapping将mapping函数应用到流中的每一个元素上,返回的结果流由会员名称组成;包含一个或多个下流收集器的流水线如本例称作多级归约。 如下例,获取每一种性别的会员的年龄总和: Map&lt;Person.Sex, Integer&gt; totalAgeByGender = roster .stream() .collect( Collectors.groupingBy( Person::getGender, Collectors.reducing( 0, Person::getAge, Integer::sum))); Collectors.reducing归约操作有三个参数: identity: 如Stream.reduce操作一样,identity是归约的初始值和默认值(如果流中没有元素),上例中,identity为0 mapper:归约操作将mapper函数应用到所有流元素,本例是获取每个成员的年龄 operation:操作函数用来归约映射的值,本例是对年龄求和 下例是获取每种性别的会员的平均年龄: Map&lt;Person.Sex, Double&gt; averageAgeByGender = roster .stream() .collect( Collectors.groupingBy( Person::getGender, Collectors.averagingInt(Person::getAge))); 并行并行计算涉及到将一个问题分为多个子问题,同时解决子问题(并行中,每一个子问题在一个独立线程中运行),然后合并各个子问题的结果。JavaSE提供了fork/join框架,可以让我们很方便地实现并行计算,然而用这个框架的话,必须指定如何划分问题,通过聚合操作就可以进行问题划分和结果合并。 对于使用集合的情形,并行计算的一个难点就是操作集合时的线程安全问题,虽然集合框架的同步方法是线程安全的,但是会导致线程竞争,达不到并行的目的。聚合操作以及并行流使我们能够实现提供的非线程安全性集合的并行性,在操作集合时不需要修改集合。注意,并行并不一定比串行快,当有足够的数据和处理器核心时可能并行更有优势。所以,即使聚合操作让我们更容易实现并行计算,但是也要考虑是否适合并行。 并行执行流操作流可以串行执行,也可以并行执行,当并行执行流时,jvm将流分为多个子流,聚合操作并行的迭代处理这些流,并把结果合并。当创建一个流时,默认是串行流,除非使用Collection.parallelStream或者BaseStream.parallel指定为并行流。如下例,并行计算男士的平均年龄: double average = roster .parallelStream() .filter(p -&gt; p.getGender() == Person.Sex.MALE) .mapToInt(Person::getAge) .average() .getAsDouble(); 并发归约再考虑如下例子: Map&lt;Person.Sex, List&lt;Person&gt;&gt; byGender = roster .stream() .collect( Collectors.groupingBy(Person::getGender)); 对应的并行代码: ConcurrentMap&lt;Person.Sex, List&lt;Person&gt;&gt; byGender = roster .parallelStream() .collect( Collectors.groupingByConcurrent(Person::getGender)); 上例称作并发归约,jvm在以下条件都为真时会为包含collect操作的指定流水线执行并发归约: 流是并行流 collect操作的collector参数的Collector.Characteristics为并发模式,通过Collector.characteristics方法设置 无论流式无序,或者collector设置了Collector.Characteristics.UNORDERED;确保流式无序的,可以通过BaseStream.unordered操作 排序pipeline处理流中元素的顺序依赖于流是串行执行还是并行执行,以及流的数据源本身和中间操作,如下例: Integer[] intArray = {1, 2, 3, 4, 5, 6, 7, 8 }; List&lt;Integer&gt; listOfIntegers = new ArrayList&lt;&gt;(Arrays.asList(intArray)); System.out.println(&quot;listOfIntegers:&quot;); listOfIntegers .stream() .forEach(e -&gt; System.out.print(e + &quot; &quot;)); System.out.println(&quot;&quot;); System.out.println(&quot;listOfIntegers sorted in reverse order:&quot;); Comparator&lt;Integer&gt; normal = Integer::compare; Comparator&lt;Integer&gt; reversed = normal.reversed(); Collections.sort(listOfIntegers, reversed); listOfIntegers .stream() .forEach(e -&gt; System.out.print(e + &quot; &quot;)); System.out.println(&quot;&quot;); System.out.println(&quot;Parallel stream&quot;); listOfIntegers .parallelStream() .forEach(e -&gt; System.out.print(e + &quot; &quot;)); System.out.println(&quot;&quot;); System.out.println(&quot;Another parallel stream:&quot;); listOfIntegers .parallelStream() .forEach(e -&gt; System.out.print(e + &quot; &quot;)); System.out.println(&quot;&quot;); System.out.println(&quot;With forEachOrdered:&quot;); listOfIntegers .parallelStream() .forEachOrdered(e -&gt; System.out.print(e + &quot; &quot;)); System.out.println(&quot;&quot;); listOfIntegers: 1 2 3 4 5 6 7 8 listOfIntegers sorted in reverse order: 8 7 6 5 4 3 2 1 Parallel stream: 3 4 1 6 2 5 7 8 Another parallel stream: 6 3 1 5 7 8 4 2 With forEachOrdered: 8 7 6 5 4 3 2 1 副作用一个方法或一个表达式除了返回值及生成一个值,还有一个副作用就是会修改计算机的状态,如可变的reductions操作(collect操作)及System.out.println。JDK对某些副作用处理的很好,特别地,collect方法就是设计针对并行安全有副作用的场景下来执行最常见的stream操作。类似forEach、peek操作可以消除副作用;lambda表达式即使返回void,但如果内部调用了System.out.println,也会产生副作用。 延迟计算/惰性计算所有中间操作都是延迟执行的,表达式、方法或算法如果仅仅在需要的时候才计算其值,则就是延迟计算。中间操作是延迟计算因为当终结操作开始时,才会处理流中的数据。延迟处理流的机制让java编译器及运行时能够优化处理流的方式。比如filter-mapToInt-average流水线操作average可以先从mapToInt操作创建的流中获取几个数,mapToInt则是从filter操作获取元素,average操作则重复着这个流程直至获取所有的数据,然后计算平均值。 干扰流操作中的lambda表达式不应该有干扰。干扰发生在一个流水线处理流时,流的数据源被修改,如下例: try { List&lt;String&gt; listOfStrings = new ArrayList&lt;&gt;(Arrays.asList(&quot;one&quot;, &quot;two&quot;)); String concatenatedString = listOfStrings .stream() // 不要在处理流时,对流的数据源进行修改,会发生干扰,导致报错 .peek(s -&gt; listOfStrings.add(&quot;three&quot;)) .reduce((a, b) -&gt; a + &quot; &quot; + b) .get(); System.out.println(&quot;Concatenated string: &quot; + concatenatedString); } catch (Exception e) { System.out.println(&quot;Exception caught: &quot; + e.toString()); } 有状态的lambda表达式在流操作中避免使用有状态的lambda表达式当做参数,有状态的lambda表达式是指其结果依赖于在流水线执行过程中可能改变的任何状态,如下例: List&lt;Integer&gt; serialStorage = new ArrayList&lt;&gt;(); System.out.println(&quot;Serial stream:&quot;); listOfIntegers .stream() // 不要这么做,其使用了有状态的lambda表达式 .map(e -&gt; { serialStorage.add(e); return e; }) .forEachOrdered(e -&gt; System.out.print(e + &quot; &quot;)); System.out.println(&quot;&quot;); serialStorage .stream() .forEachOrdered(e -&gt; System.out.print(e + &quot; &quot;)); System.out.println(&quot;&quot;); System.out.println(&quot;Parallel stream:&quot;); List&lt;Integer&gt; parallelStorage = Collections.synchronizedList( new ArrayList&lt;&gt;()); listOfIntegers .parallelStream() // 使用了有状态的lambda表达式 .map(e -&gt; { parallelStorage.add(e); return e; }) .forEachOrdered(e -&gt; System.out.print(e + &quot; &quot;)); System.out.println(&quot;&quot;); parallelStorage .stream() .forEachOrdered(e -&gt; System.out.print(e + &quot; &quot;)); System.out.println(&quot;&quot;); lambda表达式 e -&gt; { parallelStorage.add(e); return e; } 是有状态的lambda表达式,因为每次代码运行其结果都会不同: Serial stream: 8 7 6 5 4 3 2 1 8 7 6 5 4 3 2 1 Parallel stream: 8 7 6 5 4 3 2 1 1 3 6 2 4 5 8 7 若想要可预测性及确定性结果,要确保流操作中的lambda表达式参数是无状态的。 注意:ArrayList是非线程安全的,即多个线程不能同时访问指定集合,否则会导致不可预料结果,如下: Parallel stream: 8 7 6 5 4 3 2 1 null 3 5 4 7 8 1 2 访问外部范围的局部变量 和局部和匿名类类似,lambda表达式也能够捕捉变量,也可以访问外部范围的局部变量,但是不会覆盖外部范围的局部变量。 这是因为lambda表达式从词法上被隔离,不会从超类继承任何变量,也不会引入新的变量作用范围, lambda表达式里声明的变量被封闭在lambda表达式里, 如下例: import java.util.function.Consumer; public class LambdaScopeTest { public int x = 0; class FirstLevel { public int x = 1; void methodInFirstLevel(int x) { Consumer&lt;Integer&gt; myConsumer = (y) -&gt; { System.out.println(&quot;x = &quot; + x); // Statement A System.out.println(&quot;y = &quot; + y); System.out.println(&quot;this.x = &quot; + this.x); System.out.println(&quot;LambdaScopeTest.this.x = &quot; + LambdaScopeTest.this.x); }; myConsumer.accept(x); } } public static void main(String... args) { LambdaScopeTest st = new LambdaScopeTest(); LambdaScopeTest.FirstLevel fl = st.new FirstLevel(); fl.methodInFirstLevel(23); } } x = 23 y = 23 this.x = 1 LambdaScopeTest.this.x = 0 假如把lambda表达式声明替换为如下: Consumer&lt;Integer&gt; myConsumer = (x) -&gt; { } 则会报x已定义的错,这是因为lambda表达式不会引入新的变量作用范围,因此在lambda表达式内部可以直接访问外部范围的字段、方法、局部变量,比如可以直接访问methodInFirstLevel方法形参x,但是要访问FirstLevel的字段x,则需要使用this. 目标类型lambda表达式的类型如何确定呢?是通过目标类型,即如public static void printPersons(List roster, CheckPerson tester)需要CheckPerson类型,则lambda表达式就是该类型(方法声明需要的参数类型)。 java编译器根据lambda表达式使用的上下文或场景里找到目标类型当做lambda表达式的类型,也就是lambda只能用在java编译器能确定目标类型的场景里: - 变量声明 - 赋值 - return 语句 - 数组初始化 - 方法或者构造函数参数 - lambda表达式体 - ? : 三元表达式 - 转换语句 对于方法参数,java编译器确定lambda表达式类型通过2个特征:重载解析&amp;类型参数推导 序列化如同非静态内部类一样,强烈建议禁止lambda表达式的序列化。 方法引用我们使用lambda表达式来创建匿名方法时,有时lambda表达式啥也没做只是调用了一个已经存在的方法,针对这些情形,通过方法名称来引用已经存在的方法更简洁直观,方法引用可以做到这点。 Arrays.sort(rosterAsArray, Person::compareByAge); 方法引用的种类 引用静态方法 ContainingClass::staticMethodName 引用非静态实例方法containingObject::instanceMethodName 引用某个类型的任意对象的实例方法 ContainingType::methodName,如String::compareToIgnoreCase 引用构造方法 ClassName::new","categories":[{"name":"lambda","slug":"lambda","permalink":"http://zhangxiangnan.com/categories/lambda/"}],"tags":[{"name":"lambda","slug":"lambda","permalink":"http://zhangxiangnan.com/tags/lambda/"}]},{"title":"静态内部类&非静态内部类&局部类&匿名类","slug":"java/静态内部类-非静态内部类-局部类-匿名类","date":"2018-01-18T11:22:06.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2018/01/18/java/静态内部类-非静态内部类-局部类-匿名类/","link":"","permalink":"http://zhangxiangnan.com/2018/01/18/java/静态内部类-非静态内部类-局部类-匿名类/","excerpt":"静态内部类&amp;非静态内部类&amp;局部类&amp;匿名类学习笔记","text":"静态内部类&amp;非静态内部类&amp;局部类&amp;匿名类学习笔记 内部类/嵌套类内部类的定义Java语言支持在一个类中定义其他类,叫做内部类,分为2种,若用static修饰,则是静态内部类,否则为非静态内部类,如: class OuterClass { static class StaticNestedClass { } class InnerClass { } } 注意: - 内部类是封闭类/外部类的一个成员,因此内部类可以被声明为private、public、protected、包级private(默认),而外部类只能用public、或包级private修饰。 - 非静态内部类可以访问外部类的成员,即时是私有成员,静态内部类则不能访问外部类的成员。 为什么用内部类 逻辑分类 如果一个类只会在另一个类中使用,那么将其嵌入到那个类中就很合理,也有利于包结构的精简 有助于封装 如果有A、B两个类,A的成员为私有,且B只会配合A使用,此时,B如果定义为单独的类就无法访问A的成员,但是如果把A嵌入到B中,则可以访问A的私有成员,且B也可以和外部隔离(因为B只会在A中使用)。 更高地可读性、可维护性 小的类嵌入到其他类中,可读性更强 静态内部类类似于方法和变量,静态内部类和外部类关联,如静态类方法一样,静态内部类不能直接引用外部类中定义的实例变量或方法,只能通过对象来间接引用。 注意:静态内部类和外部类的实例对象成员交互时和其他正常类一样,实际上静态内部类和其他正常类一样。 使用外部类名称来访问静态内部类,如: OuterClass.StaticNestedClass 创建静态内部类的对象实例语法如下: OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass(); 非静态内部类类似于实例方法和实例变量,非静态内部类和外部类的实例相关联,可以直接访问外部类实例的方法和字段,同时非静态内部类本身不能定义任何静态成员。 class OuterClass { class InnerClass { } } InnerClass的实例只能存在于OuterClass的实例中,同时能直接访问外部类实例的方法和字段。要实例化内部InnerClass类,必须首先实例化OuterClass外部类,然后使用以下语法在外部对象中创建内部类的对象: OuterClass.InnerClass innerObject = outerObject.new InnerClass(); 有两种特殊的非静态内部类,局部类&amp;匿名类 Shadowing如果在一个特定范围(如非静态内部类或者方法声明)中,一个类型的声明(如一个成员变量或者参数名称)与外部范围里的另一个声明名称一样的话,那么该类型声明会覆盖外部范围的声明。想要访问被覆盖的声明,仅仅用名称是不够的,如下: public class ShadowTest { public int x = 0; class FirstLevel { public int x = 1; void methodInFirstLevel(int x) { System.out.println(&quot;x = &quot; + x); System.out.println(&quot;this.x = &quot; + this.x); System.out.println(&quot;ShadowTest.this.x = &quot; + ShadowTest.this.x); } } public static void main(String... args) { ShadowTest st = new ShadowTest(); ShadowTest.FirstLevel fl = st.new FirstLevel(); fl.methodInFirstLevel(23); } } 结果: x = 23 this.x = 1 ShadowTest.this.x = 0 序列化强烈禁止非静态内部类、包括局部类及匿名类的序列化,这是因为编译器编译这些类时,会创建合成的构造方法,合成构造方法让java编译器能够实现新的java语言特征,而不需要改变jvm,但是由于不同的java编译器实现中合成的构造方法不同,所以序列化与反序列化时若使用的jre实现不同会遇到兼容性问题。 局部类局部类是定义在代码块中的类,代码块指{}之间的零个或多个语句,经常是在方法内部定义局部类 定义局部类本地类/局部类是指在代码块中定义的类,代码块指{}括起来的0个或多个语句的组合体,经常是在方法中定义局部类.可以在任何代码块中定义局部类,如可以在方法内部、for循环中、if语句中定局部类。如: public class LocalCalssTest { private int name ; public static void main(String[] args) { class LocalClass { private int age; } int age = new LocalClass().age; System.out.println(age); } } 访问外部类/封装类的成员局部类可以访问外部类/封装类的成员,上个例子中,LocalClass就可以访问name属性。此外,局部类也可以访问定义为final的局部变量或参数.jdk8后final或等效final(初始化后无更改指令)的都可以访问。jdk8开始,如果在方法中定义局部类,那么该局部类可以访问方法的参数。 覆盖局部类中一个类型或变量的声明会覆盖外部类中相同名字类型或变量的声明。 局部类类似于非静态内部类2者类似因为都不能定义或声明任何静态成员,静态方法里定义的局部类也仅只能访问外部类的静态成员。 代码块中不能定义接口,因为接口本质上是静态的,所以如下编译不通过: public void greetInEnglish() { interface HelloThere { public void greet(); } class EnglishHelloThere implements HelloThere { public void greet() { } } } 局部类中也不能定义静态的方法、静态成员,如下编译不通过: public void sayGoodbyeInEnglish() { class EnglishGoodbye { public static void sayGoodbye() { } } } 局部类可以有是常量变量的静态成员 - 常量变量指基本类型的变量,或声明为final的对象类型并且是使用编译期常量表达式初始化 - 编译期常量表达式指如string的&quot;&quot;初始化形式,或者表达式的值在编译器可以计算得到。 匿名类匿名类使代码更加简洁,可以同时进行类的声明和实例化,类似于局部类除了没名字,用于只使用局部类一次的情形。 声明匿名类局部类是有类声明的,匿名类是通过表达式来定义的,如下: public class HelloWorldAnonymousClasses { interface HelloWorld { public void greet(); } public void sayHello() { class EnglishGreeting implements HelloWorld { public void greet() { } } HelloWorld englishGreeting = new EnglishGreeting(); HelloWorld frenchGreeting = new HelloWorld() { public void greet() { greetSomeone(&quot;tout le monde&quot;); } }; } } 匿名类的语法匿名类是一个表达式,匿名类表达式的语法和构造函数的调用类似,只是在代码块中进行类定义: HelloWorld frenchGreeting = new HelloWorld() { public void greet() { } }; 匿名类表达式包含如下几部分: - new操作符 - 接口或抽象类的名称 - 圆括号把传递给构造函数的参数括起来,类似正常类实例的创建,接口无参数。 - 类声明的主体,允许定义方法,不能使用语句。 因为匿名类定义是一个表达式,表达式必须是语句的一部分,所以以分号结束。 声明及访问变量说明匿名类可以访问外部域的局部变量: 匿名类可以访问外部类的成员 匿名类不能访问外部范围中定义的非final或非等效final的局部变量 和嵌套类类型,匿名类中类型的声明如变量会覆盖外部范围中有相同名称的定义 匿名类中的成员定义和局部类一样也有约束: 匿名类中不能声明静态的成员(非final)、静态方法 匿名类可以声明是常量变量的静态成员。 匿名类中可以声明以下部分: 字段 额外的方法(未实现父类抽象方法或接口方法) 局部/本地类 实例初始化 匿名类中不能定义构造函数","categories":[{"name":"java","slug":"java","permalink":"http://zhangxiangnan.com/categories/java/"}],"tags":[{"name":"generics","slug":"generics","permalink":"http://zhangxiangnan.com/tags/generics/"},{"name":"java","slug":"java","permalink":"http://zhangxiangnan.com/tags/java/"},{"name":"javadoc","slug":"javadoc","permalink":"http://zhangxiangnan.com/tags/javadoc/"}]},{"title":"java注解详解","slug":"java/java注解详解","date":"2018-01-05T11:16:57.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2018/01/05/java/java注解详解/","link":"","permalink":"http://zhangxiangnan.com/2018/01/05/java/java注解详解/","excerpt":"java注解学习","text":"java注解学习 注解是元数据的一种形式,提供程序相关的数据,但不是程序本身的一部分,注解不会直接操作他们所标注的代码。 注解有很多用途: - 编译器所需的信息,如编译器可以用注解来检测错误或禁止警告 - 编译时或发布时处理,如软件工具可以处理注解信息来生成代码、xml文件等 - 运行时处理,某些注解在运行时也可以检测到 注解基本点注解的形式最简单的: @Entity @符号后的信息对编译器表明这是一个注解。 以下注解的名称是Override: @Override void mySuperMethod() { } 注解也可以包含元素,元素可以有名称,也可以没有名称,他们也有对应的值: @Author( name = &quot;Benjamin Franklin&quot;, date = &quot;3/27/2003&quot; ) class MyClass() { } @SuppressWarnings(value = &quot;unchecked&quot;) void myMethod() { } 如果只有一个命为value的元素,那么名称可以省略,如: @SuppressWarnings(&quot;unchecked&quot;) void myMethod() {} 如果注解没有元素,那么圆括号可以省略,如@Override注解的例子。 在相同声明的位置可以使用多个注解: @Author(name = &quot;Jane Doe&quot;) @EBook class MyClass { } 如果注解有相同的类型,称为可重复注解(&gt;=Jdk8): @Author(name = &quot;Jane Doe&quot;) @Author(name = &quot;John Smith&quot;) class MyClass { } 注解可以使用java.lang或java.lang.annotation包下定义的注解,也可以使用自定义注解。 注解可以用在哪儿注解可以用在声明的地方: - 类/接口(含注解类型)/枚举声明 - 方法声明 - 字段(含枚举常量)声明 - 形参声明 - 构造函数声明 - 本地变量声明 - 注解类型声明 - 包声明 - 类型参数声明 - 类型的使用 使用时注解约定占一行。 类型注解Java8中支持类型使用的注解,称为类型注解,如:实例化对象的表达式: new @Interned MyObject(); 类型强转: myString = (@NonNull String) str; implements子句: class UnmodifiableList&lt;T&gt; implements @Readonly List&lt;@Readonly T&gt; { } 异常声明: void monitorTemperature() throws @Critical TemperatureException { } 定义注解类型注解可以替换注释为代码,设想: public class Generation3List extends Generation2List { // Author: John Doe // Date: 3/17/2002 // Current revision: 6 // Last modified: 4/12/2004 // By: Jane Doe // Reviewers: Alice, Bill, Cindy // class code goes here } 将这些注释信息如何转化为一个注解?首先必须定一个注解类型,如下: @interface ClassPreamble { String author(); String date(); int currentRevision() default 1; String lastModified() default &quot;N/A&quot;; String lastModifiedBy() default &quot;N/A&quot;; // Note use of array String[] reviewers(); } 注解类型的定义有点像接口的声明,但是在interface关键字前加@符号。注解是接口的一种形式,其元素的声明像方法,可以指定默认值。 @ClassPreamble ( author = &quot;John Doe&quot;, date = &quot;3/17/2002&quot;, currentRevision = 6, lastModified = &quot;4/12/2004&quot;, lastModifiedBy = &quot;Jane Doe&quot;, // Note array notation reviewers = {&quot;Alice&quot;, &quot;Bob&quot;, &quot;Cindy&quot;} ) public class Generation3List extends Generation2List {} 注意:如果想在Javadoc生成的文档中包含@ClassPreamble中描述的信息,需要在其注解的定义上加@Documented注解。 @Documented @interface ClassPreamble { } 已有注解类型Java预先定义了一些注解,有些被java编译器使用,有些应用到其他注解中。 java语言使用的注解java.lang定义的注解为:@Deprecated, @Override, and @SuppressWarnings. @Deprecated该注解表明被标注的元素已过时,不该再被使用。使用有过时注解标注的方法、类、字段,编译器都会警告。如果元素过时,也应该使用Javadc的过时标记@deprecated来标注,两个注解一个大写,一个小写。 // Javadoc comment follows /** * @deprecated * explanation of why it was deprecated */ @Deprecated static void deprecatedMethod() { } @Override@Override注解通知编译器被标注元素覆盖了父类的元素: // 重写方法约定加覆盖注解 @Override int overriddenMethod() { } 虽然不强制使用覆盖标记,但是使用了有助于发现错误。 @SuppressWarnings@SuppressWarnings注解告诉编译器忽略可能产生的某种特定的警告,如下忽略了过时方法调用警告: @SuppressWarnings(&quot;deprecation&quot;) void useDeprecatedMethod() { // deprecation warning // - suppressed objectOne.deprecatedMethod(); } 每一种编译器警告都属于一个分类,java语言规范定义了2中分类:deprecation and unchecked. 想要忽略多种分类的警告,如下: @SuppressWarnings({&quot;unchecked&quot;, &quot;deprecation&quot;}) @SafeVarargs@SafeVarargs注解当使用在方法或构造函数上时,断言了代码不可能对可变参数执行潜在的不安全操作。当使用该注解后,跟可变参数使用相关的unchecked警告会被忽略。 @FunctionalInterface@FunctionalInterface在java8中引入,表明当前类型声明是一个函数接口。 应用到其他注解的注解这类注解成为元注解, java.lang.annnotation中定义的几个元注解如下: @Retention@Retention注解指明了被标记注解如何存储: - RetentionPolicy.SOURCE, 被标记注解仅仅在源文件级别保留,编译时被忽略 - RetentionPolicy.CLASS ,被标记注解在编译时被编译器保留,但是在JVM运行时被忽略 - RetentionPolicy.RUNTIME ,被标记注解被jvm保留,在运行时环境中可以使用 @Documented@Documented注解表示被标注的注解在使用Javadoc工具生成文档时会被记录到文档中,默认注解是不被记录的。 @Target@Target注解标记其他注解来限制注解可以应用的java元素,如: - ElementType.CONSTRUCTOR 可应用到构造函数上 - ElementType.FIELD 可应用到字段或属性上 - ElementType.LOCAL_VARIABLE 可应用到本地变量上 - ElementType.METHOD 可应用到方法级别的注解上 - ElementType.PACKAGE 可应用到包声明上 - ElementType.PARAMETER 可应用到方法的参数上 - ElementType.TYPE 可应用到类的任何元素上 @Inherited@Inherited表示注解可以从父类继承,默认不可以。 当用户查询注解类型时,若当前类没有该类型的注解,会接着查询父类的该注解。该注解只可用于类声明上。 @Repeatable@Repeatable在java8引入,表示被标记注解可以多次应用到相同声明或类型使用 类型注解&amp;可插拔类型系统Jdk8以前,注解只能应用在声明上,jdk8里注解可以应用到任何类型使用上,这意味着可以在你使用一个类型的任何地方使用。类型注解引入是为了提升java程序的分析来提供更强的类型检查,java8不提供类型检查框架,但是它允许我们来使用多个可插拔类型检查框架来配合java编译器进行更强大的类型检查。 如,想要确保某一个特定的变量不能被赋值为null,来避免NPE异常的话,可以编写一个自定义插件来检查这一点,类似如下: @NonNull String str; 可以加载多种插件来加强类型检查,减少错误。 可重复注解有些情形可能想要使用相同的注解多次,java8引入类型注解。如想要定义多个时间点执行方法,如下: @Schedule(dayOfMonth=&quot;last&quot;) @Schedule(dayOfWeek=&quot;Fri&quot;, hour=&quot;23&quot;) public void doPeriodicCleanup() { } 可重复注解可以在任何使用标准注解的地方使用,如也可在类声明上使用,如: @Alert(role=&quot;Manager&quot;) @Alert(role=&quot;Administrator&quot;) public class UnauthorizedAccessException extends SecurityException { } 为了兼容,可重复注解保存在java编译器自动生成的注解容器里,需要以下两步声明: 一是定义可重复注解: import java.lang.annotation.Repeatable; @Repeatable(Schedules.class) public @interface Schedule { String dayOfMonth() default &quot;first&quot;; String dayOfWeek() default &quot;Mon&quot;; int hour() default 12; } @Repeatable元注解圆括号里定义的是注解容器的类型,java编译器用来存储可重复注解。 这个例子里,注解容器是Scheudles,所以可重复注解@Schedule存储在@Schedules注解里。 二是声明容器枚举类型 容器枚举类型必须有一个数组类型的元素,数组的数据类型必须是可重复注解的类型,如: public @interface Schedules { Schedule[] value(); } 重新获取注解反射API中有几个方法可用来获取注解信息,返回一个单独注解的方法,如AnnotatedElement.getAnnotation(Class)的行为不变,因为仅仅返回请求类型的一个注解(如果存在),如果请求类型存在多个注解,可以先得到其容器注解。 java8也引入其他方法来遍历容器注解来一次获取多个注解,如AnnotatedElement.getAnnotationsByType(Class)。 设计考虑当设计注解类型时,必须考虑注解类型的使用次数,因为有了可重复注解,可使用多次;也可以通过@Target元注解来限制注解的使用元素范围。 总之,要让使用者使用起来尽可能灵活、强大。","categories":[{"name":"注解","slug":"注解","permalink":"http://zhangxiangnan.com/categories/注解/"}],"tags":[{"name":"注解","slug":"注解","permalink":"http://zhangxiangnan.com/tags/注解/"}]},{"title":"JAVA泛型","slug":"java/java泛型","date":"2017-12-18T12:46:15.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2017/12/18/java/java泛型/","link":"","permalink":"http://zhangxiangnan.com/2017/12/18/java/java泛型/","excerpt":"Java中的泛型详解！","text":"Java中的泛型详解！ 为什么用泛型泛型支持在定义类、接口、方法时将类型当作参数，称作类型参数/类型变量，和形参类似，形参是输入值不同，类型参数是输入类型不同。 编译时更强的类型检测，避免更多运行时异常，减少bug 消除强转 实现支持不同类型集合的泛型算法，更安全、易懂 泛型类型泛型是类型参数化的泛型类或接口。不用泛型时(可放各种类型，所以运行时强转时容易异常)： public class Box { private Object object; public void set(Object object) { this.object = object; } public Object get() { return object; } } 泛型类的定义： class name&lt;T1, T2, ..., Tn&gt; { } 例子： public class Box&lt;T&gt; { // T stands for &quot;Type&quot; private T t; public void set(T t) { this.t = t; } public T get() { return t; } } 类型变量T可以在类中任何地方使用，类型变量可以是任何非基本类型的类型：任意类类型、接口类型、以至另一个类型变量。 类型参数命名规范约定俗成，类型参数单字母、大写，常用的如下： E 元素 (java集合框架常用） K Key N Number T Type V Value S,U,V等 泛型调用及实例化泛型类型的调用(也称参数化类型)：Box integerBox;实例化： Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;(); Box&lt;Integer&gt; integerBox = new Box&lt;&gt;();//&gt;=jdk7 参数化类型类型参数也可以是参数化类型： OrderedPair&lt;String, Box&lt;Integer&gt;&gt; p = new OrderedPair&lt;&gt;(&quot;primes&quot;, new Box&lt;Integer&gt;(...)); 泛型方法泛型方法指引入类型参数的方法，在方法的返回类型之前声明，使用&lt;&gt;，可以有多个类型参数，适用于静态、非静态、构造方法。 public class Util { public static &lt;K, V&gt; boolean compare(Pair&lt;K, V&gt; p1, Pair&lt;K, V&gt; p2) { return p1.getKey().equals(p2.getKey()) &amp;&amp; p1.getValue().equals(p2.getValue()); } } public class Pair&lt;K, V&gt; { private K key; private V value; public Pair(K key, V value) { this.key = key; this.value = value; } public void setKey(K key) { this.key = key; } public void setValue(V value) { this.value = value; } public K getKey() { return key; } public V getValue() { return value; } } Pair&lt;Integer, String&gt; p1 = new Pair&lt;&gt;(1, &quot;apple&quot;); Pair&lt;Integer, String&gt; p2 = new Pair&lt;&gt;(2, &quot;pear&quot;); boolean same = Util.&lt;Integer, String&gt;compare(p1, p2); boolean same = Util.compare(p1, p2);//类型推导 有界（受限）类型参数 有些情况想限制类型参数的参数类型为某个类型或及其子类型，用extends表示. extends此处表示类的继承和接口的实现。 public &lt;U extends Number&gt; void inspect(U u){ System.out.println(&quot;T: &quot; + t.getClass().getName()); System.out.println(&quot;U: &quot; + u.getClass().getName()); } 有界类型参数可以调用界限类型里定义的方法，如： public class NaturalNumber&lt;T extends Integer&gt; { private T n; public NaturalNumber(T n) { this.n = n; } public boolean isEven() { return n.intValue() % 2 == 0; } // ... } 界限可以有多个，用&amp;连接，多个界限中最多只能有一个类；如果有一个类，多个接口，则该类必须在最左，如 （B1为类） 有界类型参数是泛型算法实现的关键，如： public interface Comparable&lt;T&gt; { public int compareTo(T o); } public static &lt;T extends Comparable&lt;T&gt;&gt; int countGreaterThan(T[] anArray, T elem) { int count = 0; for (T e : anArray) if (e.compareTo(elem) &gt; 0) ++count; return count; } 泛型&amp;继承&amp;子类型Box&lt;Number&gt; box = new Box&lt;Number&gt;(); box.add(new Integer(10)); // OK box.add(new Double(10.1)); // OK public void boxTest(Box&lt;Number&gt; n) { } boxTest(new Box(10)) //error,Box&lt;Integer&gt;、Box&lt;Double&gt;都不是Box&lt;Number&gt;的子类型。 A继承于B，但是不代表Class继承于Class 泛型的继承可以通过extends或implements来实现： ArrayList&lt;String&gt; -&gt; List&lt;String&gt; -&gt; Collection&lt;String&gt; 类型推导Java编译器从方法调用传入的类型以及对应的方法声明的参数类型来推断出使方法调用最合理的参数类型。 static &lt;T&gt; T pick(T a1, T a2) { return a2; } Serializable s = pick(&quot;d&quot;, new ArrayList&lt;String&gt;()) 有了类型推导，在泛型方法调用、实例化泛型类、泛型类/非泛型类的泛型构造方法调用都可以省略。类型推导只通过调用参数、目标类型、返回值类型来推导，而不是用程序后续的结果类型。 通配符泛型中，问号标记“？”叫通配符，表示一种未知类型，通配符可以用在以下情形：参数的类型、字段、本地变量、返回值；不用于泛型方法调用的类型参数、泛型类的创建、父类型。 上限通配符上限通配符用来放宽变量的限制，比如想定义一个方法，适用于 List, List, and List类型。 public static void process(List&lt;? extends Number&gt;) {} List限制所有类型只能为Number，但List&lt;? extends Number&gt;可匹配Number及Number子类型，并且每个元素都可以调用Number类里的方法。 无界通配符使用?定义，如List&lt;?&gt;，称作未知类型的list，适用场合： 如果在写一个可以使用Object类中的功能实现的方法 当代码在泛型中使用不依赖类型参数的方法，如List.size List.clear，实际上Class&lt;?&gt;最常用，因为Class里的多数方法不依俩T。 // 不适用于List、List等public static void printList(List list) { for (Object elem : list) System.out.println(elem + &quot; &quot;); System.out.println();} // 打印，适合任务类型public static void printList(List&lt;?&gt; list) { for (Object elem: list) System.out.print(elem + &quot; &quot;); System.out.println();} List&lt;?&gt;与List不一样，List可以往里面添加Object、及Object的任务子类型，但是List&lt;?&gt;声明的变量只能往里添加null。 下界通配符下届通配符用 ? super Foo 表示只能是Foo或Foo的父类型，不能同时声明下届和上界。 List和List&lt;? super Integer&gt;不一样，List匹配Integer的列表，但是List&lt;? super Integer&gt;匹配Integer及Integer的父类型。 通配符和子类型A extends B，但是Class和Class没有继承关系，如何让两者有关系？ List&lt;? extends Integer&gt; intList = new ArrayList&lt;&gt;(); List&lt;? extends Number&gt; numList = intList; // OK. List&lt;? extends Integer&gt;是List&lt;? extends Number&gt;的子类型 List&lt;?&gt;是List和List的父类型。 List -&gt; List&lt;? extends Integer&gt; -&gt; List&lt;? extends Number&gt; -&gt; List&lt;?&gt; List -&gt; List&lt;? super Number&gt; -&gt; List&lt;? super Integer&gt; -&gt; List&lt;?&gt; List -&gt; List&lt;? extends Number&gt; List -&gt; List&lt;? super Integer&gt; 通配符捕获和辅助方法有些情况下，编译器可以捕获到通配符的类型，这种叫通配符捕捉。 public class WildcardError { void foo(List&lt;?&gt; i) { i.set(0, i.get(0));//报包含capture of ?的错误 } } 添加辅助方法来解决： public class WildcardFixed { void foo(List&lt;?&gt; i) { fooHelper(i); } // 创建辅助方法以便可以通过类型推导来进行通配符类型捕获 private &lt;T&gt; void fooHelper(List&lt;T&gt; l) { l.set(0, l.get(0)); } } 通配符的使用场合何时使用上界通配符、何时使用下界通配符？首先通配符主要用在方法的形式参数声明上，应避免使用在方法返回类型上（调用者需要处理通配符） 输入变量(In)就是一个提供数据给代码使用的变量，如拷贝方法copy(src, dst)，src就是输入变量，因为src提供了用来拷贝的数据（producer）； 输出变量(Out)就是一个保存数据以便在其他地方使用的变量，如copy方法的dst变量，数据拷贝到了dst接受了拷贝的数据(consumer) 又用于输入且用于输出的变量 使用指南（方法的参数声明）： 输入变量使用上界通配符，extends，此时变量只读 输出变量使用下界通配符，super，此时变量只可写 针对输入变量可以使用Object类里定义的方法访问时，使用无界通配符 当代码同时需要将变量当作输入、输出变量时，不使用通配符 以上描述总结出PECS－Producer extends, consumer super. List&lt;? extends …&gt;定义的变量可以认为只读，但是不是严格意义的只读，只是说不能修改已有元素、不能新增元素，但是仍可以执行如下： clear 插入null 迭代与删除 通过通配符捕捉来写入元素 类型擦除Java引入泛型来加强编译器类型检查以及支持泛型编程，java使用类型擦除来实现泛型： 替换泛型类型中所有的类型参数为他们的边界类型或者为Object（类型参数无界时）,因为生成的字节码都是普通的类、接口、方法 如果需要保持类型安全，插入类型转换指令 生成桥接方法来保持泛型类型继承中的多态性 java针对参数化类型不会生成新的类，所以泛型不会产生运行时开销。 泛型类型擦除类型擦除时，编译器擦除所有的类型参数，并每个都使用最左边界类型或者Object(无界类型)来替换 ，Node中T是无界通配符。 泛型方法擦除泛型方法擦除时，和类型擦除一样。 桥接方法如下： public class Node { public T data; public Node(T data) { this.data = data; } public void setData(T data) { System.out.println(“Node.setData”); this.data = data; } } public class MyNode extends Node { public MyNode(Integer data) { super(data); } public void setData(Integer data) { System.out.println(“MyNode.setData”); super.setData(data); } } 类型擦除后： public class Node { public Object data; public Node(Object data) { this.data = data; } public void setData(Object data) { System.out.println(&quot;Node.setData&quot;); this.data = data; } } public class MyNode extends Node { public MyNode(Integer data) { super(data); } public void setData(Integer data) { System.out.println(&quot;MyNode.setData&quot;); super.setData(data); } } 擦除后setData方法不能覆盖父类的setData方法，为了保持泛型类型在擦除后的多态特性，java编译器自动生成桥接方法如下： class MyNode extends Node { //桥接方法 public void setData(Object data) { setData((Integer) data); } public void setData(Integer data) { System.out.println(&quot;MyNode.setData&quot;); super.setData(data); } } 泛型的限制不能使用基本类型实例化泛型类型Pair&lt;int, char&gt; p = new Pair&lt;&gt;(8, &apos;a&apos;);//error Pair&lt;Integer, Character&gt; p = new Pair&lt;&gt;(8, &apos;a&apos;);// 8，&apos;a&apos;会自动装箱 不能创建类型参数的实例public static &lt;E&gt; void append(List&lt;E&gt; list) { E elem = new E(); // compile-time error list.add(elem); } public static &lt;E&gt; void append(List&lt;E&gt; list, Class&lt;E&gt; cls) throws Exception { E elem = cls.newInstance(); // 反射可以实现 list.add(elem); } 不能声明类型为类型参数的静态字段public class MobileDevice&lt;T&gt; { private static T os;//编译错误 } 因为静态字段是所有类的实例共享，多个实例实例化时传入不同的T类型，则无法确定os字段属于哪一个类型。 针对参数化类型不能使用cast或instanceofpublic static &lt;E&gt; void rtti(List&lt;E&gt; list) { if (list instanceof ArrayList&lt;Integer&gt;) { //编译错误 } } public static void rtti(List&lt;?&gt; list) { if (list instanceof ArrayList&lt;?&gt;) { // 无界通配符OK; instanceof需要一个具体化的类型 } } List&lt;Integer&gt; li = new ArrayList&lt;&gt;(); List&lt;Number&gt; ln = (List&lt;Number&gt;) li; //编译错误 List&lt;String&gt; l1 = ...; ArrayList&lt;String&gt; l2 = (ArrayList&lt;String&gt;)l1; // OK 不能创建参数化的数组类型List&lt;Integer&gt;[] arrayOfLists = new List&lt;Integer&gt;[2]; //编译错误，数组声明时需要具体化的类型 不能创建、捕获、抛出序列化类型的对象// 不能隐式地继承Throwable class MathException&lt;T&gt; extends Exception { } // compile-time error // 不能显式地继承Throwable class QueueFullException&lt;T&gt; extends Throwable { } // compile-time error // 不能创建类型参数的实例 public static &lt;T extends Exception, J&gt; void execute(List&lt;J&gt; jobs) { try { for (J job : jobs) // ... } catch (T e) { // compile-time error // ... } } 可以在throws子句中使用类型参数 class Parser&lt;T extends Exception&gt; { public void parse(File file) throws T { // OK } } 形式类型参数擦除后类型一样的不能重载public class Example { public void print(Set&lt;String&gt; strSet) { } public void print(Set&lt;Integer&gt; intSet) { } } 非具体化类型 具体化类型是指运行时完全可以获取到其类型信息的类型，如基本类型、非泛型类型、裸（原始）类型、或者无界通配符的调用。 非具体化类型是指编译时类型信息被擦除,如泛型类型的调用（无界通配符除外），非具化类型运行时没有足够的类型信息。如JVM运行时无法区分List、List。非具化类型不能用于：instaceof表达式、或者作为数组的元素。 堆污染当参数化类型的变量引用非参数化类型的对象时，就会发生堆污染。在编译或运行时如果无法验证包含参数话类型当操作如转换、调用的正确性，就会报未经检查的警告，需要引起注意。","categories":[{"name":"java","slug":"java","permalink":"http://zhangxiangnan.com/categories/java/"}],"tags":[{"name":"generics","slug":"generics","permalink":"http://zhangxiangnan.com/tags/generics/"},{"name":"java","slug":"java","permalink":"http://zhangxiangnan.com/tags/java/"}]},{"title":"JAVA反射之字段&方法&构造函数","slug":"java/JAVA反射之字段&方法&构造函数详解","date":"2017-04-12T12:32:02.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2017/04/12/java/JAVA反射之字段&方法&构造函数详解/","link":"","permalink":"http://zhangxiangnan.com/2017/04/12/java/JAVA反射之字段&方法&构造函数详解/","excerpt":"反射中字段、方法、构造函数的学习","text":"反射中字段、方法、构造函数的学习 反射定义了一个接口java.lang.reflect.Member，java.lang.reflect.Field、java.lang.reflect.Method、java.lang.reflect.Constructor都实现了该接口。 注意:根据java7的语言规范，类的成员是类体可继承的组件，包括fields、methods、nested classes、interfaces及枚举类型。由于构造函数不能被继承，他们不是成员。这和java.lang.reflect.Member的实现类不同。 字段字段有一个类型和值，java.lang.reflect.Field类提供了访问类型信息和设置、获取某个对象的某字段值的方法。 获取字段类型一个字段要么是基本类型，要么是引用类型。有8中基本类型：boolean, byte, short, int, long, char, float, and double. 引用类型是直接或间接继承java.lang.Object类的子类，包括接口、数组及枚举类型。 如下是一个输出不同类型字段的类型及泛华类型的展示： import java.lang.reflect.Field; import java.util.List; public class FieldSpy&lt;T&gt; { public boolean[][] b = {{ false, false }, { true, true } }; public String name = &quot;Alice&quot;; public List&lt;Integer&gt; list; public T val; public static void main(String... args) { try { Class&lt;?&gt; c = Class.forName(args[0]); Field f = c.getField(args[1]); System.out.format(&quot;Type: %s%n&quot;, f.getType()); System.out.format(&quot;GenericType: %s%n&quot;, f.getGenericType()); } catch (ClassNotFoundException x) { x.printStackTrace(); } catch (NoSuchFieldException x) { x.printStackTrace(); } } } $ java FieldSpy FieldSpy b Type: class [[Z GenericType: class [[Z $ java FieldSpy FieldSpy name Type: class java.lang.String GenericType: class java.lang.String $ java FieldSpy FieldSpy list Type: interface java.util.List GenericType: java.util.List&lt;java.lang.Integer&gt; $ java FieldSpy FieldSpy val Type: class java.lang.Object GenericType: T 说明:字段b的类型时boolean类型的二维数组，类型名称的语法规则根据Class.getName()。字段val的类型时java.lang.Object，因为泛型的信息会在编译期间擦除泛型的相关信息。T被类型变量的上层限制替代，这里是java.lang.Object.Field.getGenericType()方法会在类文件中查找签名属性（如果存在）。如果签名属性不存在，会返回Field.getType()的值（没有因为引入泛型发生改变）。反射的其他名称为getGenericFoo的方法实现思路类似。 获取&amp;解析字段的修饰符字段声明时允许的几个修饰符： 访问修饰符: public, protected, and private 管理运行时行为的修饰符： transient and volatile 限制到一个实例的修饰符: static 禁止修改值的修饰符：final 注解Field.getModifiers()方法用来一个整数值，代表该字段声明的修饰符集（一个或多个修饰符），该整数值中位表示的修饰符在java.lang.reflect.Modifier定义。下例展示了如何根据给定的修饰符查找字段，以及判断字段是否是合成（编译器生成的）及是否是枚举常量 import java.lang.reflect.Field;import java.lang.reflect.Modifier;import static java.lang.System.out; enum Spy { BLACK , WHITE } public class FieldModifierSpy { volatile int share; int instance; class Inner {} public static void main(String... args) { try { Class&lt;?&gt; c = Class.forName(args[0]); int searchMods = 0x0; for (int i = 1; i &lt; args.length; i++) { searchMods |= modifierFromString(args[i]); } Field[] flds = c.getDeclaredFields(); out.format(&quot;Fields in Class &apos;%s&apos; containing modifiers: %s%n&quot;, c.getName(), Modifier.toString(searchMods)); boolean found = false; for (Field f : flds) { int foundMods = f.getModifiers(); // Require all of the requested modifiers to be present if ((foundMods &amp; searchMods) == searchMods) { out.format(&quot;%-8s [ synthetic=%-5b enum_constant=%-5b ]%n&quot;, f.getName(), f.isSynthetic(), f.isEnumConstant()); found = true; } } if (!found) { out.format(&quot;No matching fields%n&quot;); } // production code should handle this exception more gracefully } catch (ClassNotFoundException x) { x.printStackTrace(); } } private static int modifierFromString(String s) { int m = 0x0; if (&quot;public&quot;.equals(s)) m |= Modifier.PUBLIC; else if (&quot;protected&quot;.equals(s)) m |= Modifier.PROTECTED; else if (&quot;private&quot;.equals(s)) m |= Modifier.PRIVATE; else if (&quot;static&quot;.equals(s)) m |= Modifier.STATIC; else if (&quot;final&quot;.equals(s)) m |= Modifier.FINAL; else if (&quot;transient&quot;.equals(s)) m |= Modifier.TRANSIENT; else if (&quot;volatile&quot;.equals(s)) m |= Modifier.VOLATILE; return m; } } $ java FieldModifierSpy FieldModifierSpy volatile Fields in Class &apos;FieldModifierSpy&apos; containing modifiers: volatile share [ synthetic=false enum_constant=false ] $ java FieldModifierSpy Spy public Fields in Class &apos;Spy&apos; containing modifiers: public BLACK [ synthetic=false enum_constant=true ] WHITE [ synthetic=false enum_constant=true ] $ java FieldModifierSpy FieldModifierSpy\\$Inner final Fields in Class &apos;FieldModifierSpy$Inner&apos; containing modifiers: final this$0 [ synthetic=true enum_constant=false ] $ java FieldModifierSpy Spy private static final Fields in Class &apos;Spy&apos; containing modifiers: private static final $VALUES [ synthetic=true enum_constant=false ]// 枚举类有private static final类型的合成字段$VALUES 注意编译器会生成一些合成的运行时需要的字段，可使用Field.isSynthetic()来判断是否合成字段，合成的字段根据编译器不同不同。然而内部类引入this$0字段 (即嵌套类为非静态成员类）来持有最外层类的引用；枚举类引入$VALUES字段实现隐式地定义静态方法values().合成的类成员的名字未被指定，不同的编译器实现或不同版本中可能不同。Class.getDeclaredFields()方法会返回包含合成字段的数组，但是Class.getField()方法不会返回，因为合成字段通常不是public的。因为Field字段实现了接口java.lang.reflect.AnnotatedElement，因此运行时能够获取到保留策略为java.lang.annotation.RetentionPolicy.RUNTIME的注解信息。 设置&amp;获取字段值给定某个类的一个实例，是能够用反射来设置类的字段的值。这通常仅在特殊情况下不能够以常规方式设置值。因为这么做破坏了类的设计意图，应该慎用。示例： import java.lang.reflect.Field; import java.util.Arrays; import static java.lang.System.out; enum Tweedle { DEE, DUM } public class Book { public long chapters = 0; public String[] characters = { &quot;Alice&quot;, &quot;White Rabbit&quot; }; public Tweedle twin = Tweedle.DEE; public static void main(String... args) { Book book = new Book(); String fmt = &quot;%6S: %-12s = %s%n&quot;; try { Class&lt;?&gt; c = book.getClass(); Field chap = c.getDeclaredField(&quot;chapters&quot;); out.format(fmt, &quot;before&quot;, &quot;chapters&quot;, book.chapters); chap.setLong(book, 12); out.format(fmt, &quot;after&quot;, &quot;chapters&quot;, chap.getLong(book)); Field chars = c.getDeclaredField(&quot;characters&quot;); out.format(fmt, &quot;before&quot;, &quot;characters&quot;, Arrays.asList(book.characters)); String[] newChars = { &quot;Queen&quot;, &quot;King&quot; }; chars.set(book, newChars); out.format(fmt, &quot;after&quot;, &quot;characters&quot;, Arrays.asList(book.characters)); Field t = c.getDeclaredField(&quot;twin&quot;); out.format(fmt, &quot;before&quot;, &quot;twin&quot;, book.twin); t.set(book, Tweedle.DUM); out.format(fmt, &quot;after&quot;, &quot;twin&quot;, t.get(book)); // production code should handle these exceptions more gracefully } catch (NoSuchFieldException x) { x.printStackTrace(); } catch (IllegalAccessException x) { x.printStackTrace(); } } } $ java Book BEFORE: chapters = 0 AFTER: chapters = 12 BEFORE: characters = [Alice, White Rabbit] AFTER: characters = [Queen, King] BEFORE: twin = DEE AFTER: twin = DUM 注意：通过反射设置字段的值有一定的性能开销，因为必须进行各种操作，比如访问权限验证。从运行时角度看，效果一样，并且操作就像在代码中直接改变值一样是原子性的。反射的使用会导致丢失一些运行时优化，如下代码很可能被虚拟机优化，但是使用Field.set*()就不会进行优化。 int x = 1; x = 2; x = 3; 常见代码错误IllegalArgumentException由于不可转换类型（due to Inconvertible Types）当使用反射给引用类型的整数赋值基本类型的数值时，就会报该错误。不是用反射的话，编译器会执行自动装箱操作，将基本类型装箱为引用类型，这样类型检查就没问题，但是用反射的话，类型检查只发生在运行时，没有机会去执行装箱操作。 import java.lang.reflect.Field; public class FieldTrouble { public Integer val; public static void main(String... args) { FieldTrouble ft = new FieldTrouble(); try { Class&lt;?&gt; c = ft.getClass(); Field f = c.getDeclaredField(&quot;val&quot;); f.setInt(ft, 42); // IllegalArgumentException // production code should handle these exceptions more gracefully } catch (NoSuchFieldException x) { x.printStackTrace(); } catch (IllegalAccessException x) { x.printStackTrace(); } } } $ java FieldTrouble Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Can not set java.lang.Object field FieldTrouble.val to (long)42 at sun.reflect.UnsafeFieldAccessorImpl.throwSetIllegalArgumentException (UnsafeFieldAccessorImpl.java:146) at sun.reflect.UnsafeFieldAccessorImpl.throwSetIllegalArgumentException (UnsafeFieldAccessorImpl.java:174) at sun.reflect.UnsafeObjectFieldAccessorImpl.setLong (UnsafeObjectFieldAccessorImpl.java:102) at java.lang.reflect.Field.setLong(Field.java:831) at FieldTrouble.main(FieldTrouble.java:11) 解决办法： f.set(ft, new Integer(43)); 提示：当时使用反射设&amp;获取一个字段的值的时候，编译器没机会来执行装箱操作。编译器只能转换Class.isAssignableFrom()方法的规范描述的相关转换。如下： Integer.class.isAssignableFrom(int.class) == false// 反射时引用类型到基本类型不成功 int.class.isAssignableFrom(Integer.class) == false// 反射时基本类型到引用类型不成功 NoSuchFieldException for Non-Public Fields$ java FieldSpy java.lang.String count java.lang.NoSuchFieldException: count at java.lang.Class.getField(Class.java:1519) at FieldSpy.main(FieldSpy.java:12) 提示：Class.getField()及Class.getFields()方法返回class对象代表的类、枚举、接口的公共成员方法。想获取类声明的所有方法（不是继承），使用Class.getDeclaredFields()方法。 IllegalAccessException when Modifying Final Fields如果尝试获取&amp;设置私有或其他无法访问的字段的值，或设置final字段的值（不论修饰符是什么）可能会抛出IllegalAccessException异常。 import java.lang.reflect.Field; public class FieldTroubleToo { public final boolean b = true; public static void main(String... args) { FieldTroubleToo ft = new FieldTroubleToo(); try { Class&lt;?&gt; c = ft.getClass(); Field f = c.getDeclaredField(&quot;b&quot;); // f.setAccessible(true); // solution f.setBoolean(ft, Boolean.FALSE); // IllegalAccessException // production code should handle these exceptions more gracefully } catch (NoSuchFieldException x) { x.printStackTrace(); } catch (IllegalArgumentException x) { x.printStackTrace(); } catch (IllegalAccessException x) { x.printStackTrace(); } } } $ java FieldTroubleToo java.lang.IllegalAccessException: Can not set final boolean field FieldTroubleToo.b to (boolean)false at sun.reflect.UnsafeFieldAccessorImpl. throwFinalFieldIllegalAccessException(UnsafeFieldAccessorImpl.java:55) at sun.reflect.UnsafeFieldAccessorImpl. throwFinalFieldIllegalAccessException(UnsafeFieldAccessorImpl.java:63) at sun.reflect.UnsafeQualifiedBooleanFieldAccessorImpl.setBoolean (UnsafeQualifiedBooleanFieldAccessorImpl.java:78) at java.lang.reflect.Field.setBoolean(Field.java:686) at FieldTroubleToo.main(FieldTroubleToo.java:12) 提示：class初始化后，存在一个访问限制组织修改final字段值。Field声明为继承自AccessibleObject，提供了方法来抑制此检查。但这会产生副作用；如有时即使值已经被修改，但是程序的其他部分仍可能使用旧值。AccessibleObject.setAccessible()仅在安全上下文允许的情况下才能成功。 方法方法拥有返回值、参数、及可能抛出异常。java.lang.reflect.Method类提供了获取参数和返回值的类型信息的方法，也经常用来执行指定对象的方法。 获取方法类型信息一个字段要么是基本类型要么是引用类型，有8中基本类型：boolean、byte、short、int、long、char、float、double。一个引用类型指直接或间接继承java.lang.Object类包括接口、数组、枚举类型的任意对象。 import java.lang.reflect.Field; import java.util.List; public class FieldSpy&lt;T&gt; { public boolean[][] b = {{ false, false }, { true, true } }; public String name = &quot;Alice&quot;; public List&lt;Integer&gt; list; public T val;// 参数化类型 public static void main(String... args) { try { Class&lt;?&gt; c = Class.forName(args[0]); Field f = c.getField(args[1]); System.out.format(&quot;Type: %s%n&quot;, f.getType()); System.out.format(&quot;GenericType: %s%n&quot;, f.getGenericType()); // production code should handle these exceptions more gracefully } catch (ClassNotFoundException x) { x.printStackTrace(); } catch (NoSuchFieldException x) { x.printStackTrace(); } } } $ java FieldSpy FieldSpy b Type: class [[Z GenericType: class [[Z $ java FieldSpy FieldSpy name Type: class java.lang.String GenericType: class java.lang.String $ java FieldSpy FieldSpy list Type: interface java.util.List GenericType: java.util.List&lt;java.lang.Integer&gt; $ java FieldSpy FieldSpy val Type: class java.lang.Object GenericType: T 字段b是二维boolean数组，其类型名称的语法在Class.getName()描述。字段val的类型结果是继承自java.lang.Object，因为通过类型擦除实现泛型，在编译期间删除删除有关泛型的信息。所以T被类型变量的上界替换，该例是java.lang.Object. Field.getGenericType()在类文件中查找签名属性（如果存在），如果不存在，会降级为Field.getType()（没有因为泛型导致被改变）。反射中其他有类似getGenericFoo方法来获取Foo的某个值的实现都类似。 获取方法或构造函数参数的名称和其他信息可以使用java.lang.reflect.Executable.getParameters方法来获取任何方法或构造函数的形式参数(Method和Constructor类继承了Executable，因此继承了Executable.getParameters方法)然而，.class文件不保存默认不保存形参名称。这是因为许多生成和使用类的工具不希望更大的静态或动态的包含参数名称的类文件占位。尤其，这些工具不得不处理更大的.class类文件，JVM也会使用更多的内存。另外，某些参数名称，如secret、password可能暴露安全敏感的方法信息。 为了在制定类文件中保存形参名称，这样就能够在反射时拿到这些形参的名称，可以使用-parameters配置javac编译器来编译源文件。 import java.lang.reflect.`*`; import java.util.function.`*`; import static java.lang.System.out; public class MethodParameterSpy { private static final String fmt = &quot;%24s: %s%n&quot;; &lt;E extends RuntimeException&gt; void genericThrow() throws E {} public static void printClassConstructors(Class c) { Constructor[] allConstructors = c.getConstructors(); out.format(fmt, &quot;Number of constructors&quot;, allConstructors.length); for (Constructor currentConstructor : allConstructors) { printConstructor(currentConstructor); } Constructor[] allDeclConst = c.getDeclaredConstructors(); out.format(fmt, &quot;Number of declared constructors&quot;, allDeclConst.length); for (Constructor currentDeclConst : allDeclConst) { printConstructor(currentDeclConst); } } public static void printClassMethods(Class c) { Method[] allMethods = c.getDeclaredMethods(); out.format(fmt, &quot;Number of methods&quot;, allMethods.length); for (Method m : allMethods) { printMethod(m); } } public static void printConstructor(Constructor c) { out.format(&quot;%s%n&quot;, c.toGenericString()); Parameter[] params = c.getParameters(); out.format(fmt, &quot;Number of parameters&quot;, params.length); for (int i = 0; i &lt; params.length; i++) { printParameter(params[i]); } } public static void printMethod(Method m) { out.format(&quot;%s%n&quot;, m.toGenericString()); out.format(fmt, &quot;Return type&quot;, m.getReturnType()); out.format(fmt, &quot;Generic return type&quot;, m.getGenericReturnType()); Parameter[] params = m.getParameters(); for (int i = 0; i &lt; params.length; i++) { printParameter(params[i]); } } public static void printParameter(Parameter p) { out.format(fmt, &quot;Parameter class&quot;, p.getType()); out.format(fmt, &quot;Parameter name&quot;, p.getName()); out.format(fmt, &quot;Modifiers&quot;, p.getModifiers()); out.format(fmt, &quot;Is implicit?&quot;, p.isImplicit());// out.format(fmt, &quot;Is name present?&quot;, p.isNamePresent());//参数名字是否存在 out.format(fmt, &quot;Is synthetic?&quot;, p.isSynthetic());//是否自动生成 } public static void main(String... args) { try { printClassConstructors(Class.forName(args[0])); printClassMethods(Class.forName(args[0])); } catch (ClassNotFoundException x) { x.printStackTrace(); } } } import java.util.`*`; public class ExampleMethods&lt;T&gt; { public boolean simpleMethod(String stringParam, int intParam) { System.out.println(&quot;String: &quot; + stringParam + &quot;, integer: &quot; + intParam); return true; } public int varArgsMethod(String... manyStrings) { return manyStrings.length; } public boolean methodWithList(List&lt;String&gt; listParam) { return listParam.isEmpty(); } public &lt;T&gt; void genericMethod(T[] a, Collection&lt;T&gt; c) { System.out.println(&quot;Length of array: &quot; + a.length); System.out.println(&quot;Size of collection: &quot; + c.size()); } } 执行命令： java MethodParameterSpy ExampleMethods 输出： Number of constructors: 1 Constructor #1 public ExampleMethods() Number of declared constructors: 1 Declared constructor #1 public ExampleMethods() Number of methods: 4 Method #1 public boolean ExampleMethods.simpleMethod(java.lang.String,int) Return type: boolean Generic return type: boolean Parameter class: class java.lang.String Parameter name: stringParam Modifiers: 0 Is implicit?: false Is name present?: true Is synthetic?: false Parameter class: int Parameter name: intParam Modifiers: 0 Is implicit?: false Is name present?: true Is synthetic?: false Method #2 public int ExampleMethods.varArgsMethod(java.lang.String...) Return type: int Generic return type: int Parameter class: class [Ljava.lang.String; Parameter name: manyStrings Modifiers: 0 Is implicit?: false Is name present?: true Is synthetic?: false Method #3 public boolean ExampleMethods.methodWithList(java.util.List&lt;java.lang.String&gt;) Return type: boolean Generic return type: boolean Parameter class: interface java.util.List Parameter name: listParam Modifiers: 0 Is implicit?: false Is name present?: true Is synthetic?: false Method #4 public &lt;T&gt; void ExampleMethods.genericMethod(T[],java.util.Collection&lt;T&gt;) Return type: void Generic return type: void Parameter class: class [Ljava.lang.Object; Parameter name: a Modifiers: 0 Is implicit?: false Is name present?: true Is synthetic?: false Parameter class: interface java.util.Collection Parameter name: c Modifiers: 0 Is implicit?: false Is name present?: true Is synthetic?: false getType: 返回参数的声明类型的Class类 getName: 返回参数的名字。如果名字存在，则返回.class类文件返回的名称，否则该方法返回自动生成的名称，形式如argN，N是定义该参数的方法的参数的索引。 例如，假如没有指定-parameters编译配置来编译类文件，则如下输出： public boolean ExampleMethods.simpleMethod(java.lang.String,int) Return type: boolean Generic return type: boolean Parameter class: class java.lang.String Parameter name: arg0 Modifiers: 0 Is implicit?: false Is name present?: false Is synthetic?: false Parameter class: int Parameter name: arg1 Modifiers: 0 Is implicit?: false Is name present?: false Is synthetic?: false getModifiers :返回形参具有的各种特征表示的整数，该数值是下列值的和，如果应用于形式参数： Value (in decimal) Value (in hexadecimal) Description 16 0x0010 形参定义为final 4096 0x1000 形参是synthetic合成的. 或者可以调用方法isSynthetic. 32768 0x8000 形参在源码中声明为隐式的，或者可以调用isImplicit方法。 isImplicit: 返回源码中声明的参数是否是隐性的 isNamePresent: 根据.class类文件来决定形参是否有一个名字，有返回true。 isSynthetic: 如果源码中声明的参数既不是隐性的也不是明确在源码定义的则返回true。 隐性和合成参数 某些构造函数是如果没有被显示声明则会在源码中隐性声明。如ExampleMethods例子无构造函数，一个默认构造函数就会隐性声明。MethodParameterSpy例子打印的隐性声明构造函数如下： Number of declared constructors: 1 public ExampleMethods() 考虑如下片段： public class MethodParameterExamples { public class InnerClass { } } InnerClass是一个非京台嵌套类或内部类。内部类的有个构造函数也是隐性声明的。然而，该隐性构造包含一个参数，当java编译器编译内部类时，会生成一个类似下面的： public class MethodParameterExamples { public class InnerClass { final MethodParameterExamples parent; InnerClass(final MethodParameterExamples this$0) { parent = this$0; } } } InnerClass构造包含一个参数，参数类型是包含内部类InnerClass的类，即MethodParameterExamples。参照如下输出: public MethodParameterExamples$InnerClass(MethodParameterExamples) Parameter class: class MethodParameterExamples Parameter name: this$0 Modifiers: 32784 Is implicit?: true Is name present?: true Is synthetic?: false 因为InnerClass类的构造函数是隐性指定的，所以参数也是隐性的。注意：Java编译器为内部类的构造函数创建一个形式参数，以使编译器能够将创建表达式中的引用（表示直接包含的实例）传递给成员类的构造函数。值32784表示InnerClass构造函数的参数同时是finla（16）和隐性的（32768）。Java语言允许变量名称含有$符号，但是约定来说，在变量名称中不用$符号。Java编译器提供的构造函数如果他们不能对应到源码里明确地或隐含的构造函数，则就是是synthetic合成的，除非他们是类初始化方法。合成的构造函数根据不同的编译器实现而不同。考虑如下： public class MethodParameterExamples { enum Colors { RED, WHITE; } } Java编译器针对该类会生成几个方法，兼容.class类文件结构，并提供enum构造预期的功能。如，Java编译器会创建一个类文件如下： final class Colors extends java.lang.Enum&lt;Colors&gt; { public final static Colors RED = new Colors(&quot;RED&quot;, 0); public final static Colors BLUE = new Colors(&quot;WHITE&quot;, 1); private final static values = new Colors[]{ RED, BLUE }; private Colors(String name, int ordinal) { super(name, ordinal); } public static Colors[] values(){ return values; } public static Colors valueOf(String name){ return (Colors)java.lang.Enum.valueOf(Colors.class, name); } } java编译器创建了三个构造和方法，为该枚举构造： Colors(String name, int ordinal), Colors[] values(), and Colors valueOf(String name). 方法values和valueOf是隐性声明的. 因此他们的形参名称也是隐性的。 枚举的Colors(String name, int ordinal)构造函数是一个默认构造函数，隐性声明。然而，该构造的形参（name和ordinal）则是非隐性声明的，因为这些形参既不是明确的，也不是隐性的，是合成的。 (一个枚举构造的默认构造的形参不是隐性声明的，因为不同的编译器构造的形式要求不一样；另一个java编译器可能指定不同的形参。当编译器编译使用了枚举常量的表达式时，他们仅仅依赖枚举构造的公共静态字段，不依赖构造函数及常量初始化的过程。）因此： enum Colors: Number of constructors: 0 Number of declared constructors: 1 Declared constructor #1 private MethodParameterExamples$Colors() Parameter class: class java.lang.String Parameter name: $enum$name Modifiers: 4096 Is implicit?: false Is name present?: true Is synthetic?: true Parameter class: int Parameter name: $enum$ordinal Modifiers: 4096 Is implicit?: false Is name present?: true Is synthetic?: true Number of methods: 2 Method #1 public static MethodParameterExamples$Colors[] MethodParameterExamples$Colors.values() Return type: class [LMethodParameterExamples$Colors; Generic return type: class [LMethodParameterExamples$Colors; Method #2 public static MethodParameterExamples$Colors MethodParameterExamples$Colors.valueOf(java.lang.String) Return type: class MethodParameterExamples$Colors Generic return type: class MethodParameterExamples$Colors Parameter class: class java.lang.String Parameter name: name Modifiers: 32768 Is implicit?: true Is name present?: true Is synthetic?: false 获取&amp;解析方法修饰符有几个可能成为方法声明的几个修饰符： 访问修饰符: public, protected, and private 限制到一个实例的修饰符： static 禁止改变值的修饰符：final 需要覆盖的修饰符： abstract 组织可重入的修饰符：synchronized 表示用另一种语言实现的修饰符: native 强制执行严格的浮点行为: strictfp 注解：Annotations MethodModifierSpy例子展示的指定方法的修饰符，及方法是否是编译器生成（synthetic），是否包含可变参数，是否是桥接方法（编译器生成来支持通用接口). import java.lang.reflect.Method; import java.lang.reflect.Modifier; import static java.lang.System.out; public class MethodModifierSpy { private static int count; private static synchronized void inc() { count++; } private static synchronized int cnt() { return count; } public static void main(String... args) { try { Class&lt;?&gt; c = Class.forName(args[0]); Method[] allMethods = c.getDeclaredMethods(); for (Method m : allMethods) { if (!m.getName().equals(args[1])) { continue; } out.format(&quot;%s%n&quot;, m.toGenericString()); out.format(&quot; Modifiers: %s%n&quot;, Modifier.toString(m.getModifiers())); out.format(&quot; [ synthetic=%-5b var_args=%-5b bridge=%-5b ]%n&quot;, m.isSynthetic(), m.isVarArgs(), m.isBridge()); inc(); } out.format(&quot;%d matching overload%s found%n&quot;, cnt(), (cnt() == 1 ? &quot;&quot; : &quot;s&quot;)); // production code should handle this exception more gracefully } catch (ClassNotFoundException x) { x.printStackTrace(); } } } $ java MethodModifierSpy java.lang.Object wait public final void java.lang.Object.wait() throws java.lang.InterruptedException Modifiers: public final [ synthetic=false var_args=false bridge=false ] public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException Modifiers: public final [ synthetic=false var_args=false bridge=false ] public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException Modifiers: public final native [ synthetic=false var_args=false bridge=false ] 3 matching overloads found $ java MethodModifierSpy java.lang.StrictMath toRadians public static double java.lang.StrictMath.toRadians(double) Modifiers: public static strictfp [ synthetic=false var_args=false bridge=false ] 1 matching overload found $ java MethodModifierSpy MethodModifierSpy inc private synchronized void MethodModifierSpy.inc() Modifiers: private synchronized [ synthetic=false var_args=false bridge=false ] 1 matching overload found $ java MethodModifierSpy java.lang.Class getConstructor public java.lang.reflect.Constructor&lt;T&gt; java.lang.Class.getConstructor (java.lang.Class&lt;T&gt;[]) throws java.lang.NoSuchMethodException, java.lang.SecurityException Modifiers: public transient [ synthetic=false var_args=true bridge=false ] 1 matching overload found $ java MethodModifierSpy java.lang.String compareTo public int java.lang.String.compareTo(java.lang.String) Modifiers: public [ synthetic=false var_args=false bridge=false ] public int java.lang.String.compareTo(java.lang.Object) Modifiers: public volatile [ synthetic=true var_args=false bridge=true ] 2 matching overloads found 注意对Class.getConstructor()执行Method.isVarArgs()返回true，这因为该方法声明如下： public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) 而非： public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt; [] parameterTypes) 注意String.compareTo()方法的输出有2个方法，一个是String.java声明的： public int compareTo(String anotherString); 另一个是编译器生成的桥接方法或合成方法。这种情况是因为String事先了参数化泛型接口Comparable。在类型擦除时，继承的方法Comparable.compareTo()的参数类型从java.lang.Object变为java.lang.String。由于Comparable接口中的compareTo方法的参数化类型和String的方法在类型擦除后，不在匹配，不存在覆盖overriding。在所有的情形中，这会产生一个编译错误，因为接口没有被实现。桥接方法的作用就是避免这种问题。 Method实现了java.lang.reflect.AnnotatedElement，所以保留策略为运行时的注解java.lang.annotation.RetentionPolicy.RUNTIME都能够获取到. 调用方法反射提供了执行类的方法的手段。通常，反射调用方法仅仅当在非反射代码里不可能转化类的实例到指定类型时才是必须的。通过java.lang.reflect.Method.invoke()可以执行方法的调用，第一个参数表示执行哪一个实例的指定方法（如果方法是静态的，第一个参数应该是null），第二个参数表示方法执行所需的参数。如果底层方法抛出异常，会被java.lang.reflect.InvocationTargetException包装。方法的原始异常可以通过异常链机制的InvocationTargetException.getCause()方法获取。 找到&amp;执行指定声明的方法import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.lang.reflect.Type; import java.util.Locale; import static java.lang.System.out; import static java.lang.System.err; public class Deet&lt;T&gt; { private boolean testDeet(Locale l) { // getISO3Language() may throw a MissingResourceException out.format(&quot;Locale = %s, ISO Language Code = %s%n&quot;, l.getDisplayName(), l.getISO3Language()); return true; } private int testFoo(Locale l) { return 0; } private boolean testBar() { return true; } public static void main(String... args) { if (args.length != 4) { err.format(&quot;Usage: java Deet &lt;classname&gt; &lt;langauge&gt; &lt;country&gt; &lt;variant&gt;%n&quot;); return; } try { Class&lt;?&gt; c = Class.forName(args[0]); Object t = c.newInstance(); Method[] allMethods = c.getDeclaredMethods(); for (Method m : allMethods) { String mname = m.getName(); if (!mname.startsWith(&quot;test&quot;) || (m.getGenericReturnType() != boolean.class)) { continue; } Type[] pType = m.getGenericParameterTypes(); if ((pType.length != 1) || Locale.class.isAssignableFrom(pType[0].getClass())) { continue; } out.format(&quot;invoking %s()%n&quot;, mname); try { m.setAccessible(true); Object o = m.invoke(t, new Locale(args[1], args[2], args[3])); out.format(&quot;%s() returned %b%n&quot;, mname, (Boolean) o); // Handle any exceptions thrown by method to be invoked. } catch (InvocationTargetException x) { Throwable cause = x.getCause(); err.format(&quot;invocation of %s failed: %s%n&quot;, mname, cause.getMessage()); } } // production code should handle these exceptions more gracefully } catch (ClassNotFoundException x) { x.printStackTrace(); } catch (InstantiationException x) { x.printStackTrace(); } catch (IllegalAccessException x) { x.printStackTrace(); } } } Deet invokes getDeclaredMethods() which will return all methods explicitly declared in the class. Also, Class.isAssignableFrom() is used to determine whether the parameters of the located method are compatible with the desired invocation. Technically the code could have tested whether the following statement is true since Locale is final: Locale.class == pType[0].getClass()However, Class.isAssignableFrom() is more general. $ java Deet Deet ja JP JPinvoking testDeet()Locale = Japanese (Japan,JP),ISO Language Code = jpntestDeet() returned true$ java Deet Deet xx XX XXinvoking testDeet()invocation of testDeet failed:Couldn’t find 3-letter language code for xxFirst, note that only testDeet() meets the declaration restrictions enforced by the code. Next, when testDeet() is passed an invalid argument it throws an unchecked java.util.MissingResourceException. In reflection, there is no distinction in the handling of checked versus unchecked exceptions. They are all wrapped in an InvocationTargetException Invoking Methods with a Variable Number of Arguments Method.invoke() may be used to pass a variable number of arguments to a method. The key concept to understand is that methods of variable arity are implemented as if the variable arguments are packed in an array. The InvokeMain example illustrates how to invoke the main() entry point in any class and pass a set of arguments determined at runtime. import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.Arrays; public class InvokeMain { public static void main(String… args) { try { Class&lt;?&gt; c = Class.forName(args[0]); Class[] argTypes = new Class[] { String[].class }; Method main = c.getDeclaredMethod(“main”, argTypes); String[] mainArgs = Arrays.copyOfRange(args, 1, args.length); System.out.format(“invoking %s.main()%n”, c.getName()); main.invoke(null, (Object)mainArgs); // production code should handle these exceptions more gracefully } catch (ClassNotFoundException x) { x.printStackTrace(); } catch (NoSuchMethodException x) { x.printStackTrace(); } catch (IllegalAccessException x) { x.printStackTrace(); } catch (InvocationTargetException x) { x.printStackTrace(); } } }First, to find the main() method the code searches for a class with the name “main” with a single parameter that is an array of String Since main() is static, null is the first argument to Method.invoke(). The second argument is the array of arguments to be passed. $ java InvokeMain Deet Deet ja JP JPinvoking Deet.main()invoking testDeet()Locale = Japanese (Japan,JP),ISO Language Code = jpntestDeet() returned true Troubleshooting covers common errors encountered when finding or invoking methods构造函数The Reflection APIs for constructors are defined in java.lang.reflect.Constructor and are similar to those for methods, with two major exceptions: first, constructors have no return values; second, the invocation of a constructor creates a new instance of an object for a given class. Finding Constructors illustrates how to retrieve constructors with specific parametersRetrieving and Parsing Constructor Modifiers shows how to obtain the modifiers of a constructor declaration and other information about the constructorCreating New Class Instances shows how to instantiate an instance of an object by invoking its constructorTroubleshooting describes common errors which may be encountered while finding or invoking constructors","categories":[{"name":"java","slug":"java","permalink":"http://zhangxiangnan.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://zhangxiangnan.com/tags/java/"},{"name":"reflect","slug":"reflect","permalink":"http://zhangxiangnan.com/tags/reflect/"}]},{"title":"JAVA反射介绍及Class详解","slug":"java/JAVA反射介绍及Class详解","date":"2017-04-12T12:14:01.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2017/04/12/java/JAVA反射介绍及Class详解/","link":"","permalink":"http://zhangxiangnan.com/2017/04/12/java/JAVA反射介绍及Class详解/","excerpt":"反射的用途 反射对于想要在运行时去检查或修改运行在Java虚拟机中的程序的运行时行为的场合，经常用到。","text":"反射的用途 反射对于想要在运行时去检查或修改运行在Java虚拟机中的程序的运行时行为的场合，经常用到。 可扩展的特征应用程序可以通过使用可扩展对象的全名称创建实例来使用外部用户定义的类 类浏览器和可视化开发环境一个类浏览器需要能够枚举出类的成员。可视化开发环境可以借助于使用反射提供的类型信息来帮助开发者写正确的代码。 调试器和测试工具调试器能够检查类的基本成员.测试工具可以利用反射来得到类中定义的API，来确保测试用例的高度覆盖（检查单元测试覆盖率）。 反射的缺点反射很强大，但不能滥用。能不用反射就不用，不得不用反射时需要考虑以下几点： 性能开销因为反射设计动态解析的类型，所以不能执行某些Java虚拟机优化。因此反射操作的性能比非反射对象的性能更慢，应该在对性能敏感的程序中频繁调用的地方尽量避免使用反射。 安全限制反射需要一个运行时权限，但运行在安全管理器下该权限可能不存在。对于必须在安全受限的上下文来说，很重要，如Applet 内部暴露由于反射允许代码执行非反射代码中认为非法的操作，如访问私有字段和方法，此时使用反射能导致意外地副作用，导致代码功能失调、破坏可移植性。同时，反射代码破坏了抽象性，因此可能通过更新平台来改变行为（不懂） Class每一个对象要么是引用类型要么是基本类型。引用类型全部继承自java.lang.Object。Classes、enums、arrays及interfaces都是引用类型。基本类型只包括8种：boolean、byte、short、long、char、int、float、double。引用类型例如java.lang.String，所有基本类型的包装类型如java.lang.Double，接口java.io.Serializable，及枚举javax.swing.SortOrder。 针对每一种对象类型，Java虚拟机实例化java.lang.Class的一份不可变实例。Class提供了方法来检查对象的运行时属性，包括成员和类型信息，同时Class也提供了创建新的classes及对象的功能。更重要的是，Class是所有反射API的入口。 重新获取Class对象 所有反射操作的入口是java.lang.Class。除了java.lang.reflect.ReflectPermission类，java.lang.reflect包下的其他类都没有公共构造函数。要获得这些类，有必要调取Class的相应地方法。有几种方法来来获取Class，根据是代码否有权限访问一个对象，类的名称，类型或一个已存在的Class。 Object.getClass() 如果能取到类的某个实例对象，最简单的获取其Class对象的方式是调用Object.getClass()方法。当然，这种方式只适合于全部继承自Object类的引用类型。如： Class c = &quot;foo&quot;.getClass(); 返回String类的Class对象 Class c = System.console().getClass(); 和虚拟机关联的有一个唯一的console对象，通过System.console()对象返回，getClass()返回的是java.io.Console类的Class对象。 enum E { A, B } Class c = A.getClass(); A是枚举类型E的一个实例，getClass()方法返回枚举类型E对应的Class对象 byte[] bytes = new byte[1024]; Class c = bytes.getClass(); 由于数组是Object对象，所以也能对数组的实例调用getClass()方法。返回的Class对应组件类型为byte的数组 import java.util.HashSet; import java.util.Set; Set&lt;String&gt; s = new HashSet&lt;String&gt;(); Class c = s.getClass(); 该例中，java.util.Set是java.util.HashSet类型的实例对象实现的一个接口。getClass()返回的Class对应于java.util.HashSet。 .class语法如果有类型但是没有实例对象，通过追加”.class”到类型的名称后面也可以获取到Class。这也是基本类型最简单的方式获取Class。 boolean b; Class c = b.getClass(); // 编译报错 Class c = boolean.class; // 正确 注意boolean.getClass()会产生编译错误，因为boolean类型时基本类型，不能被引用。.class语法返回类型boolean对应的Class。 Class c = java.io.PrintStream.class; 返回java.io.PrintStream类型对应的Class对象 Class c = int[][][].class; The .class也用来获取多维数组类型对应的Class Class.forName()如果有一个类的全限定名称，使用静态方法Class.forName()能获取到对应的Class对象。该方式不能用来加载基本类型。 Class c = Class.forName(&quot;com.duke.MyLocaleServiceProvider&quot;); 该语句根据传入的全限定名来创建一个class对象 Class cDoubleArray = Class.forName(&quot;[D&quot;); Class cStringArray = Class.forName(&quot;[[Ljava.lang.String;&quot;); 如果是数组类型传入的名称，则按下面Class.getName的描述；变量cDoubleArray表示基本类型double数组对应的Class（和double[].class一样），变量cStringArray表示String的二维数组对应的Class（和String[][].class一样）。 Class.getName()： 返回Class对象代表的实体的字符串名称（类、接口、数组、基本类型或void） 如果该class对象表示一个引用类型（非数组类型）就依据java语言规范，返回类的二进制名称。 如果该class对象表示一个基本类型或者void类型，返回对应基本类型或者void的java语言关键字对应的字符串 如果该class对象表示一个数组类，则名称由元素类型的名称前面追加字符”[“表示数组嵌套的深度，元素类型名称的编码如下： 元素类型|编码 boolean Z byte B char C 类或接口 类全限定名称 double D float F int I long J short S 类或接口名称就如上述说明的类的二进制名称 示例: 方法调用 结果 String.class.getName() “java.lang.String” byte.class.getName() “byte” (new Object[3]).getClass().getName() “[Ljava.lang.Object;” (new int[3][4][5][6][7][8][9]).getClass().getName() “[[[[[[[I” 基本类型包装类的TYPE字段对于基本类型来说.Class语法获取其Class对象非常方便，也是首选方式；还有另一种方式来获取Class。每一个基本类型和void类型都有一个包装类在java.lang中，将基本类型装箱为包装类型。每一个包装类型有一个TYPE字段，即是基本类型对应的Class对象 Class c = Double.TYPE;// 相等于double.classClass c = Void.TYPE;//相等于void.class. 返回Classes的方法有几个反射API可以返回classes，但是只有当某个Class已经直接或间接得到才能访问那几个API。 Class.getSuperclass() 返回指定class的超类class Class c = javax.swing.JButton.class.getSuperclass();// 返回javax.swing.AbstractButton. Class.getClasses()返回指定class的所有的公共classes、接口及枚举成员，包含继承的成员。 Class&lt;?&gt;[] c = Character.class.getClasses();//返回内部多个公共class成员 Class.getDeclaredClasses()返回class里所有显示声明的类、接口、枚举（公共、私有等都包含） Class&lt;?&gt;[] c = Character.class.getDeclaredClasses();//返回显示声明的几个类 Class.getDeclaringClass()如果Class对象表示的接口或类是另一个类的成员，则返回声明该成员的类对应的Class对象；否则如果不是任何其他类的成员则返回null。如果该Class对象表示一个数组类型、基本类型、或void，则返回null。匿名类的声明没有声明类但有一个封闭类 public class MyClass { static Object o = new Object() { public void m() {} }; static Class&lt;c&gt; = o.getClass().getDeclaringClass(); } o定义的匿名类的声明类为null Class.getEnclosingClass()返回class的直接封闭类 Class c = Thread.State.class().getEnclosingClass();//枚举类Thread.State的封闭类是Thread public class MyClass { static Object o = new Object() { public void m() {} }; static Class&lt;c&gt; = o.getClass().getEnclosingClass(); } o定义的匿名内部类的封闭类是Mycalss java.lang.reflect.Field.getDeclaringClass()返回这些成员被声明的Class。 import java.lang.reflect.Field; Field f = System.class.getField(&quot;out&quot;); Class c = f.getDeclaringClass();//返回System,out字段在System类里定义 java.lang.reflect.Method.getDeclaringClass()返回这些成员被声明的Class。 java.lang.reflect.Constructor.getDeclaringClass()返回这些成员被声明的Class。 Class.getGenericInterfaces() 返回该对象表示的类或接口直接实现的接口的类型(Type类型) 如果某个实现的接口是参数化类型，则返回的Type对象必须准确反映出源码中使用的实际类型参数，如果以前没有创建表示每个实现接口的参数化类型，则创建该类型。 如果该对象是一个类，则返回该类实现的所有的接口数组，顺序按照该对象表示的类实现接口时的顺序对应；对于数组来说，按照Cloneable、Serializable的顺序返回。 如果该对象是一个接口，返回该接口直接继承的所有接口，顺序按照和接口继承时声明的接口顺序一致。 如果该对象是类或接口，但是没有实现任何接口，返回空数组。 如果该对象是基本类型或void，返回空数组。 Class.getInterfaces() 返回类型时Class类型 如果该对象是一个类，则返回该类实现的所有的接口数组，顺序按照该对象表示的类实现接口时的顺序对应；对于数组来说，按照Cloneable、Serializable的顺序返回。 如果该对象是一个接口，返回该接口直接继承的所有接口，顺序按照和接口继承时声明的接口顺序一致。 如果该对象是类或接口，但是没有实现任何接口，返回空数组。 如果该对象是基本类型或void，返回空数组。 Class.getModifiers() 返回类或接口的java语言修饰符，加密成一个整数。修饰符包含Java虚拟机为public、protected、private、final、static、abstract、interface的常量，需要使用Modifier的方法来解码 如果是数组类型，public、private、protected修饰符是和数组的组件类型一致 如果是基本类型或者void，总是有public修饰符，总无protected及private修饰符。 如果是数组类型、基本类型或void，总有final修饰符，总是无interface修饰符。其他修饰符不能由此规则决定。 如果是数组类型，总有abstract修饰符 检查类的修饰符和类型class可以定义一个或多个修饰符来决定运行时行为： 访问修饰符：public, protected, and private 需要重写的修饰符：abstract 限制为某个实例的修饰符：: static 禁止值被修改的修饰符： final 强制执行严格的浮点行为的修饰符：strictfp 注解并不是所有的修饰符可以用在所有类上，如接口不能用final修饰，enum不能用abstract修饰。java.lang.reflect.Modifier包含了所有可能的修饰符的声明，也包含了对Class.getModifiers()方法返回的修饰符标记的解码方法。 如下例展示了如何获取类的声明的组件类型包括修饰符、泛型参数、实现的接口及继承的父类的路径。如果累实现了java.lang.reflect.AnnotatedElement接口，也能拿到运行时的注解信息 import java.lang.annotation.Annotation; import java.lang.reflect.Modifier; import java.lang.reflect.Type; import java.lang.reflect.TypeVariable; import java.util.Arrays; import java.util.ArrayList; import java.util.List; import static java.lang.System.out; public class ClassDeclarationSpy { public static void main(String... args) { try { Class&lt;?&gt; c = Class.forName(args[0]);//根据类名称得到class对象 out.format(&quot;Class:%n %s%n%n&quot;, c.getCanonicalName());// 类的规范名称 out.format(&quot;Modifiers:%n %s%n%n&quot;, Modifier.toString(c.getModifiers()));// 输出类的修饰符 out.format(&quot;Type Parameters:%n&quot;); TypeVariable[] tv = c.getTypeParameters();// 获取类型参数 if (tv.length != 0) { out.format(&quot; &quot;); for (TypeVariable t : tv) out.format(&quot;%s &quot;, t.getName()); out.format(&quot;%n%n&quot;); } else { out.format(&quot; -- No Type Parameters --%n%n&quot;); } out.format(&quot;Implemented Interfaces:%n&quot;); Type[] intfs = c.getGenericInterfaces();// 实现接口 if (intfs.length != 0) { for (Type intf : intfs) out.format(&quot; %s%n&quot;, intf.toString()); out.format(&quot;%n&quot;); } else { out.format(&quot; -- No Implemented Interfaces --%n%n&quot;); } out.format(&quot;Inheritance Path:%n&quot;);// 继承路径 List&lt;Class&gt; l = new ArrayList&lt;Class&gt;(); printAncestor(c, l); if (l.size() != 0) { for (Class&lt;?&gt; cl : l) out.format(&quot; %s%n&quot;, cl.getCanonicalName()); out.format(&quot;%n&quot;); } else { out.format(&quot; -- No Super Classes --%n%n&quot;); } out.format(&quot;Annotations:%n&quot;); Annotation[] ann = c.getAnnotations();// 注解 if (ann.length != 0) { for (Annotation a : ann) out.format(&quot; %s%n&quot;, a.toString()); out.format(&quot;%n&quot;); } else { out.format(&quot; -- No Annotations --%n%n&quot;); } // production code should handle this exception more gracefully } catch (ClassNotFoundException x) { x.printStackTrace(); } } private static void printAncestor(Class&lt;?&gt; c, List&lt;Class&gt; l) { Class&lt;?&gt; ancestor = c.getSuperclass();// 实现的父类 if (ancestor != null) { l.add(ancestor); printAncestor(ancestor, l); } } } 几个不同输入参数下的结果示例如下: $ java ClassDeclarationSpy java.util.concurrent.ConcurrentNavigableMap Class: java.util.concurrent.ConcurrentNavigableMap Modifiers: public abstract interface Type Parameters: K V Implemented Interfaces: java.util.concurrent.ConcurrentMap&lt;K, V&gt; java.util.NavigableMap&lt;K, V&gt; Inheritance Path: -- No Super Classes -- Annotations: -- No Annotations -- This is the actual declaration for java.util.concurrent.ConcurrentNavigableMap in the source code: public interface ConcurrentNavigableMap&lt;K,V&gt; extends ConcurrentMap&lt;K,V&gt;, NavigableMap&lt;K,V&gt; 注意由于上述例子参数是接口，隐含abstract修饰符。编译器为每个接口添加该修饰符。同样，该接口有2个泛型参数，K、V。K、V具体的额外信息可通过TypeVariable的方法得到。上述说明接口也可以实现接口。 $ java ClassDeclarationSpy &quot;[Ljava.lang.String;&quot; Class: java.lang.String[] Modifiers: public abstract final Type Parameters: -- No Type Parameters -- Implemented Interfaces: interface java.lang.Cloneable interface java.io.Serializable Inheritance Path: java.lang.Object Annotations: -- No Annotations -- 由于数组是运行时对象，所有的类型信息都由java虚拟机提供。特别的，数组实现了Cloneable、java.io.Serializable接口，并且数组的直接父类总是Object类。 $ java ClassDeclarationSpy java.io.InterruptedIOException Class: java.io.InterruptedIOException Modifiers: public Type Parameters: -- No Type Parameters -- Implemented Interfaces: -- No Implemented Interfaces -- Inheritance Path: java.io.IOException java.lang.Exception java.lang.Throwable java.lang.Object Annotations: -- No Annotations -- $ java ClassDeclarationSpy java.security.Identity Class: java.security.Identity Modifiers: public abstract Type Parameters: -- No Type Parameters -- Implemented Interfaces: interface java.security.Principal interface java.io.Serializable Inheritance Path: java.lang.Object Annotations: @java.lang.Deprecated() java.security.Identity被注解标记为过时的api，可以用来通过反射代码来监测过时API 注意：并不是所有的注解都能通过反射拿到，需要注解的保留策略的类型为Runtime类型（ java.lang.annotation.RetentionPolicy of RUNTIME）的注解才能在运行时拿到。 获取Class的成员Class里提供了2类方法来访问字段、方法、构造函数：枚举所有成员的方法及查找某个指定成员的方法。还有不同的方法来访问类本身直接声明的成员及查找实现的接口或实现类继承下来的成员。 定义字段的Class方法 API 是否枚举成员 是否包括继承的成员 是否返回私有成员 getDeclaredField() no no yes getField() no yes no getDeclaredFields() yes no yes getFields() yes yes no 定位方法的Class方法 API 是否枚举成员 是否包括继承的成员 是否返回私有成员 getDeclaredMethod() no no yes getMethod() no yes no getDeclaredMethods() yes no yes getMethods() yes yes no 定位构造函数的方法 API 是否枚举成员 是否包括继承的成员 是否返回私有成员 getDeclaredConstructor() no N/A1 yes getConstructor() no N/A1 no getDeclaredConstructors() yes N/A1 yes getConstructors() yes N/A1 no 构造函数不能被继承 import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.lang.reflect.Member; import static java.lang.System.out; enum ClassMember { CONSTRUCTOR, FIELD, METHOD, CLASS, ALL } public class ClassSpy { public static void main(String... args) { try { Class&lt;?&gt; c = Class.forName(args[0]); out.format(&quot;Class:%n %s%n%n&quot;, c.getCanonicalName()); Package p = c.getPackage(); out.format(&quot;Package:%n %s%n%n&quot;, (p != null ? p.getName() : &quot;-- No Package --&quot;)); for (int i = 1; i &lt; args.length; i++) { switch (ClassMember.valueOf(args[i])) { case CONSTRUCTOR: printMembers(c.getConstructors(), &quot;Constructor&quot;); break; case FIELD: printMembers(c.getFields(), &quot;Fields&quot;); break; case METHOD: printMembers(c.getMethods(), &quot;Methods&quot;); break; case CLASS: printClasses(c); break; case ALL: printMembers(c.getConstructors(), &quot;Constuctors&quot;); printMembers(c.getFields(), &quot;Fields&quot;); printMembers(c.getMethods(), &quot;Methods&quot;); printClasses(c); break; default: assert false; } } } catch (ClassNotFoundException x) { x.printStackTrace(); } } private static void printMembers(Member[] mbrs, String s) { out.format(&quot;%s:%n&quot;, s); for (Member mbr : mbrs) { if (mbr instanceof Field) out.format(&quot; %s%n&quot;, ((Field)mbr).toGenericString()); else if (mbr instanceof Constructor) out.format(&quot; %s%n&quot;, ((Constructor)mbr).toGenericString());// 返回泛型化String else if (mbr instanceof Method) out.format(&quot; %s%n&quot;, ((Method)mbr).toGenericString()); } if (mbrs.length == 0) out.format(&quot; -- No %s --%n&quot;, s); out.format(&quot;%n&quot;); } private static void printClasses(Class&lt;?&gt; c) { out.format(&quot;Classes:%n&quot;); Class&lt;?&gt;[] clss = c.getClasses(); for (Class&lt;?&gt; cls : clss) out.format(&quot; %s%n&quot;, cls.getCanonicalName()); if (clss.length == 0) out.format(&quot; -- No member interfaces, classes, or enums --%n&quot;); out.format(&quot;%n&quot;); } } 以下是几个示例： $ java ClassSpy java.lang.ClassCastException CONSTRUCTOR Class: java.lang.ClassCastException Package: java.lang Constructor: public java.lang.ClassCastException() public java.lang.ClassCastException(java.lang.String)// 构造函数不能被继承 $ java ClassSpy java.nio.channels.ReadableByteChannel METHOD Class: java.nio.channels.ReadableByteChannel Package: java.nio.channels Methods: public abstract int java.nio.channels.ReadableByteChannel.read (java.nio.ByteBuffer) throws java.io.IOException // 从实现接口继承的方法 public abstract void java.nio.channels.Channel.close() throws java.io.IOException public abstract boolean java.nio.channels.Channel.isOpen() $ java ClassSpy ClassMember FIELD METHOD Class: ClassMember Package: -- No Package -- Fields: // 可以根据 java.lang.reflect.Field.isEnumConstant()来区分枚举字段 public static final ClassMember ClassMember.CONSTRUCTOR public static final ClassMember ClassMember.FIELD public static final ClassMember ClassMember.METHOD public static final ClassMember ClassMember.CLASS public static final ClassMember ClassMember.ALL Methods: // 方法名都带有类名，这样可以区分如toString()方法是Enum类的，而不是继承自Object的 public static ClassMember ClassMember.valueOf(java.lang.String) public static ClassMember[] ClassMember.values() public final int java.lang.Enum.hashCode() public final int java.lang.Enum.compareTo(E) public int java.lang.Enum.compareTo(java.lang.Object) public final java.lang.String java.lang.Enum.name() public final boolean java.lang.Enum.equals(java.lang.Object) public java.lang.String java.lang.Enum.toString() public static &lt;T&gt; T java.lang.Enum.valueOf (java.lang.Class&lt;T&gt;,java.lang.String) public final java.lang.Class&lt;E&gt; java.lang.Enum.getDeclaringClass() public final int java.lang.Enum.ordinal() public final native java.lang.Class&lt;?&gt; java.lang.Object.getClass() public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException public final void java.lang.Object.wait() hrows java.lang.InterruptedException public final native void java.lang.Object.notify() public final native void java.lang.Object.notifyAll() // 获取字段的声明类 if (mbr instanceof Field) { Field f = (Field)mbr; out.format(&quot; %s%n&quot;, f.toGenericString()); out.format(&quot; -- declared in: %s%n&quot;, f.getDeclaringClass()); } 常见问题编译警告可能发生的警告为：”Note: … uses unchecked or unsafe operations”当调用一个方法时，参数值的类型经过校验，很可能经过转化。如下例getMethod()方法引起常见的未收校验的转换警告： import java.lang.reflect.Method; public class ClassWarning { void m() { try { Class c = ClassWarning.class; Method m = c.getMethod(&quot;m&quot;); // warning // production code should handle this exception more gracefully } catch (NoSuchMethodException x) { x.printStackTrace(); } } } $ javac ClassWarning.java Note: ClassWarning.java uses unchecked or unsafe operations. Note: Recompile with -Xlint:unchecked for details. $ javac -Xlint:unchecked ClassWarning.java ClassWarning.java:6: warning: [unchecked] unchecked call to getMethod (String,Class&lt;?&gt;...) as a member of the raw type Class Method m = c.getMethod(&quot;m&quot;); // warning ^ 因为c被声明为原始类型（不带有类型参数），但是getMethod()方法是一个参数化类型，所以发生未经转换的警告有2中解决方法，更倾向于修改c的声明，使其带有合适的泛型类型，该例的声明应该为： Class&lt;?&gt; c = warn.getClass(); 或者可以使用@SuppressWarnings来抑制警告 Class c = ClassWarning.class; @SuppressWarnings(&quot;unchecked&quot;) Method m = c.getMethod(&quot;m&quot;); 建议：通常的原则是,警告不应该被忽略， 因为警告可能表明一个bug。参数化声明应该合理使用。如果参数化声明不可能（如和厂商的类库代码交互），则可以使用@SuppressWarnings. 构造函数不可访问时构造异常如果在类的无参构造函数不可访问时，调用Class.newInstance()方法会抛出InstantiationException异常。 class Cls { private Cls() {} } public class ClassTrouble { public static void main(String... args) { try { Class&lt;?&gt; c = Class.forName(&quot;Cls&quot;); c.newInstance(); // InstantiationException } catch (InstantiationException x) { x.printStackTrace(); } catch (IllegalAccessException x) { x.printStackTrace(); } catch (ClassNotFoundException x) { x.printStackTrace(); } } } $ java ClassTrouble java.lang.IllegalAccessException: Class ClassTrouble can not access a member of class Cls with modifiers &quot;private&quot; at sun.reflect.Reflection.ensureMemberAccess(Reflection.java:65) at java.lang.Class.newInstance0(Class.java:349) at java.lang.Class.newInstance(Class.java:308) at ClassTrouble.main(ClassTrouble.java:9) Class.newInstance()的行为和new关键字很类似，会因为new关键失败的相同原因失败。反射里通用的解决方案是利用java.lang.reflect.AccessibleObject类提供的抑制访问控制校验的功能；然而由于java.lang.Class没继承AccessibleObject，所以不会有效。唯一的方案是使使用Constructor.newInstance()方法的类继承AccessibleObject。建议：通常，更倾向于使用Constructor.newInstance()","categories":[{"name":"java","slug":"java","permalink":"http://zhangxiangnan.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://zhangxiangnan.com/tags/java/"},{"name":"reflect","slug":"reflect","permalink":"http://zhangxiangnan.com/tags/reflect/"}]},{"title":"排查CPU使用率始终100%问题","slug":"problems/排查CPU load过高的线上问题","date":"2017-02-24T10:21:08.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2017/02/24/problems/排查CPU load过高的线上问题/","link":"","permalink":"http://zhangxiangnan.com/2017/02/24/problems/排查CPU load过高的线上问题/","excerpt":"排查CPU使用率始终100%的线上问题，现象，排查过程，解决方案。","text":"排查CPU使用率始终100%的线上问题，现象，排查过程，解决方案。 现象 收到线上机器单个CPU平均load过高的报警，登陆到机器，命令行执行top命令显示如下： [zhangxia@xxxx ~]$ top top - 17:38:39 up 58 days, 6:38, 2 users, load average: 0.66, 0.20, 0.19 Tasks: 119 total, 2 running, 117 sleeping, 0 stopped, 0 zombie Cpu0 : 38.3%us, 59.0%sy, 0.0%ni, 0.3%id, 0.0%wa, 0.0%hi, 2.3%si, 0.0%st Cpu1 : 20.7%us, 47.4%sy, 0.0%ni, 31.6%id, 0.0%wa, 0.0%hi, 0.0%si, 0.3%st Mem: 1922348k total, 1703128k used, 219220k free, 4300k buffers Swap: 2096440k total, 0k used, 2096440k free, 235564k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 8288 zhangxia 20 0 2628m 29m 11m S 98.1 1.6 0:25.24 java 可以发现进程号为8288的进程CPU使用率为98%，接近100%。 解决过程top找到cpu占用最高的进程号 已找到进程号为8288. 查看已找到的进程中哪个线程CPU使用率最高 在top执行的视图里执行shift+H快捷键，提示“Show threads On”，此时展示的PID为线程ID，可以观察到线程id为19234的线程占用CPU最高。或者使用”Top -Hp 进程号“来观察。 top - 17:47:40 up 58 days, 6:47, 2 users, load average: 0.71, 0.23, 0.18 Tasks: 526 total, 2 running, 524 sleeping, 0 stopped, 0 zombie Cpu0 : 25.5%us, 44.4%sy, 0.0%ni, 0.0%id, 0.0%wa, 0.0%hi, 1.9%si, 28.2%st Cpu1 : 19.9%us, 41.4%sy, 0.0%ni, 37.5%id, 0.0%wa, 0.0%hi, 0.0%si, 1.3%st Mem: 1922348k total, 1707684k used, 214664k free, 5740k buffers Swap: 2096440k total, 0k used, 2096440k free, 237624k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 19234 zhangxia 20 0 2628m 29m 11m R 97.3 1.6 0:26.50 java jstack+进程号导出线程堆栈 执行导出某个进程内的所有线程堆栈信息到文件： jstack 8288 &gt; stack.8288 堆栈信息导出到了当前文件夹，为stack.8288。 内容如下： 2017-02-24 18:12:51 Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.45-b02 mixed mode): &quot;Attach Listener&quot; #9 daemon prio=9 os_prio=0 tid=0x00007f8abc001000 nid=0x4b48 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE &quot;Finalizer&quot; #3 daemon prio=8 os_prio=0 tid=0x00007f8b0407e800 nid=0x4b2a in Object.wait() [0x00007f8af12f9000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on &lt;0x00000006c6c06e80&gt; (a java.lang.ref.ReferenceQueue$Lock) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143) - locked &lt;0x00000006c6c06e80&gt; (a java.lang.ref.ReferenceQueue$Lock) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164) at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209) &quot;Reference Handler&quot; #2 daemon prio=10 os_prio=0 tid=0x00007f8b0407c000 nid=0x4b29 in Object.wait() [0x00007f8af13fa000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on &lt;0x00000006c6c08370&gt; (a java.lang.ref.Reference$Lock) at java.lang.Object.wait(Object.java:502) at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:157) - locked &lt;0x00000006c6c08370&gt; (a java.lang.ref.Reference$Lock) &quot;main&quot; #1 prio=5 os_prio=0 tid=0x00007f8b04009800 nid=0x4b22 runnable [0x00007f8b0a8ae000] java.lang.Thread.State: RUNNABLE at java.io.FileOutputStream.writeBytes(Native Method) at java.io.FileOutputStream.write(FileOutputStream.java:326) at java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:82) at java.io.BufferedOutputStream.flush(BufferedOutputStream.java:140) - locked &lt;0x00000006c6c17678&gt; (a java.io.BufferedOutputStream) at java.io.PrintStream.write(PrintStream.java:482) - locked &lt;0x00000006c6c06f30&gt; (a java.io.PrintStream) at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:221) at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:291) at sun.nio.cs.StreamEncoder.flushBuffer(StreamEncoder.java:104) - locked &lt;0x00000006c6c06ee8&gt; (a java.io.OutputStreamWriter) at java.io.OutputStreamWriter.flushBuffer(OutputStreamWriter.java:185) at java.io.PrintStream.write(PrintStream.java:527) - eliminated &lt;0x00000006c6c06f30&gt; (a java.io.PrintStream) at java.io.PrintStream.print(PrintStream.java:669) at java.io.PrintStream.println(PrintStream.java:806) - locked &lt;0x00000006c6c06f30&gt; (a java.io.PrintStream) at CpuLoadHighTest.main(CpuLoadHighTest.java:4) &quot;VM Thread&quot; os_prio=0 tid=0x00007f8b04077000 nid=0x4b28 runnable &quot;GC task thread#0 (ParallelGC)&quot; os_prio=0 tid=0x00007f8b0401e800 nid=0x4b24 runnable &quot;GC task thread#1 (ParallelGC)&quot; os_prio=0 tid=0x00007f8b04020000 nid=0x4b25 runnable &quot;GC task thread#2 (ParallelGC)&quot; os_prio=0 tid=0x00007f8b04022000 nid=0x4b26 runnable &quot;GC task thread#3 (ParallelGC)&quot; os_prio=0 tid=0x00007f8b04023800 nid=0x4b27 runnable &quot;VM Periodic Task Thread&quot; os_prio=0 tid=0x00007f8b040cc800 nid=0x4b30 waiting on condition JNI global references: 9 得到线程号8566的十六进制表示 命令行执行如下命令： printf ‘%x\\n’ 19234 得到十六进制表示为4b22 在堆栈日志中查找线程号十六进制表示为4b22的线程堆栈信息在堆栈文件中查找4b22，得到如下线程堆栈信息： &quot;main&quot; #1 prio=5 os_prio=0 tid=0x00007f8b04009800 nid=0x4b22 runnable [0x00007f8b0a8ae000] java.lang.Thread.State: RUNNABLE at java.io.FileOutputStream.writeBytes(Native Method) at java.io.FileOutputStream.write(FileOutputStream.java:326) at java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:82) at java.io.BufferedOutputStream.flush(BufferedOutputStream.java:140) - locked &lt;0x00000006c6c17678&gt; (a java.io.BufferedOutputStream) at java.io.PrintStream.write(PrintStream.java:482) - locked &lt;0x00000006c6c06f30&gt; (a java.io.PrintStream) at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:221) at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:291) at sun.nio.cs.StreamEncoder.flushBuffer(StreamEncoder.java:104) - locked &lt;0x00000006c6c06ee8&gt; (a java.io.OutputStreamWriter) at java.io.OutputStreamWriter.flushBuffer(OutputStreamWriter.java:185) at java.io.PrintStream.write(PrintStream.java:527) - eliminated &lt;0x00000006c6c06f30&gt; (a java.io.PrintStream) at java.io.PrintStream.print(PrintStream.java:669) at java.io.PrintStream.println(PrintStream.java:806) - locked &lt;0x00000006c6c06f30&gt; (a java.io.PrintStream) at CpuLoadHighTest.main(CpuLoadHighTest.java:4) 根绝CpuLoadHighTest.main(CpuLoadHighTest.java:4)可得到问题出现的具体位置，然后分析是否死循环死锁等问题即可解决。","categories":[{"name":"problems","slug":"problems","permalink":"http://zhangxiangnan.com/categories/problems/"}],"tags":[{"name":"problems","slug":"problems","permalink":"http://zhangxiangnan.com/tags/problems/"}]},{"title":"kafka的设计原理解析","slug":"kafka/kafka的设计原理解析","date":"2017-02-16T08:03:01.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2017/02/16/kafka/kafka的设计原理解析/","link":"","permalink":"http://zhangxiangnan.com/2017/02/16/kafka/kafka的设计原理解析/","excerpt":"kafka的设计原理解析，其设计目标，及其为了这个目标作出的设计方案","text":"kafka的设计原理解析，其设计目标，及其为了这个目标作出的设计方案 kafka的设计目标Kafka 的定位是作为一个统一的处理实时数据流的平台，其必须能够处理一个「大公司」每天可能产生的消息量级。因此，在设计之初 Kafka 就考虑要满足多样的应用场景： 高吞吐量：必须具有高吞吐量以便支持大容量事件流，如实时日志聚合服务 加载离线数据：必须能够支持优雅地处理大数据量的backlog积压，以便能够支持来自离线系统的定期数据加载 低延迟：必须能够处理低延迟的消息传递应用以便支持更多的传统的消息系统的使用场景 最好能够支持对订阅源的分区、分布式、及实时处理，并产生新的派生订阅源，这促使产生了kafka的分区和消费者模型 高可用性：在流数据被馈送到其他数据系统用于服务的场景中，需要在机器故障时支持容错 为了支持上述的场景，设计了一些独特的元素，类似于数据库日志，而非传统的消息系统。 持久性文件系统性能并不差kafka在存储和缓存消息上很大程度上依赖了文件系统。有个普遍的观念认为硬盘很慢，这让人觉着基于硬盘的持久性结构设计是不是能提供高性能。实际上恰当设计的硬盘结构通常可以和网络一样快。影响硬盘性能的关键事实是随着过去十年的磁盘寻道耗费的延迟的大幅缩小，硬盘驱动器的吞吐量大幅提升，在具有六个7200rpm SATA RAID-5阵列的JBOD配置上线性写入的性能约为600MB/s，但随机写入性能仅为100k/s，相差超过6000倍。这些现行读取和写入是左右使用模式中最可预测的，操作系统也对此进行了大量优化。现代操作系统提供预读和后写技术，以大块多次预取数据并将较小的逻辑写入分组为大型物理写入。有些情况下的硬盘顺序访问可能比内存的随机访问更快。 常量级别时间消息系统中使用的持久化数据结构通常是跟BTree或者其他通用用途的随机访问数据结构每个消费者一个队列来维护消息的元数据信息。Btrees是可用的最通用的数据结构，并且使得可以在消息队列中支持各种各样的事务和非事务的语义。同时也带来了相当高的成本，Btree操作时间复杂度为O(log N)。通常O(log N)被认为基本上等同于恒定时间，但是这不适用于磁盘操作。磁盘一次寻道需要10ms，并且一次只能寻一个，因此并行化受限。因此即使少量的磁盘也导致很高的开销。 Kafka 采用 log append 的方式写磁盘，可以为消息的读写操作提供 O(1)的复杂度，并且读写互相不会 block 其他操作。由于读写操作的复杂度和数据量无关，使得 Kafka 可以运行在普通机器组成的集群中，每台 server 所能存储的消息量也非常大。这同时带来了另外一些便利，与其他消息系统在消息被消费后即删除的方式不同，kafka 可以将消息保存较长的一段时间，为 Consumer 带来很大的灵活性。 IO优化提升效率我们已经付出了很大努力来提高效率。 我们的主要用例之一是处理网络活动数据，这是非常高的量：每个页面视图可能会生成几十个写入。 此外，我们假设每个发布的消息由至少一个消费者（通常很多）阅读，因此我们努力使消费尽可能廉价。 从以往构建和运行类似多个系统的经验看来，我们发现，对于有效地多租户操作效率是关键。如果下游基础设施服务在应用程序使用中由于小的突变很容易成为瓶颈，那么这样的变化总会产生问题。如果性能很快，便有助于确保应用程序不会由于基础设施的小问题而产生故障。这对于在中央集群上运行支持几十或上百的应用程序的集中式服务时特别重要，因为使用方式的变化几乎每天都发生。 上述讨论消除了不良的磁盘访问模式，对于这类系统仍有两个常见的效率低下的原因：太多的小I/O操作，太多的字节复制操作。小的I/O问题在客户端和服务端以及服务端自身的持久化操作都有发生。为了避免这个问题，Kafka使用的协议构建于一种自然地将消息分组到一起的“消息集”的抽象。这允许网络请求将消息分组到一起，而不是一次发送一条消息，缓冲了网络往返的开销。服务器则一次性将消息块追加到log文件中，客户端也一次性抓取大的连续消息块。 这个简单的优化产生数量级的速度。 批处理导致更大的网络包，更大的顺序磁盘操作，连续的内存块等等，所有这些都允许Kafka将随机消息写入的突发流转换为流向消费者的线性写入 另一个效率低下的地方是字节复制。消息比较少时不是问题，但是一旦负载升高，影响就很大。为了避免这个问题，Kafka采取生产者、代理broker服务器、消费者共享的标准二进制格式（这样数据块无需更改便可在三者间传递）。代理服务器维护的消息日志本身就是一个文件组成的目录，每个文件由生产者和消费者共同使用的格式已经写入到磁盘的一系列消息集组成。维护这种通用格式有助于优化最重要的操作：持久日志块的网络传输。现代Unix操作系统提供了高度优化的代码用来将数据从页高速缓冲存储器传输到socket；Linux里则通过sendfile系统调用完成。 为了理解sendfile的影响，有必要理解数据从文件传递到socket几个常见步骤： 操作系统将数据从磁盘读入到内核空间的页高速缓存存储器 应用程序将数据从内核空间读入到用户空间缓存区 应用程序将数据写会到内核空间中的sokcet缓冲区 操作系统从socket缓冲区复制数据到NIC缓冲区，并通过网络发送 DMA copy:direct memory copy；直接内存访问 很显然，这种方式效率低下，有四次复制操作，两次系统调用。使用sendfile后，通过允许操作系统直接发送页缓存的数据到网络而避免重复拷贝的操作，仅仅只需要最后拷贝到NIC缓冲区的操作。 对于一个主题多个消费者的常见使用情形，使用上述的零拷贝优化，数据只有一次被拷贝到页缓存，每次消费都重复使用，而不是加载到内存里当每次读取的时候被复制到内核空间。这使得消息被消费的速率取决于网络连接的限制。页缓存和sendfile的结合意味着消费者大多出现的集群上，你可能观察不到任何磁盘活动，因为都是从缓存提供数据。 更多Java对零拷贝的支持和sendfile的背景，看http://www.ibm.com/developerworks/linux/library/j-zerocopy 端到端的批量消息压缩End-to-end Batch CompressionI在其他场景下，CPU、硬盘其实不是瓶颈，而是网络带宽。很常见的就是需要通过广域网在各个数据中心之间发送消息的数据流水线。当然，用户也总是可以一次压缩信息，而不需要Kafka的帮助，但这样的压缩比通常很低，因为大多数的冗余来自于相同类型的消息间的重复而不是单条消息本身(如，JSON中的字段名称，web日志中的用户代理，公共的字符串值. 高效的压缩需要一次压缩多条消息而不是每次只压缩一条消息。 Kafka允许通过遍历消息集来实现消息批量压缩。多条信息可以放到一起压缩，然后发送压缩后的内容到服务器。这些消息也会按着压缩的格式来写入，并在日志文件中保持压缩格式，并且只会由消费者解压缩。Kafka支持GZIP、Snappy、LZ4压缩协议，更多压缩细节见https://cwiki.apache.org/confluence/display/KAFKA/Compression 生产者负载均衡生产者直接发送数据到某分区的leader消息代理服务器，而不经过任何中间路由层。为了协助生产者实现这个功能，Kafka各个节点都能随时应答对于那些服务器存活、对于某个主题的所有分区leaders服务器地址的请求，协助生产者发送请求到恰当的服务器。 客户端控制着发布消息到哪一个分区，这可以通过随机、实现某种负载均衡的随机、某些语义层面的分区函数来实现。Kafka提供了语法上的分区接口，通过允许用户指定一个关键字分区，然后使用该接口hash到一个分区（如果有必要也可以选择重写分区函数）。例如，如果选择用户id作为关键字，这样对于指定用户的所有消息都被发送到相同分区中。 这反过来将允许消费者对他们的消费进行局部性假设。 这种分区风格被明确地设计为允许消费者进行对局部敏感的处理。 异步发送批处理是效率的主要驱动因素之一，为了启用批处理，Kafka生产者将尝试在内存中累积数据，并在单个请求中发送更大的批次。 批处理可以配置为累积不超过固定数量的消息，并且等待不超过一定的固定等待时间（例如64k或10ms）。 这允许累积更多的字节发送，并且在服务器上几乎没有更大的I / O操作。 这种缓冲是可配置的，并且提供了一种机制来折衷少量的额外延迟以获得更好的吞吐量。 生产者配置见：https://kafka.apache.org/documentation/#producerconfigsapi细节：http://kafka.apache.org/082/javadoc/index.html?org/apache/kafka/clients/producer/KafkaProducer.html 消费者Kafka通过向Kafka服务器发送提取请求，来获取它想要消费的消息所在分区的leader地址。消费者在每次请求中指定日志中消息的偏移量，然后获取到一个从那个位置开始的日志块。这样消费者拥有对消费消息位置的控制权，如果有需要还能够重设其值来重复消费数据。 推或者拉kafka考虑的一个问题：是否消费者应该从服务器拉取数据还是服务器应该推送数据到消费者。在这个角度，Kafka遵循了一个更加传统的设计，也是大多数消息系统使用的 ，生产者发送数据到服务器，消费者从服务器拉取数据。一些集中式日志系统，如Scribe、Apache Flume，遵循的是一种非常不同的基于推的数据推送到下游的思路。两种设计各有利弊，基于推的系统不好应对多样化的消费者，因为服务器控制数据传输的速率。而通常的目标则是让消费者以自己最大的消费速率来消费数据；不幸的是，在推送的系统中，当消费速率跟不上生产速率时，消费者往往被压制（类似于消费者被攻击）。一个基于拉的系统有更好的性能，消费者只是简单的落后于生产者，在可能的时候赶上.","categories":[{"name":"kafka","slug":"kafka","permalink":"http://zhangxiangnan.com/categories/kafka/"}],"tags":[{"name":"kafka","slug":"kafka","permalink":"http://zhangxiangnan.com/tags/kafka/"}]},{"title":"kafka的适用场合","slug":"kafka/kafka的适用场合","date":"2017-02-14T08:06:02.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2017/02/14/kafka/kafka的适用场合/","link":"","permalink":"http://zhangxiangnan.com/2017/02/14/kafka/kafka的适用场合/","excerpt":"kafka的适用场合","text":"kafka的适用场合 Kafka的常见应用场合消息系统 Kafka完全可以替换传统消息服务器。使用消息系统有很多原因，解耦消息生产者和处理过程，缓存未处理的消息等。对比大多数消息系统，Kafka有更高的吞吐量，而且基于分片构建，有副本机制，有容错机制，对于构建大规模可扩展的消息处理程序是不错的选择。 在我们的经验中，消息的使用往往相对低延迟，但需要很低的终端到终端的延迟，且经常依赖于Kafka提供强大的持久性保证。 在消息系统领域，Kafka相较于传统消息系统如ActiveMq、RabbitMQ。 网站活动追踪 Kafka一开始是用来构建用户行为追踪流水线作为一系列实时的发布订阅模型的订阅源。这就是说网站活动（页面浏览、搜索、其他用户产生的行为动作）按着一个活动类型一个主题被发布到中央主题。这些订阅源可以用来消费用于一系列用途如实时处理、实时监控、加载数据到Hadoop或线下数据仓库系统以便于线下处理和报表。 活动行为追踪常常数据量非常大，因为每一次用户浏览页面都产生许多活动信息。 Metrics Kafka经常用来分析运行时的监控数据。这涉及聚合来自分布式应用程序的统计数据来产生运行数据的几种馈送。 日志聚合Log Aggregation 很多人使用Kafka进行日志聚合的方案。日志聚合通常从服务器收集物理日志文件，并将其集中起来（文件服务器或者可能HDFS）处理。Kafka抽象了文件的细节，并将日志或事件数据更清晰地抽象为消息流。这允许更低延迟地处理，更容易支持多数据源和分布式数据消费。相比于以日志为中心的系统如Scribe或者Flume，Kafka提供了同样出色的性能，更强的持久性保证及更低的端到端延迟。 流处理Stream Processing 很多Kafka用户在由多个阶段组成的处理流水线中处理数据，其中原始数据从Kafka主体消费，接着聚合，丰富，或转换到新主题以便于进一步消费或后续处理。如，一个推荐新闻文章的流水线可能先从RSS订阅源抓取文章内容，将其发布到名为“articles”的主题；进一步处理可能是规范化或者对内容去重，然后发布到清理后的内容到一个新主题；最后的处理阶段可能是尝试推荐内容给用户。这样的处理流水线就是基于不同的主题进行实时数据流的处理。从Kafka的0.10.0.0版本处理，一个轻量级但强大的流处理库为Kafka Streams可用来执行上述的数据处理。除了Kafka Streams，也可选择其他开源流处理工具如Apache Storm和Apache Samza。 事件源Event Sourcing 事件源是一种应用程序设计风格，其中状态变化记录为按时间排序的记录序列。Kafka支持非常大的存储日志数据，是构建于这种风格的应用程序极好的后端。 提交日志Commit Log Kafka可以作为分布式系统的一种外部提交日志。该日志有助于各节点间备份数据，以及故障节点重新恢复数据时充当重新同步机制。Kafka的日志压缩特性有助于支持该用途。在这点上，Kafka类似于Apache的Zookeeper项目的作用。","categories":[{"name":"译","slug":"译","permalink":"http://zhangxiangnan.com/categories/译/"},{"name":"kafka","slug":"译/kafka","permalink":"http://zhangxiangnan.com/categories/译/kafka/"}],"tags":[{"name":"kafka","slug":"kafka","permalink":"http://zhangxiangnan.com/tags/kafka/"}]},{"title":"求2个单链表的交点","slug":"leetcode/求2个单链表的交点","date":"2017-01-22T07:21:01.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2017/01/22/leetcode/求2个单链表的交点/","link":"","permalink":"http://zhangxiangnan.com/2017/01/22/leetcode/求2个单链表的交点/","excerpt":"求2个单链表的交点（思考过程及源码）","text":"求2个单链表的交点（思考过程及源码） 求2个单链表的交点160.Intersection of Two Linked Lists https://leetcode.com/problems/intersection-of-two-linked-lists/?tab=Description Write a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3 begin to intersect at node c1. Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. 理解题意 写一个程序来找到两个单链表相交开始的结点。 例如，如下两个链表： A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3 A、B两个链表相交在c1结点。 注意： 如果两个链表没有交点，直接返回null 原有链表必须保持原始结构，即函数无副作用 可假设整个链表结构中没有环 代码的时间和空间复杂度应该为：O(n)，O(1) 实现思路一 1、首先考虑特殊情况，A为null、或B为null，或者两者都为null，则应该返回null 2、一般情况下，连个链表都不为空，假设相交于c1点，借用下图： A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3 梳理已知变量，我们只知道两个链表头结点a1、b1，不知道链表长度，对于链表的操作一般操作只有按顺序遍历，反转等；另外我们可以控制遍历时的速度，一次遍历一个结点还是2个结点，但我们对于A、B两个链表不清楚长度有倍数关系，所以两个链表都单步遍历，一次遍历一个结点（即两者速度一样，则相同时间里行驶的距离一样，即经过的结点数一样）。 那我们就遍历，假设A、B的长度相等，因为2个链表已假设肯定相交，也即交点之前的两个链表的长度相等，两个链表同时进行遍历时判断遍历的节点是否相等就可以找到交点 那对于A、B交点之前的长度不相等的情况即A、B两个链表长度不相等的情况呢？没有思路，先假设c1之前A链表的长度为a,c1之前B链表的长度为b，两者相交后共同的部分长度为c，那么还是让两个指针pa、pb从A、B的头结点均单步遍历，看看会发生什么。pa遍历到末尾c3的时候，pb遍历到不知哪个结点，只知道pb走了pa+c距离，即pa走的长度，还有pb+c-(pa+c)=pb-pa的长度就走到末尾，此时两者行驶的距离一样。 但是我们想要的是pa、pb同时能相聚于c1点，现在pa已经到达c3点，pb还有pb-pa个点要走，想着此时pa等着pb，一直等到pb达到末尾，但貌似没啥用，又要重新开始吗难道？那就不让pa等，两个都接着走，这样pb到终点时，pa又走了pb-pa的距离（假设走的虚拟节点）。 此时pb到达终点c3，pa到终点c3后又多走了pb-pa距离，此时观察下子，发现pb-(pb-pa)=pa，即要是pa到终点后，从b1开始走，走了pb-pa距离，此时pb到终点，而此时pa在B链表上还差pa的距离即达到c1，pb刚好位于终点也是差了pa距离。这时，两个继续走，就能相交于c1. 以上思路是相交的，针对不相交的，同样逻辑判断，若最后没找到那个点即不想交。 实现思路二虚线延长法A: a1 → a2 a1 → a2 ↘ ↗ c1 → c2 → c3 ↗ ↘ B: b1 → b2 → b3 b1 → b2 → b3 单步遍历两个链表（想不到理由会不同速率遍历，因为不知道长度差异，所以就单步试试），速率相同，时间可以自由控制，也就是我们可以决定两个遍历遍历节点数相同还是差异一定倍数。 那假设时间一样吧，因为也想不到为啥时间弄成不一样。指针pa从从a1出发经过c1到c3后，接着走b1到b3；pb从b1出发，经过c1到c3后，继续走a1到a2.此时，pa、pb是同时到达b3、a2的，因为两者速率一样，时间一样，最后经过节点数肯定一样。 c3之后的两个分支是虚拟的，但是我们知道a1和b1两个头结点，若pa、pb上面不是走的虚拟分支，而是交换头结点后继续走，那么会同时到达b3和a2结点，也会同时到c1点，解决。 考虑两个链表没有相交，仍按照上述逻辑交换，执行到最后时，pa、pb的next结点都为null。 代码实现`/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */` public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pa = headA; ListNode pb = headB; boolean swapa = false;// 记录pa是否交换执行到pb boolean swapb = false;// 记录pb是否交换执行到pa while (pa != null &amp;&amp; pb != null) { if (pa == pb) { return pa; } else { pa = pa.next; pb = pb.next; if (pa == null &amp;&amp; !swapa) { pa = headB; swapa = true; } if (pb == null &amp;&amp; !swapb) { pb = headA; swapb = true; } } } return null; } 改进：可以省去标记变量，对于不相交的情况最后两者都会等于null，从而退出循环 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) return null; ListNode pa = headA; ListNode pb = headB; while (a != b) { a = a != null ? a.next : headB; b = b != null ? b.next : headA; } return a; } }","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangxiangnan.com/categories/algorithm/"},{"name":"leetcode","slug":"algorithm/leetcode","permalink":"http://zhangxiangnan.com/categories/algorithm/leetcode/"},{"name":"linked list","slug":"algorithm/leetcode/linked-list","permalink":"http://zhangxiangnan.com/categories/algorithm/leetcode/linked-list/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zhangxiangnan.com/tags/leetcode/"}]},{"title":"求2个数字之和","slug":"leetcode/求2个数字之和","date":"2017-01-18T09:48:01.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2017/01/18/leetcode/求2个数字之和/","link":"","permalink":"http://zhangxiangnan.com/2017/01/18/leetcode/求2个数字之和/","excerpt":"求2个由单链表表示的数字之和","text":"求2个由单链表表示的数字之和 Add Two Numbers-两数之和链接：https://leetcode.com/problems/add-two-numbers/原题：You are given two non-empty linked lists representing two non-negative integers.The digits are stored in reverse order and each of their nodes contain a single digit.Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 单链表定义: `/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */` 翻译给定2个非空单链表来表示2个非负整数，每个数字的每一位在链表中以倒序存储（即链表头结点表示个位数，以此类推），每一个结点包含一个单独的数字。求出2数之和，并以链表形式返回（倒序存储，即链表头结点表示个位数，依次类推）。示例：输入： (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8 题意分析1、和一般2数求和稍微不同，无非就是2个数字用链表表示，链表头结点表示个位数，依次类推。2、正常数字求和无非就是2个数的个位数与个数数相加，得到数字大于9，则需要往十位进位（进位的值为个位数的和/10,整除）。和的个位数值则为个数为和 % 10（对10取余），依次类推。使用链表表示的数字求和原理类似。3、考虑几个特殊情况，若一个数字有2位，一个有3位，此时3位数字的百位数字仍然要和0相加，并加上来自十分位的进位值；若2-&gt;9与8-&gt;1相加呢，和为三位数，其百位值为十位进位得到，需要考虑到进位值所产生的新的结点。 实现思路 1、初始： public class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { .... } 2、题意里说2个非空链表，不用判断链表是否为null； 接着自然想到在求和过程中需要定义一个int变量保存进位值，需要定义一个结点变量表示求和后新链表的头结点ListNode newHead； 在上面分析的过程中，遍历2个链表求和时，需要一个临时变量来保存当前遍历过程中的新结点的值ListNode sumNode: public class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int carry = 0;// 存储进位值，初始化为0 ListNode newHead= null;// 新链表的头结点值，初始化为null while(l1 != null || l2 != null){// 只要2个链表不同时为null，都需要继续遍历求和 ListNode sumNode = null; int sum = carry;// 和，加上进位值 if(l1 != null) {// sum += l1.val;// sum加上l链表当前结点的值 l1 = l1.next;// 修改l1指向下个结点 } if(l2 != null) { sum += l2.val; l2 = l2.next; } // 求进位值和当前位的值 carry = sum / 10; sum = sum %10; // 遍历第一次时，设置新链表头结点的值 sumNode = new ListNode(sum); if(newHead ==null) { newHead = sumNode; } ..... } // 进位不等于0时 if(carry!=0) { .... } return newHead; } } 3、上述过程将sumNode在while循环里作为临时变量，每次while循环后sumNode重新初始化为null，缺少了将每次循环产生的sumNode 连接起来的步骤，所以需要将sumNode移动到while循环外作为临时变量，这样就能记住上次循环的sumNode值； 另外就是进位产生的新结点不在while循环中，需要单独设置循环最后一次的sumNode的next为carry所生成的node： public class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int carry = 0;// 存储进位值，初始化为0 ListNode newHead= null;// 新链表的头结点值，初始化为null ListNode preNode= null;// 每次while循环时上次循环的和结点的值，第一次循环的上一次的和结点值可以理解为null while(l1 != null || l2 != null){// 只要2个链表不同时为null，都需要继续遍历求和 int sum = carry;// 和，加上进位值 if(l1 != null) {// sum += l1.val;// sum加上l链表当前结点的值 l1 = l1.next;// 修改l1指向下个结点 } if(l2 != null) { sum += l2.val; l2 = l2.next; } // 求进位值和当前位的值 carry = sum / 10; sum = sum %10; // 遍历第一次时，设置新链表头结点的值 ListNode sumNode = new ListNode(sum); if(newHead ==null) { newHead = sumNode; preNode = sumNode;// 更新preNode的值为新值 }else { preNode.next = sumNode;// 将上次结点和本次结点连接起来 preNode = sumNode;//更新preNode的值为本次和产生的结点值 } } // 进位不等于0时 if(carry!=0) { preNode.next = new ListNode(carry);// 将上次结点值指向进位产生的结点 } return newHead; } } 进一步优化上个步骤的代码基本可以当做答案，不过可以进一步稍微优化： 求进位值和当前位值可以添加限制条件，不用每次都执行，因为只有当sum&lt;=9时执行和不执行carry和sum值一样 可以使用sum变量提取到while外，作为上一步循环的2个结点的值加上上上一次循环的产生的进位值，这样carry变量就可以省略 while里每次都要判断newHead == null，啰嗦，判断这个条件无非就是newHead初始值为null，那假如这个结点第一次不为null，而是个类似哨兵结点sentinel，这样中间便不用每次判空，直接往后追加，最后直接返回sentinel.next即可。最后结果： public class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode sentinel= new ListNode(0);// 哨兵结点 ListNode preNode= sentinel;// preNode默认为哨兵结点 int sum = 0; //上一步循环的2个结点的值加上上上一次循环的产生的进位值 while(l1 != null || l2 != null){ sum = sum / 10;// 取上次循环sum的进位值 if(l1 != null) { sum += l1.val; l1 = l1.next; } if(l2 != null) { sum += l2.val; l2 = l2.next; } preNode.next = new ListNode(sum%10);; preNode = preNode.next; } // 2个结点的进位值最多为1 if(sum /10 == 1) { preNode.next = new ListNode(1); } return sentinel.next;// 哨兵结点的下一个即为新链表头结点 } } 验证可以通过几个简单case，自行验证：1-&gt;2 2-&gt;3;1-&gt;9 9-&gt;1;1-&gt;9 1;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangxiangnan.com/categories/algorithm/"},{"name":"leetcode","slug":"algorithm/leetcode","permalink":"http://zhangxiangnan.com/categories/algorithm/leetcode/"},{"name":"linked list","slug":"algorithm/leetcode/linked-list","permalink":"http://zhangxiangnan.com/categories/algorithm/leetcode/linked-list/"},{"name":"math","slug":"algorithm/leetcode/linked-list/math","permalink":"http://zhangxiangnan.com/categories/algorithm/leetcode/linked-list/math/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zhangxiangnan.com/tags/leetcode/"}]},{"title":"反转单链表的某部分","slug":"leetcode/反转单链表的某部分-reverse-part-singly-linked-list","date":"2017-01-17T09:07:01.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2017/01/17/leetcode/反转单链表的某部分-reverse-part-singly-linked-list/","link":"","permalink":"http://zhangxiangnan.com/2017/01/17/leetcode/反转单链表的某部分-reverse-part-singly-linked-list/","excerpt":"反转单链表的某部分（思考过程及java源码）","text":"反转单链表的某部分（思考过程及java源码） 反转单链表的某部分Reverse Linked List II(reverse part)https://leetcode.com/problems/reverse-linked-list-ii/ 原题Reverse a linked list from position m to n. Do it in-place and in one-pass. For example: Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4, return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL. Note: Given m, n satisfy the following condition: 1 ≤ m ≤ n ≤ length of list. Subscribe to see which companies asked this question `/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */` 题意大概就是给我们一个单链表，然后让我们反转单链表的一部分（2个参数表示反转的第m个结点到第n个结点，m、n从1开始），反转单链表是要求反转全部，要求必须是一次遍历完成，且必须使用原地算法（使用变量是固定数量的、小的空间，不能现行增长，本地意思是不能复制链表）原地算法：https://zh.wikipedia.org/wiki/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95 大致思路不考虑特殊情况，就考虑大众情况，比方说让我反转1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL的结点2到结点4的部分（m=2，n=4），那我很容易想到就是遍历单链表，遍历的时候定义一个变量i，i==m到i==n中间结点就是我要反转的部分结点，这部分结点反转的逻辑就是反转某个单链表；接着就是这部分反转后的部分结点，需要和原链表按顺序连一块，本例就是1和4连，2和5连，那意思是我遍历的时需要记住待反转部分结点的前面一个结点和后一个结点，还需记住待反转部分反转后的首尾结点，然后返回结果是原链表的头结点，所以还需要记住原链表的头结点。接着，我可以遍历一遍找到m、n对应结点，然后再从m遍历到n进行链表反转，这样子遍历不止一次，不符合题目要求，只能在一次遍历的时候同时反转 具体过程 1、首先我先对head或者head.next == null的情况做下检查，head.next == null情况可能不太好想一开始，先排除： public ListNode reverseBetween(ListNode head, int m, int n) { if(head == null || head.next == null) return head; ... } 2、接着我按着刚才的思路，定义几个相关变量，并初始化下值： public ListNode reverseBetween(ListNode head, int m, int n) { if(head == null || head.next == null) return head; int i = 1;// 因为m、n从1开始，所以统一i也从1开始 ListNode oldHead = head;// 原链表的头结点，赋值应该没啥异议 ListNode reversePreNode = null;// 反转部分链表反转前其头结点的前一个结点 ListNode reversedTail = null;// 反转部分链表反转后的尾结点，一开始不知道，为null ListNode reverseNextNode = null;// 反转部分链表反转前尾结点的下一个结点 ListNode reversedNewHead = null;// 反转部分链表反转后的头结点，一开始不知道，为null ... } 3、开始遍历，遍历时，我可以用while、for都行，此处用while，所以上步定义了变量i表示迭代的次数，遍历得有结束遍历的条件吧，毕竟只反转一部分，不需要遍历所有结点，所以我需要加个结束条件if(i&gt;n)break;接着就是寻找第2步中定义的几个变量的值： reversePreNode的含义是反转部分反转前头结点的前一个结点，反转部分反转前头结点其索引顺序为m，m的前一个结点索引为m－1，所以遍历时，若i=m-1，则该结点就是reversePreNode的值（反转部分反转前头结点的前一个结点）； reversedTail含义为反转部门链表反转后的尾结点，那就是找反转前的头结点，头结点索引顺序为m，则若i＝＝m，则当前结点就是reversedTail的值因为要在一次循环里搞定，所以朦胧感觉可能需要在while里有一段代码做反转操作： public ListNode reverseBetween(ListNode head, int m, int n) { if (head == null) return null; if (head.next == null) return head; int i = 1; ListNode reversedNewHead = null;// 反转部分链表反转后的头结点 ListNode reversedTail = null;// 反转部分链表反转后的尾结点 ListNode oldHead = head;// 原链表的头结点 ListNode reversePreNode = null;// 反转部分链表反转前其头结点的前一个结点 ListNode reverseNextNode = null; while (head != null) { if (i &gt; n) { break; } if (i == m - 1) { reversePreNode = head; } if (i == m) { reversedTail = head; } // 反转结点逻辑... i++;// 更新i，没啥异议吧 } return xx;// 暂定，未知 } 4、接着就是反转结点部分的逻辑: 首先反转结点逻辑可参考反转单链表的几句关键逻辑（临时变量next保存当前结点的next结点，修改当前结点的next指向已️反转部分链表头结点，然后更新已反转链表头结点指向，更新待反转链表的头结点指向)，几个变量对应到步骤2定义的变量即可 反转的结点是在m和n之间，所以反转逻辑应该在if(i&gt;=m &amp;&amp; i&lt;=n) 条件内执行 遍历时需要修改head指向为下一个结点，所以要在各个if else分支里都要执行head＝head.next public ListNode reverseBetween(ListNode head, int m, int n) { if (head == null) return null; if (head.next == null) return head; int i = 1; ListNode reversedNewHead = null;// 反转部分链表反转后的头结点 ListNode reversedTail = null;// 反转部分链表反转后的尾结点 ListNode oldHead = head;// 原链表的头结点 ListNode reversePreNode = null;// 反转部分链表反转前其头结点的前一个结点 ListNode reverseNextNode = null; while (head != null) { if (i &gt; n) { break; } if (i == m - 1) { reversePreNode = head; } if (i &gt;= m &amp;&amp; i &lt;= n) { if (i == m) {// 这部分移到if条件里 reversedTail = head; } reverseNextNode = head.next;// 反转前保存当前结点的next结点，反转结束时该值刚好是reverseNextNode代表的含义 head.next = reversedNewHead;// 修改当前结点（待反转链表部分的头结点）指向已反转链表部分的头结点 reversedNewHead = head;// 更改已反转链表的头结点的指向 head = reverseNextNode;// 更新head指向为待反转链表的头结点 } else { head = head.next;// 更新head指向为其下一个结点 } i++;// 更新i，没啥异议吧 } return xx;// 暂定，未知 } 5、收尾与返回逻辑： 在循环里执行反转后，紧接着需要在循环外执行更新reversedTail的next指向，根据几个变量含义，让其指向reverseNextNode即可。 返回结果就需要考虑几种情况了，因为需要返回反转后新链表的头结点，但是m有可能&gt;=2，此时reversePreNode肯定不为空，需要将reversePreNode的next指向反转部分新的头结点，然后直接返回oldHead即可；若m==1,则不能这么做，需要返回反转部分链表的新的头结点，即reversedNewHead： public ListNode reverseBetween(ListNode head, int m, int n) { if (head == null) return null; if (head.next == null) return head; int i = 1; ListNode reversedNewHead = null;// 反转部分链表反转后的头结点 ListNode reversedTail = null;// 反转部分链表反转后的尾结点 ListNode oldHead = head;// 原链表的头结点 ListNode reversePreNode = null;// 反转部分链表反转前其头结点的前一个结点 ListNode reverseNextNode = null; while (head != null) { if (i &gt; n) { break; } if (i == m - 1) { reversePreNode = head; } if (i &gt;= m &amp;&amp; i &lt;= n) { if (i == m) { reversedTail = head; } reverseNextNode = head.next; head.next = reversedNewHead; reversedNewHead = head; head = reverseNextNode; } else { head = head.next; } i++; } reversedTail.next = reverseNextNode; if (reversePreNode != null) { reversePreNode.next = reversedNewHead; return oldHead; } else { return reversedNewHead; } }","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangxiangnan.com/categories/algorithm/"},{"name":"leetcode","slug":"algorithm/leetcode","permalink":"http://zhangxiangnan.com/categories/algorithm/leetcode/"},{"name":"linked list","slug":"algorithm/leetcode/linked-list","permalink":"http://zhangxiangnan.com/categories/algorithm/leetcode/linked-list/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zhangxiangnan.com/tags/leetcode/"}]},{"title":"反转单链表","slug":"leetcode/反转单链表-reverse-singly-linked-list","date":"2017-01-12T09:22:08.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2017/01/12/leetcode/反转单链表-reverse-singly-linked-list/","link":"","permalink":"http://zhangxiangnan.com/2017/01/12/leetcode/反转单链表-reverse-singly-linked-list/","excerpt":"反转单链表（思考过程及java源码）","text":"反转单链表（思考过程及java源码） 反转单链表Reverse a singly linked list.https://leetcode.com/problems/reverse-linked-list/ 迭代方式思路 已知条件：假定给定一个正常单链表a-&gt;b-&gt;c-&gt;d，ListNode l1 = a; 推导：反转无非是把已知的链表转化为d-&gt;c-&gt;b-&gt;a，即将原链表的结点指向全部反向。那么，开始思考： 1、首先我定义一个变量指向a，表示待反转链表的头结点ListNode oldHead=a，接着第一步很自然想到把a的next指向null，但是一旦我这么改的话，我就没法得到b结点，进而没法修改b的next指向。故我需要在修改a的指向前，提前定义一个额外的变量来临时保存a的next指向，那么我定义ListNode nextNode = oldHead.next，此时nextNode指向b结点，链表还未做任何改动，即a(oldHead)-&gt;b(nextNode)-&gt;c-&gt;d; 2、定义了nextNode变量，那么我修改a的指向便无后顾之忧，所以我执行oldHead.next = null,即使a的next指向null，此时原链表变为了2段，一段是a(oldHead)-&gt;null（称作已反转链表部分），另一段是b(nextNode)-&gt;c-&gt;d（称作未反转链表部分），因为oldHead的含义理解为当前需要反转的结点，因为需要将oldHead指向nextNode(b)，并将nextNode指向nextNode.next(c)，修改oldHead指向的话，需要记住已分割部分的头结点，只能再定义个结点newHead=oldHead，执行顺序为newHead=oldHead，oldHead=nextNode，nextNode=nextNode.next，此时链表的2段为a(newHead)-&gt;null, b(oldHead)-&gt;c(nextNode)-&gt;d-&gt;null。 3、此时我接着要把未反转链表部分接着反转，把头结点b的next指向a（即把未反转链表的头结点指向已反转链表的头结点），此时链表分两段为b（oldHead）-&gt;a（newHead）-&gt;null，c(nextNode)-&gt;d，接着我需要更新几个变量的指向（使其oldHead指向c，newHead就需要指向b，nextNode指向d，2段链表分别为b(newHead)-&gt;a-&gt;null,c(oldHead)-&gt;d(nextNode)-&gt;null。 4、继续重复过程3，修改c的next使其指向b，那么我得到c（oldHead）—&gt;b（newHead）-&gt;a-&gt;null，d（nextNode）-&gt;null，更新几个变量指向后，2段链表为c(newHead)-&gt;b-&gt;a-&gt;null，d(oldHead)-null(nextNode) 5、再重复过程3，修改d的next=newHead,2段链表分别为d(oldHead)-&gt;c(newHead)-&gt;b-&gt;a-null，null(nextNode)，此时已经反转完成，然后迭代结束条件就是nextNode==null 6、总的来说，需要newHead、oldHead、nextNode3个变量，在原链表还是一段的时候，我们的oldHead指向a，nextNode=a.next，newHead则等于null,三个变量的表示意思为：oldHead表示待反转链表的头结点，newHead表示已反转链表的头结点（所以一开始初始值为null），nextNode表示带反转链表的头结点的下一个结点（所以初始值为oldHead.next)。 迭代（循环）实现`/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */` public class Solution { public ListNode reverseList(ListNode head) { if(head == null) return null; ListNode newHead = null; ListNode oldHead = head; ListNode nextNode = head.next;// nextNode定义为待反转链表头结点的next结点，初始化为head的next结点 while(nextNode != null){// 待反转链表头结点的next结点不为null作为条件 oldHead.next = newHead; newHead =oldHead; oldHead = nextNode; nextNode = nextNode.next; } oldHead.next = newHead;// 需要手动更改待反转链表的最后一个头结点的指向 newHead = oldHead;// 该步可以省略，直接返回oldHead，为了更清晰。 return newHeadNode; } } 为什么while循环要以nextNode！= null作为结束条件？考虑以下实现，只是不同的初始化方式： `/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */` public class Solution { public ListNode reverseList(ListNode head) { if(head == null) return null; ListNode newHead = null;// 定义为已反转链表头结点 ListNode oldHead = head;// 定义为待反转链表头结点 ListNode next = null;// 定义为待反转链表的头结点的next结点，初始化为null while(oldHead != null){//迭代结束条件是待反转链表的头结点不为null，为null说明反转结束 next = oldHead.next;// 保存next指向 oldHead.next = newHead; newHead = oldHead; oldHead = next; } return newHead;// newHead结点即为新链表的头结点 } } 递归方式思路前面分析的过程可以概括为一个已反转链表（初始为null）部分，一个未反转链表部分（初始为待反转链表），每次都是从待反转链表拿出头结点，作为已反转链表部分的头结点，不断重复这个过程，直到待反转链表部分只剩下null结点。这个过程和递归很类似，递归就是在函数里调用函数本身，重复调用函数本身说明解决的问题结构很类似，刚才的分析过程中一直存在的结构或变量有2个，一个是已反转链表、一个未反转链表，那递归函数是不是可以这么定义？ private ListNode reverse(ListNode oldHead, ListNode newHead) 我在这个函数里要调用函数自身进行递归，所以： private ListNode reverse(ListNode oldHead, ListNode newHead){ return reverse(oldHead, newHead); } 貌似需要在递归里做些处理，回想我们在每一次的从待反转链表结点里拿出头结点oldHead（拿出前需要先记住oldHead的next结点，否则修改oldHead的next指向后，便找不到原next结点了），将其next指向已反转链表的头结点，这样未反转链表和已反转链表的头结点都发生了变化，我们需要更新oldHead和newHead的指向。 private ListNode reverse(ListNode oldHead, ListNode newHead){ ListNode next = oldHead.next;// 记住待反转链表头结点的next结点 oldHead.next = newHead;// 将oldHead结点从待反转链表结点拿出，使其成为已反转链表结点的头结点 newHead = oldHead;// 更新newHead结点指向 oldHead = next;// 更新oldHead结点指向，指向此时待反转链表结点的头结点（为先前保存的next指向的结点） return reverse(oldHead, newHead); } 貌似递归还缺少递归出口，拿什么作为出口？回想刚才分析过程，最终是以待反转链表的头结点未null，结束，此时已反转链表的头结点就是反转后新链表的头结点。 private ListNode reverse(ListNode oldHead, ListNode newHead){ if(oldHead == null) return newHead; ListNode next = oldHead.next;// 记住待反转链表头结点的next结点 oldHead.next = newHead;// 将oldHead结点从待反转链表结点拿出，使其成为已反转链表结点的头结点 newHead = oldHead;// 更新newHead结点指向 oldHead = next;// 更新oldHead结点指向，指向此时待反转链表结点的头结点（为先前保存的next指向的结点） return reverse(oldHead, newHead); } 递归方式实现public ListNode reverseList(ListNode head) { if(head == null) return null; return reverse(head, null);// 一开始已反转链表为null，因此头结点未null } private ListNode reverse(ListNode oldHead, ListNode newHead){ if(oldHead == null) return newHead; ListNode next = oldHead.next;// 记住待反转链表头结点的next结点 oldHead.next = newHead;// 将oldHead结点从待反转链表结点拿出，使其成为已反转链表结点的头结点 // 以下2个更新可以省略，为了清晰 newHead = oldHead;// 更新newHead结点指向 oldHead = next;// 更新oldHead结点指向，指向此时待反转链表结点的头结点（为先前保存的next指向的结点） return reverse(oldHead, newHead); }","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zhangxiangnan.com/categories/algorithm/"},{"name":"leetcode","slug":"algorithm/leetcode","permalink":"http://zhangxiangnan.com/categories/algorithm/leetcode/"},{"name":"linked list","slug":"algorithm/leetcode/linked-list","permalink":"http://zhangxiangnan.com/categories/algorithm/leetcode/linked-list/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://zhangxiangnan.com/tags/leetcode/"}]},{"title":"kafka的入门知识","slug":"kafka/kafka的入门知识","date":"2017-01-09T09:17:02.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2017/01/09/kafka/kafka的入门知识/","link":"","permalink":"http://zhangxiangnan.com/2017/01/09/kafka/kafka的入门知识/","excerpt":"kafka的入门知识","text":"kafka的入门知识 kafka的背景Kafka是LinkedIn开发的一个分布式消息系统，使用Scala编写，现成为Apache项目。它以可水平扩展和高吞吐率而被广泛使用。目前越来越多的开源分布式处理系统如Cloudera、Apache Storm、Spark都支持与Kafka集成。现在很多不同类型公司用来作为多种类型的数据管道和消息系统使用。 应用场景 日志收集：收集各种服务的log，通过kafka以统一接口方式开放给consumer，例如：Hadoop、Hbase等 消息系统：解耦producer和consumer，缓存消息 用户活动跟踪：记录用户各种活动，如page view、搜索、点击等，这些消息被发送到topic中，然后consumer做实时的监控分析 运营指标：记录运营监控指标，服务器的性能数据，如：CPU,IO,响应时间等 事件源 实时流处理 提交日志，用于备份还原 kafka的拓扑结构拓扑图 几个概念BrokerKafka集群包含一个或多个服务器，这种服务器被称为broker（代理服务器）。一台kafka服务器就是一个broker，一个集群由多个broker组成，一个broker可以容纳多个topic。 Topic每条发布到Kafka集群的消息都有一个类别或者叫做主题，这个类别被称为Topic，Kafka中Topic可以理解为一个存储消息的队列。物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存在一个或多个broker上，但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处。 Partition分区，Partition是物理上的概念，Kafka物理上把Topic分成一个或多个Partition，每个Partition在物理上对应一个文件夹，该文件夹下存储这个Partition的所有消息和索引文件。如创建topic1和topic2两个topic，且分别有13个和19个Partition分区，则整个集群上相应会生成32个文件夹。为了实现扩展性，一个非常大的topic可以分布到多个broker上，但kafka只保证按一个partition中的顺序将消息发给consumer，不保证一个topic的整体（多个partition间）的顺序。 Producer消息生产者，负责发布消息到Kafka broker Consumer消息消费者，向Kafka broker读取消息的客户端。 Consumer Group（CG）kafka用来实现一个topic消息的广播（发给所有的consumer）和单播（发给任意一个consumer）的手段。一个topic可以属于多个CG，即多个CG可以无差别地消费一个topic的信息。topic的消息会复制（不是真的复制，是概念上的）到所有的CG，但每个CG只会把消息发给该CG中的一个consumer。如果需要实现广播，只要每个consumer有一个独立的CG就可以了。要实现单播只要所有的consumer在同一个CG。用CG还可以将consumer进行自由的分组而不需要多次发送消息到不同的topic（不懂）。每个consumer属于一个特定的Consumer Group, Kafka允许为每个consumer指定group name，若不指定group name则属于默认的group。 Offset偏移量kafka的存储文件都是按照offset.kafka来命名，用offset做名字的好处是方便查找。例如你想找位于2049的位置，只要找到2048.kafka的文件即可。当然the first offset就是00000000000.kafka 一个Kafka集群中会包含若干个Producer（可能是端上的PV数据，或者服务器日志，CPU、Memory监控信息等），若干个Broker（Broker越多，集群的吞吐量越高），若干个Consumer Group，以及一个zookeeper集群。Kafka通过zookeeper管理broker和consumer的动态加入和离开。Producer通过push方式将消息发送到Broker，Consumer通过pull方式从Broker订阅消费消息。 kafka是一个分布式的流式传输平台分布式流平台应该具有的三个特征： 可以发布和订阅流记录流，这点类似于消息队列或者企业级消息系统 可以以容错方式存储记录流 可以当产生记录流时进行处理. kafka的优势kafka用于2大类应用程序： 构建可靠地在系统或应用程序之间获取数据的实时流数据流水线 构建对数据流进行变换或反应的实时流应用程序 相关概念：Kafka作为集群运行在一个或者多个机器上Kafka集群以称为主题的类别存储记录流。每个记录由一个键，一个值和一个时间戳组成。 Kafka有四个核心API： Producer API允许应用程序发布记录流到一个或多个Kafka主题 Consumer API允许应用程序订阅一个或多个主题，并处理为其生成的记录流. Steams API允许应用程序充当流处理器，从一个或多个主题消费输入流，然后产生输出流到一个或多个输出主题，高效地转换输入流到输出流。 Connector API允许构建和运行可重用的生产者或消费者，将Kafka主题连接到现有应用程序或数据系统。例如，关系数据库的Connector连接器可能捕获对表的每个更改。 Kafka中，客户端和服务端的通讯使用一个简单的，高性能的，语言无关的TCP协议。该协议有版本控制，并保持与旧版本的向后兼容性。同时，提供了很多种语言的Kafka客户端。 Kafka文件存储机制Topic &amp; PartitionKafka为记录流提供的核心抽象便是主题（topic）.主题是发布记录的类别或者feed名称。Kafka的主题总是支持多个消费者的，即一个主题可以拥有0个、1个或者多个订阅者来订阅发送到该主题的数据。 对于每个主题，Kafka集群维护了一个分区日志如下图： 逻辑上Topic可以看为一个Queue，每个消息必须指定它所属的Topic，可理解为每条消息必须指明放到哪个Queue里。物理上把Topic分成一个或多个Partition，每个Partition对应一个文件夹，文件夹存储Partition所有消息和索引文件。每个Partition有自己的副本，每个副本分布在不同的Broker节点上。通过多个Partition可使得吞吐率能线性提升。消息append到Partition中，属于顺序写磁盘，顺序写磁盘效率远大于随机写内存，因此效率高。 每一个分区是一个有序的、不可变的记录序列，不断地追加到结构化提交日志。分区中的每条记录都被赋予了一个顺序的id号，称作offset偏移量，偏移量在某个分区内唯一标示每条记录。 Kafka集群保留所有已发布的记录，无论是否已经被消费。当然保留所有数据也不现实，kafka提供两种方式来删除数据，一种通过配置来定义数据的保留时间，另一种通过配置分区文件大小限制。例如，如果设置保留策略为2天，则一条记录在被发布后的2天之内，是可以被消费的，一旦2天过后则被丢弃来达到释放空间的目的。Kafka的性能和数据的大小密切相关，和将数据存储多长时间无太大关系. 事实上，每个消费者保留的唯一元数据是该消费者在日志中的偏移或位置。这种偏移由消费者控制，通常消费者在读取记录时线性地提前其偏移，但是实际上，由于消费者控制着位置的值，所以它可以以喜欢的任何顺序来消费数据。例如，一个消费者可以将偏移量的值减小来重复处理以前的数据，或者跳过最近的记录从“现在”开始消费数据。 这些功能的组合使kafka的消费者非常轻量级，消费者来来去去，对集群和其他消费者却没什么太多影响。如，你可以通过kafka命令行工具的tail命令来获取任何主题的记录，却无需更改任何现有用户使用的内容。 日志的分区设计有几个目的。首先分区使日志可以增加到超出单台服务器的容量。首先，它们允许日志扩展到适合单个服务器的大小。每个单独的分区必须适合托管它的服务器，但主题可能有许多分区，因此它可以处理任意数量的数据。第二，为了并行性 partition存储结构Partition命名规则：Topic+有序序号(从0开始)，例如topic_name-0, topic_name-1, topic_name-2 … Partition和副本分配方法。例如一个Kafka集群有2个Broker，创建一个Topic包含2个Partition，1个副本，则broker-0存放partition-0、partition-1，broker-1存放partition-0，partition-1即可 。 Partition中文件存储方式：每个Partition平均分配到多个大小相等的Segment数据文件中，Segment文件生命周期由server端配置参数决定。Kafka有2种策略删除旧数据： 基于时间，例如：删除1周以前的数据 基于partition文件大小，例如：Partition文件大于1GB时候删除旧数据 分布式日志的分区分布在kafka集群中的服务器上，每个服务器处理数据并请求共享分区。每个分区都使用可配置数量的服务器进行复制，以实现容错。 每个分区都有一台机器充当leader，0或者多台机器充当followers。leader处理所有的针对该分区的读和写请求，followers则被动同步leader的数据。若leader宕机，则kafka自动选取一个followers来充当leader。每个服务器都充当某个分区的leader，同时，又充当剩下分区的follower，这样实现集群的负载均衡。 生产者Producers生产者发布数据到他们选择发布的主题上。生产者决定哪条记录发布到主题内的哪个分区上，实现这个功能可以通过简单轮询或者通过语法层面的分区函数（如根据记录里的某个关键字段）来实现负载均衡。 消费者Consumers消费者使用一个消费者组名称consumer group name来标记自己，发布到主题的每个记录针对订阅该主题的每个消费组只会发送给其中一个消费者实例（消费者实例可以是在单独的进程或者单独的机器上）。如果所有的消费者实例有相同的消费组，这样数据将在这些消费者实例中很好地负载均衡。如果所有的消费者实例都有着不同的消费组，这样每条数据记录都会被广播到所有的消费者实例中。 如图，两台服务器组成的kafka集群，托管有四个分区(p0~p3)，与2个消费组。消费组A有2个消费者实例，消费组B有4个消费者实例。 通常情况下，一个主题有少量的消费组，可以理解为“逻辑上的订阅者”。为了扩展和容错，每个消费组里包含多个消费者实例。这就和发布-订阅模型很像，只不过kafka的一个订阅者是一个由很多实例组成的集群而不是单个进程。 在Kafka中实现消费的方式是通过在消费者实例上划分日志中的分区，使得每个实例在任何时间点是分区的“公平共享”的独占消费者。维持消费组内的消费实例与分区关系的过程是通过kafka协议动态完成的。如果新的消费实例加入消费组，他们会从组内的其他消费实例的手中接管一些分区；如果一个消费者实例死掉，它负责的分区会被分派到其他尚存的消费者实例中。 Kafka只提供一个分区内记录的总顺序，而不是主题中的不同分区之间，即不保证一个主题内不同分区的数据间的顺序关系。每个分区的顺序性结合按键分割数据的特性已经能满足大部分的程序需要。然而，如果你需要对记录进行总排序，可以使用只有一个分区的主题来实现，这意味着每个消费组内也只能有一个消费者实例。 保证Kafka提供了如下保证： 生产者发送到特定主题分区的消息将按照发送时的顺序进行追加。即，如果记录M1和M2都是被同一个生产者发送，且M1先发送，这样M1拥有比M2小的偏移量，而且在日志文件里也出现的比M2早。 一个消费者实例按照记录在日志文件里存储的顺序消费数据。 针对副本个数设置为N的主题，kafka可以容忍N-1个服务器故障而不丢失任何提交到日志文件的任何记录。 Kafka作为消息系统Messaging SystemKafka流的概念 VS 传统企业级消息系统： 1、传统消息系统有2个模型：队列和发布-订阅模型。针对队列，一组消费者从一个服务器读取数据，每一条记录只被其中的一个消费者消费；针对发布-订阅模型，每条记录被广播到所有消费者。这2个模型都有其优势和劣势。队列允许你分割数据的处理到多个消费者实例，让你可以扩展处理过程，但不支持多个消费者组,因为一旦一个进程消费了数据数据便不可再被消费。发布订阅允许你广播数据到多个订阅者，但是不能够扩展处理过程因为每条记录都被发送到每一个订阅者。 由此，kafka产生了消费组的概念，和队列一样，消费组让你可以分割处理过程到一系列进程去处理（消费组的成员）。和订阅发布类似，消费组让你可以广播信息到多个消费组。 Kafka模型的优势是每个主题都有着两个特性，可以扩展处理过程同时支持多订阅者，没有必要非得像传统消息系统一样非得选择队列或者订阅发布模型。 2、Kafka相比传统消息系统也有着更强的顺序保证：传统队列在服务器端按顺序保留记录，如果多个消费者从队列里消费数据，服务端按照他们存储的顺序分发记录，记录被异步传递到消费者，所以记录可能到达不同的消费者时丢失了顺序。这意味着存在并行消费时，记录的顺序在被多个消费者消费时的顺序和其存储顺序则不一致。消息系统通常使用一个叫做独占消费者的概念来解决这个问题，独占消费者只允许一个进程来从队列里消费数据，但这意味着处理过程没有并行性。 Kafka做得更好。通过在主题内部具有并行性的概念（分区），kafka可以在多个消费者进程间保证顺序和负载均衡。通过将主题内的分区分派到消费组内的消费者来实现，这样每个分区仅仅被该消费组内的恰好一个消费者消费。这样，kafka确保指定消费者是指定分区的唯一消费者，并且按顺序消费数据。由于有多个分区，这样做仍然可以在多个消费者实例上负载均衡。注意一个消费组里的消费者实例不能超过主题的分区数。 kafka作为存储系统任何允许发布消息和消费消息两个过程解耦的消息队列实际上都充当正在传输的消息的存储系统。Kafka就是一个非常优秀的存储系统。写到Kafka的信息被写到了磁盘，为了容错进行了复制。Kafka为生产者提供确认机制，这样直到数据被全部复制成功后，一个写操作才被认为成功，并且保证即时服务器写入失败也会持续运行。Kafka使用的磁盘结构很容易扩展-无论服务器上有50KB还是50TB的持久化数据，Kafka做的事情是一样的。 由于对很好地利用存储，并且允许客户端来控制自身的读取位置，所以将Kafka当做某种特殊用途的分布式文件系统，致力于解决高性能、低延迟的提交日志存储，复制和传播特性。 ###kafka作为流处理系统Kafka不仅仅可以用来读、写、存储数据流、还是可以当做实时流处理系统。Kafka中，流处理器是从输入主题中获取连续数据流，然后对输入数据做一些处理，接着产生连续数据流到输出主题的任何东西。如，一个零售程序接收销售和货物的输入数据流，然后计算后产生排序和价格调整的输出流。 如果是直接做一些简单的处理过程可以通过producer和consumer的API，对于更复杂的转换，Kafka提供了一套完整集成的流API，允许对流进行计算聚合或者合并流数据。 这套API帮助解决了这些难题：处理无序数据，重复处理数据，执行状态有关的计算等。这套API构建与Kafka提供的核心原是愈发：生产者消费者API，Kafka的有状态存储机制，在流处理器实例之间使用相同的group组机制进行容错 总结Kafka包含了消息、存储、流处理这些特性看似不寻常，但是Kafka作为一个流平台这些都是必须的。分布式文件系统如HDFS允许存储静态文件用来批处理。这样的系统实际上可以存储并处理过去的历史数据。 传统企业级消息系统让你可以处理在订阅之后产生的数据，而构建于分布式文件系统的系统则可以处理订阅之前的数据。Kafka拥有这两种特性，这对于Kafka作为流程序平台和流数据流水线至关重要 通过结合了存储和低延迟订阅的特性，流式应用程序以同样的方式处理过去和未来的数据。这个单一的程序可以处理历史的、已存储的数据；当消费到最后一条数据时，并没有结束，可以继续处理未来产生的数据。这便是流处理的一个广义概念，包括了批处理和消息驱动程序。 同样，对于流水局流水线而言，订阅和实时事件相结合使借助Kafka作为非常低延迟的流水线成为可能；可靠存储数据的特性使其应用于传送关键数据的场合，这些场合对于数据的传递必须得到保证，或者用于和仅仅周期性加载数据或可以长时间进行维护的离线系统进行集成的场景。Kafka流处理设施使得可以在数据到达时变换数据。","categories":[{"name":"kafka","slug":"kafka","permalink":"http://zhangxiangnan.com/categories/kafka/"}],"tags":[{"name":"kafka","slug":"kafka","permalink":"http://zhangxiangnan.com/tags/kafka/"}]},{"title":"go的GOPATH概念","slug":"go/go的GOPATH概念","date":"2017-01-06T08:27:12.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2017/01/06/go/go的GOPATH概念/","link":"","permalink":"http://zhangxiangnan.com/2017/01/06/go/go的GOPATH概念/","excerpt":"go的GOPATH概念","text":"go的GOPATH概念 Go的路径概念用来解析引入的声明The Go path is used to resolve import statements.It is implemented by and documented in the go/build package. The GOPATH environment variable lists places to look for Go code.On Unix, the value is a colon-separated string.On Windows, the value is a semicolon-separated string.On Plan 9, the value is a list. GOPATH must be set to get, build and install packages outside thestandard Go tree. Each directory listed in GOPATH must have a prescribed structure: The src directory holds source code. The path below srcdetermines the import path or executable name. The pkg directory holds installed package objects.As in the Go tree, each target operating system andarchitecture pair has its own subdirectory of pkg(pkg/GOOS_GOARCH). If DIR is a directory listed in the GOPATH, a package withsource in DIR/src/foo/bar can be imported as “foo/bar” andhas its compiled form installed to “DIR/pkg/GOOS_GOARCH/foo/bar.a”. The bin directory holds compiled commands.Each command is named for its source directory, but onlythe final element, not the entire path. That is, thecommand with source in DIR/src/foo/quux is installed intoDIR/bin/quux, not DIR/bin/foo/quux. The “foo/“ prefix is strippedso that you can add DIR/bin to your PATH to get at theinstalled commands. If the GOBIN environment variable isset, commands are installed to the directory it names insteadof DIR/bin. GOBIN must be an absolute path. Here’s an example directory layout: GOPATH=/home/user/gocode /home/user/gocode/ src/ foo/ bar/ (go code in package bar) x.go quux/ (go code in package main) y.go bin/ quux (installed command) pkg/ linux_amd64/ foo/ bar.a (installed package object) Go searches each directory listed in GOPATH to find source code,but new packages are always downloaded into the first directoryin the list. See https://golang.org/doc/code.html for an example. Internal Directories Code in or below a directory named “internal” is importable onlyby code in the directory tree rooted at the parent of “internal”.Here’s an extended version of the directory layout above: /home/user/gocode/ src/ crash/ bang/ (go code in package bang) b.go foo/ (go code in package foo) f.go bar/ (go code in package bar) x.go internal/ baz/ (go code in package baz) z.go quux/ (go code in package main) y.go The code in z.go is imported as “foo/internal/baz”, but thatimport statement can only appear in source files in the subtreerooted at foo. The source files foo/f.go, foo/bar/x.go, andfoo/quux/y.go can all import “foo/internal/baz”, but the source filecrash/bang/b.go cannot. See https://golang.org/s/go14internal for details. Vendor Directories Go 1.6 includes support for using local copies of external dependenciesto satisfy imports of those dependencies, often referred to as vendoring. Code below a directory named “vendor” is importable onlyby code in the directory tree rooted at the parent of “vendor”,and only using an import path that omits the prefix up to andincluding the vendor element. Here’s the example from the previous section,but with the “internal” directory renamed to “vendor”and a new foo/vendor/crash/bang directory added: /home/user/gocode/ src/ crash/ bang/ (go code in package bang) b.go foo/ (go code in package foo) f.go bar/ (go code in package bar) x.go vendor/ crash/ bang/ (go code in package bang) b.go baz/ (go code in package baz) z.go quux/ (go code in package main) y.go The same visibility rules apply as for internal, but the codein z.go is imported as “baz”, not as “foo/vendor/baz”. Code in vendor directories deeper in the source tree shadowscode in higher directories. Within the subtree rooted at foo, an importof “crash/bang” resolves to “foo/vendor/crash/bang”, not thetop-level “crash/bang”. Code in vendor directories is not subject to import pathchecking (see ‘go help importpath’). When ‘go get’ checks out or updates a git repository, it now alsoupdates submodules. Vendor directories do not affect the placement of new repositoriesbeing checked out for the first time by ‘go get’: those are alwaysplaced in the main GOPATH, never in a vendor subtree. See https://golang.org/s/go15vendor for details.","categories":[{"name":"译","slug":"译","permalink":"http://zhangxiangnan.com/categories/译/"},{"name":"go","slug":"译/go","permalink":"http://zhangxiangnan.com/categories/译/go/"},{"name":"GOPATH","slug":"译/go/GOPATH","permalink":"http://zhangxiangnan.com/categories/译/go/GOPATH/"}],"tags":[{"name":"guava","slug":"guava","permalink":"http://zhangxiangnan.com/tags/guava/"},{"name":"immutableCollections","slug":"immutableCollections","permalink":"http://zhangxiangnan.com/tags/immutableCollections/"}]},{"title":"guava的集合工具类详解","slug":"guava/collections/guava的集合工具类详解","date":"2016-11-22T07:18:15.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2016/11/22/guava/collections/guava的集合工具类详解/","link":"","permalink":"http://zhangxiangnan.com/2016/11/22/guava/collections/guava的集合工具类详解/","excerpt":"JDK集合框架提供了许多工具，方便实用，Guava相比提供了更多的工具，适用于所有集合，这也是guava更流行和成熟的部分。","text":"JDK集合框架提供了许多工具，方便实用，Guava相比提供了更多的工具，适用于所有集合，这也是guava更流行和成熟的部分。 guava针对一个特定的接口将其方法以一种相对直观的方式进行分组，如下: 接口 JDK还是Guava的接口 对应的Guava工具类 Collection JDK Collections2 (避免和 java.util.Collections冲突) List JDK Lists Set JDK Sets SortedSet JDK Sets Map JDK Maps SortedMap JDK Maps Queue JDK Queues Multiset Guava Multisets Multimap Guava Multimaps BiMap Guava Maps Table Guava Tables 静态构造方式JDK7之前，构造新的泛型集合需要讨厌的代码重复: List&lt;TypeThatsTooLongForItsOwnGood&gt; list = new ArrayList&lt;TypeThatsTooLongForItsOwnGood&gt;(); Guava则借助于泛型推断来决定右侧类型： List&lt;TypeThatsTooLongForItsOwnGood&gt; list = Lists.newArrayList(); Map&lt;KeyType, LongishValueType&gt; map = Maps.newLinkedHashMap(); JDK7的菱形操作符也去除了右侧类型： List&lt;TypeThatsTooLongForItsOwnGood&gt; list = new ArrayList&lt;&gt;(); 但是guava优化的更好，使用工厂模式，可以很方便的初始化集合。 Set&lt;Type&gt; copySet = Sets.newHashSet(elements); List&lt;String&gt; theseElements = Lists.newArrayList(&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;); 此外，可以根据工厂方法的名称来提高初始化集合到指定大小的可读性： List&lt;Type&gt; exactly100 = Lists.newArrayListWithCapacity(100); List&lt;Type&gt; approx100 = Lists.newArrayListWithExpectedSize(100); Set&lt;Type&gt; approx100Set = Sets.newHashSetWithExpectedSize(100); 注意: Guava自己的新集合类型没有暴露原始构造器或初始化工具方法。相反，Guava暴露了静态工厂方法，如： Multiset&lt;String&gt; multiset = HashMultiset.create(); IterablesGuava的工具方法总是接受Iterable而不是Collection，这是因为遇到一个不是存在在内存中的“集合”是很常见的，如从数据库，从数据中心；如果没有抓取到所有的元素，是不支持如size方法的。 因此，你希望的支持所有Collections的许多操作都可以在Iterables中找到。此外，大多数Iterables的方法在Iterables中有访问原始iterator的对应版本。 Iterables中的绝大多数方法都是很简便的: 只在有绝对需要的时候才增强底层迭代。返回Iterables的方法返回的是简单计算的视图，而不是内存中显示构造的新集合。 Guava12中，Iterables通过FlumentIterable支持，对大多数操作进行流式语法包装。 常用方法 方法 描述 等同于 concat(Iterable&lt;Iterable&gt;) 返回几个Iterables对象的原始级联视图 concat(Iterable…) frequency(Iterable, Object) 返回指定object在Iterable中出现的次数 Collections.frequency(Collection, Object); 参考Multiset partition(Iterable, int) 把Iterable分割为每块含有指定的数目，并返回不可修改的视图 Lists.partition(List, int), paddedPartition(Iterable, int) getFirst(Iterable, T default) 返回Iterable的第一个元素，若为空返回指定默认元素. Iterable.iterator().next() FluentIterable.first() getLast(Iterable) 返回iterable的最后元素，或者当为空时快速失败 getLast(Iterable, T default) FluentIterable.last() elementsEqual(Iterable, Iterable) 当Iterables相同的顺序上拥有相同的元素才返回true List.equals(Object) unmodifiableIterable(Iterable) 返回iterable的不可修改视图 Collections.unmodifiableCollection(Collection) limit(Iterable, int) 返回元素个数最多为指定数字的Iterable FluentIterable.limit(int) getOnlyElement(Iterable) 返回Iterable中的仅有的一个元素，若Iterable为空或者含有多个元素则快速失败。 getOnlyElement(Iterable, T default) Iterable&lt;Integer&gt; concatenated = Iterables.concat( Ints.asList(1, 2, 3), Ints.asList(4, 5, 6)); // concatenated has elements 1, 2, 3, 4, 5, 6 String lastAdded = Iterables.getLast(myLinkedHashSet); String theElement = Iterables.getOnlyElement(thisSetIsDefinitelyASingleton); // if this set isn&apos;t a singleton, something is wrong! Iterables类似Collection的方法通常，Collections天然支持如下这些操作，但是Iterables不是这样。这些操作当参数实际上是Collection时，每个都都代表了对应的集合接口方法。如，如果Iterables.size传入的参数实际上是一个Collection，方法内部调用Collection.size替代而不是遍历Iterator。 方法 类似集合方法 FluentIterable等价方法 addAll(Collection addTo, Iterable toAdd) Collection.addAll(Collection) contains(Iterable, Object) Collection.contains(Object) FluentIterable.contains(Object) removeAll(Iterable removeFrom, Collection toRemove) Collection.removeAll(Collection) retainAll(Iterable removeFrom, Collection toRetain) Collection.retainAll(Collection) size(Iterable) Collection.size() FluentIterable.size() toArray(Iterable, Class) Collection.toArray(T[]) FluentIterable.toArray(Class) isEmpty(Iterable) Collection.isEmpty() FluentIterable.isEmpty() get(Iterable, int) List.get(int) FluentIterable.get(int) toString(Iterable) Collection.toString() FluentIterable.toString() FluentIterableFluentIterable也有几个拷贝到不可变集合的简洁的方法: ImmutableSet toImmutableSet()ImmutableSortedSet toImmutableSortedSet(Comparator) Lists除了静态构造方法和函数式编程方法，Lists提供了很多实用的工具方法。 方法 描述 partition(List, int) 返回一个list视图，将原List分为指定大小的块 reverse(List) 返回指定List的反转（倒序）视图，若果list不可变，请使用 ImmutableList.reverse() List&lt;Integer&gt; countUp = Ints.asList(1, 2, 3, 4, 5); List&lt;Integer&gt; countDown = Lists.reverse(theList); // {5, 4, 3, 2, 1} List&lt;List&lt;Integer&gt;&gt; parts = Lists.partition(countUp, 2); // {{1, 2}, {3, 4}, {5}} SetsSet理论上的操作We provide a number of standard set-theoretic operations, implemented as views over the argument sets. These return a SetView, which can be used:Guava支持set理论上的操作，均返回SetView，其支持： 直接作为一个Set，因为SetView实现了Set接口 拷贝到另一个不可变的集合通过copyInto(set) 通过immutableCopy()得到一个不可变的拷贝 方法 union(Set, Set) intersection(Set, Set) difference(Set, Set) symmetricDifference(Set, Set) 如： Set&lt;String&gt; wordsWithPrimeLength = ImmutableSet.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;); Set&lt;String&gt; primes = ImmutableSet.of(&quot;two&quot;, &quot;three&quot;, &quot;five&quot;, &quot;seven&quot;); SetView&lt;String&gt; intersection = Sets.intersection(primes, wordsWithPrimeLength); // contains &quot;two&quot;, &quot;three&quot;, &quot;seven&quot; // 可以直接使用intersection作为Set，但是如果使用很多次则拷贝更高效 return intersection.immutableCopy(); 其他Set工具方法 方法 描述 参照 cartesianProduct(List) 笛卡尔乘积，返回从每个Set选取的每个元素可能组成的list cartesianProduct(Set…) powerSet(Set) 返回指定set的子set的set集合 Set&lt;String&gt; animals = ImmutableSet.of(&quot;gerbil&quot;, &quot;hamster&quot;); Set&lt;String&gt; fruits = ImmutableSet.of(&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;); Set&lt;List&lt;String&gt;&gt; product = Sets.cartesianProduct(animals, fruits); // {{\"gerbil\", \"apple\"}, {\"gerbil\", \"orange\"}, {\"gerbil\", \"banana\"}, // {\"hamster\", \"apple\"}, {\"hamster\", \"orange\"}, {\"hamster\", \"banana\"}} Set&lt;Set&lt;String&gt;&gt; animalSets = Sets.powerSet(animals); // {{}, {\"gerbil\"}, {\"hamster\"}, {\"gerbil\", \"hamster\"}} MapsuniqueIndex方法Maps.uniqueIndex(Iterable, Function) 解决的是拥有一组对象，每个对象的某个属性是唯一的，我们想通过这个唯一的属性来找到这个对象。 如我们有一组string，每个string长度不一样，想通过指定的长度来找到某个对象： ImmutableMap&lt;Integer, String&gt; stringsByIndex = Maps.uniqueIndex(strings, new Function&lt;String, Integer&gt; () { public Integer apply(String string) { return string.length(); } }); difference方法Maps.difference(Map, Map)比较的是2个map的所有不同点，返回一个MapDifference对象: entriesInCommon() 在2个map里都有的entry，key和values都相等。 entriesDiffering() key相同，但是有不同的values，可以通过MapDifference.ValueDifference来得到左边和右边的values entriesOnlyOnLeft() key在左边的map里存在但是在右边的map里没有 entriesOnlyOnRight() key在右边的map存在，左边没有 Map&lt;String, Integer&gt; left = ImmutableMap.of(“a”, 1, “b”, 2, “c”, 3); Map&lt;String, Integer&gt; right = ImmutableMap.of(“b”, 2, “c”, 4, “d”, 5); MapDifference&lt;String, Integer&gt; diff = Maps.difference(left, right); diff.entriesInCommon(); // {“b” =&gt; 2} diff.entriesDiffering(); // {“c” =&gt; (3, 4)} diff.entriesOnlyOnLeft(); // {“a” =&gt; 1} diff.entriesOnlyOnRight(); // {“d” =&gt; 5} BiMap的工具方法The Guava针对BiMap的工具方法在Maps里，因为BiMap也是一个Map BiMap utility Corresponding Map utility synchronizedBiMap(BiMap) Collections.synchronizedMap(Map) unmodifiableBiMap(BiMap) Collections.unmodifiableMap(Map) Multisets标准的集合操作，如containsAll忽略了multiset中元素出现的次数，只关心元素是否在multiset中存在与否。Multisets则提供了许多重视元素多样性的操作： 方法 描述 和Collection方法的区别 containsOccurrences(Multiset sup, Multiset sub) 如果sub.count(o)&lt;=super.count(o)对于所有的o成立，则返回true，否则false Collection.containsAll忽略了出现次数，仅仅测试元素是否被包含 removeOccurrences(Multiset removeFrom, Multiset toRemove) 移除removeFrom中的一次出现针对toRemove元素的每一次出现 Collection.removeAll移除了所有元素的所有出现次数，虽然toremove中仅仅出现一次 retainOccurrences(Multiset removeFrom, Multiset toRetain) 确保对于所有的o，removeFrom.count(o) &lt;= toReatin.count(o) Collection.retainAll保留了所有元素的所有出现次数，虽然toReatin中仅仅出现一次。 intersection(Multiset, Multiset) 返回2个multisets的交集视图，retainOccurrences的一种非破坏性方法 Multiset&lt;String&gt; multiset1 = HashMultiset.create(); multiset1.add(&quot;a&quot;, 2); Multiset&lt;String&gt; multiset2 = HashMultiset.create(); multiset2.add(&quot;a&quot;, 5); multiset1.containsAll(multiset2); // returns true: all unique elements are contained, // even though multiset1.count(&quot;a&quot;) == 2 &lt; multiset2.count(&quot;a&quot;) == 5 Multisets.containsOccurrences(multiset1, multiset2); // returns false multiset2.removeOccurrences(multiset1); // multiset2 now contains 3 occurrences of &quot;a&quot; multiset2.removeAll(multiset1); // removes all occurrences of &quot;a&quot; from multiset2, even though multiset1.count(&quot;a&quot;) == 2 multiset2.isEmpty(); // returns true 其他Multisets中的工具方法包括： 方法 说明 copyHighestCountFirst(Multiset) 返回出现频次倒序的Multiset的不可变拷贝 unmodifiableMultiset(Multiset) 返回Multiset的不可变视图 unmodifiableSortedMultiset(SortedMultiset) 返回排序Multiset的不可变视图 Multiset&lt;String&gt; multiset = HashMultiset.create(); multiset.add(&quot;a&quot;, 3); multiset.add(&quot;b&quot;, 5); multiset.add(&quot;c&quot;, 1); ImmutableMultiset&lt;String&gt; highestCountFirst = Multisets.copyHighestCountFirst(multiset); // highestCountFirst, 类似它的entrySet和elementSet, 以顺序{&quot;b&quot;, &quot;a&quot;, &quot;c&quot;}遍历元素 Multimapsindex对比Maps.uniqueIndex, Multimaps.index(Iterable, Function)解决的是当你想要找到某个属性上相同的所有对象时，也有可能是唯一的单独对象.假如想通过长度来进行分组： ImmutableSet digits = ImmutableSet.of(“zero”, “one”, “two”, “three”, “four”, “five”, “six”, “seven”, “eight”, “nine”); Function&lt;String, Integer&gt; lengthFunction = new Function&lt;String, Integer&gt;() { public Integer apply(String string) { return string.length(); } }; ImmutableListMultimap&lt;Integer, String&gt; digitsByLength = Multimaps.index(digits, lengthFunction); `/* * digitsByLength maps: * 3 =&gt; {&quot;one&quot;, &quot;two&quot;, &quot;six&quot;} * 4 =&gt; {&quot;zero&quot;, &quot;four&quot;, &quot;five&quot;, &quot;nine&quot;} * 5 =&gt; {&quot;three&quot;, &quot;seven&quot;, &quot;eight&quot;} */` invertFrom由于Multimap可以映射许多key到某个value，以及一个key到多个values，所有反转一个multimap会很有用。Guava提供invertFrom(Multimap toInvert, Multimap dest)来实现该功能。 NOTE: 如果使用ImmutableMultimap，则考虑使用ImmutableMultimap.inverse()替换. ArrayListMultimap&lt;String, Integer&gt; multimap = ArrayListMultimap.create(); multimap.putAll(&quot;b&quot;, Ints.asList(2, 4, 6)); multimap.putAll(&quot;a&quot;, Ints.asList(4, 2, 1)); multimap.putAll(&quot;c&quot;, Ints.asList(2, 5, 3)); TreeMultimap&lt;Integer, String&gt; inverse = Multimaps.invertFrom(multimap, TreeMultimap.&lt;String, Integer&gt; create()); // 注意我们自己选择实现，所有如果用TreeMultimap会得到如下有序的结果： `/* * inverse maps: * 1 =&gt; {&quot;a&quot;} * 2 =&gt; {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;} * 3 =&gt; {&quot;c&quot;} * 4 =&gt; {&quot;a&quot;, &quot;b&quot;} * 5 =&gt; {&quot;c&quot;} * 6 =&gt; {&quot;b&quot;} */` forMap方法假如想对一个Map使用Multimap的方法该怎么办？forMap(map)视图将一个Map当做SetMultiMap。这会很有用，如，和Multimaps.invertFrom结合使用： Map&lt;String, Integer&gt; map = ImmutableMap.of(&quot;a&quot;, 1, &quot;b&quot;, 1, &quot;c&quot;, 2); SetMultimap&lt;String, Integer&gt; multimap = Multimaps.forMap(map); // multimap maps [&quot;a&quot; =&gt; {1}, &quot;b&quot; =&gt; {1}, &quot;c&quot; =&gt; {2}] Multimap&lt;Integer, String&gt; inverse = Multimaps.invertFrom(multimap, HashMultimap.&lt;Integer, String&gt; create()); // inverse maps [1 =&gt; {&quot;a&quot;, &quot;b&quot;}, 2 =&gt; {&quot;c&quot;}] Wrappers包装Tables与Multimaps.newXXXMultimap(Map, Supplier)工具方法类似， Tables.newCustomTable(Map, Supplier)允许你指定一个你喜欢的row或者column map的Table实现。 // use LinkedHashMaps instead of HashMaps Table&lt;String, Character, Integer&gt; table = Tables.newCustomTable( Maps.&lt;String, Map&lt;Character, Integer&gt;&gt;newLinkedHashMap(), new Supplier&lt;Map&lt;Character, Integer&gt;&gt; () { public Map&lt;Character, Integer&gt; get() { return Maps.newLinkedHashMap(); } }); transpose变换The transpose(Table&lt;R, C, V&gt;) 方法允许你将Table&lt;R, C, V&gt;变换成Table&lt;C, R, V&gt;. Wrappers大多数情形使用ImmutableTable","categories":[{"name":"译","slug":"译","permalink":"http://zhangxiangnan.com/categories/译/"},{"name":"guava","slug":"译/guava","permalink":"http://zhangxiangnan.com/categories/译/guava/"}],"tags":[{"name":"guava","slug":"guava","permalink":"http://zhangxiangnan.com/tags/guava/"},{"name":"CollectionUtilities","slug":"CollectionUtilities","permalink":"http://zhangxiangnan.com/tags/CollectionUtilities/"}]},{"title":"guava的新集合类型","slug":"guava/collections/guava的新集合类型","date":"2016-10-21T05:20:15.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2016/10/21/guava/collections/guava的新集合类型/","link":"","permalink":"http://zhangxiangnan.com/2016/10/21/guava/collections/guava的新集合类型/","excerpt":"guava的新集合类型Multiset、Multimap、BiMap、Table、ClassToInstanceMap、RangeSet","text":"guava的新集合类型Multiset、Multimap、BiMap、Table、ClassToInstanceMap、RangeSetGuava介绍了许多jdk中没有的但是很有用处的新集合类型，这些新集合类型和JDK集合框架和平共处，并且没有硬塞进任何东西到JDK集合抽象类中。一般来说，Guava的集合实现严格遵循了JDK接口契约。 Multiset传统的JAVA惯例手法来统计一文档中的单词出现频率，类似如下： Map&lt;String, Integer&gt; counts = new HashMap&lt;String, Integer&gt;(); for (String word : words) { Integer count = counts.get(word); if (count == null) { counts.put(word, 1); } else { counts.put(word, count + 1); } } 这种方式笨拙，容易出错，且不支持收集各种有用的统计信息，如单词总数，而Guava做的更好。Guava提供一个新集合类型，Multiset，支持元素的多次添加，数学中的multiset定义为元素可以出现不止一次的set。在multiset中，类似sets和tuples，元素是无序的，如multisets {a, a, b} 和 {a, b, a} 是equal的。 有2种方式理解这个概念： 类似一个没元素顺序的约束的ArrayList 类似一个Map&lt;E, Integer&gt;,key、value分别表示元素和元素出现的次数 Guava的Multiset API结合了这2种方式，如下： 当以正常集合对待它，Multiset表现的更像是一个无序的ArrayList： 调用add(E),则该元素出现的次数加1. Multiset的iterator()方法迭代每一个元素的每一次出现。 size()方法是所有元素的所有出现次数的总和。 额外的query操作，及性能特性，比较像一个Map&lt;E, Integer&gt;. count(Object)方法返回指定元素的出现次数。HashMultiset的count方法效率是O(1)，TreeMultiset的count方法效率是O(log n)等。 entrySet() 类似Map的entrySet。 elementSet()返回multiset的一个去重的元素集合Set&lt;E&gt;，类似于Map的keySet() 针对不重复的元素来说，Multiset实现类内存消耗（空间复杂度）随着不重复元素的数目线性增长,即重复存储相同对象。 尤其需要注意，Multiset是和JDK集合Collection的接口规范完全一致的，除了JDK自身的早期版本的极少见情形 – 特别的，TreeMultiset，类似TreeSet，使用comparison来比较是否相等，而不是Object的equals方法. 特别地，Multiset.addAll(Collection)在集合中的每个元素每出现一次，该元素的出现次数加一，该方式比上面的使用Map+for循环更简便。 其他方法说明如下： 方法 描述 count(E) 对添加到multiset的元素出现次数进行计数 elementSet() 返回Multiset的去重元素的集合(一个Set&lt;E&gt;) entrySet() 类似于Map.entrySet(),返回Set&lt;Multiset.Entry&lt;E&gt;&gt;，一个包含支持getElement()和getCount()方法的entries的set集合 add(E, int) 给指定元素添加指定数目的出现次数 remove(E, int) 移除指定元素的指定数目的出现次数 setCount(E, int) 设置指定元素的出现次数为非负值 size() 返回Multiset中所有元素的总共的出现次数和。 Multiset不是一个Map注意Multiset不是一个Map&lt;E, Integer&gt;，尽管Multiset实现有这部分的功能。Multiset是一个真正的集合类型， 符合所有的相关的接口协议，其他值得注意的区别如下： 一个Multiset的元素只能有正数的count计数，不能是负数。计数0不认为在multiset中，在elementSet()、entrySet视图中计数为0的元素会被过滤。 multiset.size() 返回集合的大小，就是集合中所有元素的计数的总和。如果想要得到去重后元素的数目（不重复元素的数目），使用elementSet().size()得到。(所以，例如，add(E)方法会使multiset.size()的数目加一) multiset.iterator() 会遍历每一个元素的每一次出现，所以迭代的次数等于multiset.size() Multiset&lt;E&gt; 支持添加元素，移除元素，或者直接设置元素的计数count。setCount(elem, 0)等价于移除该元素的所有次数的出现。 multiset.count(elem) 对于不在multiset中的元素始终返回0 实现类Guava提供许多Multiset的实现，大体上对应于JDK的map实现类。 Map Corresponding Multiset Supports null elements HashMap HashMultiset Yes TreeMap TreeMultiset Yes (if the comparator does) LinkedHashMap LinkedHashMultiset Yes ConcurrentHashMap ConcurrentHashMultiset No ImmutableMap ImmutableMultiset No SortedMultisetSortedMultisetSortedMultiset是Multiset接口的一个变种，支持高效地获取指定范围的子multisets。例如你可以使用latencies.subMultiset(0, BoundType.OPEN, 100, BoundType.OPEN).size()来获取你的网站100ms下的延迟的请求的子集，然后和latecies.size()比较来获取百分比。 TreeMultiset实现了SortedMultiset接口。ImmutableSortedMultiset目前正在测试GWT的兼容性。 Multimap每一个有经验的java程序员很可能自己实现了Map&lt;K, List&lt;V&gt;&gt;或者Map&lt;K, Set&lt;V&gt;&gt;，或者直接使用那种笨拙的结构。Guava的Multimap框架使处理从keys到多个值得映射关系变得简单。一个Multimap是一个普遍的方式来关联keys和任意多values。 从概念上有2种方式来理解Multimap：单个key到单个value的映射集合： a -&gt; 1 a -&gt; 2 a -&gt; 4 b -&gt; 3 c -&gt; 5 或者是唯一的单个key到values集合的映射关系： a -&gt; [1, 2, 4] b -&gt; [3] c -&gt; [5] 一般来说, Multimap接口是理解这种观念最好的视图，但是也允许你使用asMap()以另一种方式来看，asMap()返回Map&lt;K, Collection&lt;V&gt;&gt;。最重要的是， 不会出现一个key对应一个空集合的情况：一个key要么映射到至少一个value，要么在Multimap中该key不存在。如果你想区分key存在但是没对应的values和key就不存在这2种情况，更适合的数据结构很可能是Graph图（支持孤立点）。 我们很少直接使用Multimap接口，更多的是，我们会使用ListMultimap或者SetMultimap，相应地keys映射到List和Set。 Modifying 修改APIMultimap.get(key)返回和给定key相关联的values视图，即时目前什么也没有。对于ListMultiMap返回一个list，SetMultimap返回一个set。 修改操作直接对底层的Multimap进行写。如： Set&lt;Person&gt; aliceChildren = childrenMultimap.get(alice); aliceChildren.clear(); aliceChildren.add(bob); aliceChildren.add(carol); 对底层的MultiMap直接进行写。 其他修改multimap的方式（更直接）包括： 方法 描述 等同于 put(K, V) 添加key到value的映射 multimap.get(key).add(value) putAll(K, Iterable&lt;V&gt;) 依次添加key到每一个value的映射 Iterables.addAll(multimap.get(key), values) remove(K, V) 移除key到value的映射，若multimap改变了则返回true，否则false multimap.get(key).remove(value) removeAll(K) 移除所有与key映射的所有value，返回的集合可以修改，但是修改它不会影响multimap (返回适合的集合类型) multimap.get(key).clear() replaceValues(K, Iterable&lt;V&gt;) 清空key到所有value的映射，然后设置key到每个给定value的映射。返回被清空的key关联的vlaues集合 multimap.get(key).clear(); Iterables.addAll(multimap.get(key), values) views视图MultiMap支持一系列强大的视图： asMap方法将所有的Multimap&lt;K,V&gt;当做一个Map&lt;K,Collection&gt;&gt;，其返回值支持remove、并且对返回集合的改变会影响到multimap，但是其不支持put或者putall。更关键的是，当你想要对于不存在的key返回null时你可以使用asMap().get(key)，而不是返回一个干净的空集合。(你应当强转asMap.get(key)的返回值到合适的集合类型– 对应SetMultiMap的是set，ListMultiMap的List – 但是JDK的类型系统不允许ListMultiMap返回Map&lt;K, List&lt;V&gt;&gt;) entries方法返回MultiMap所有的entries为一个Collection&lt;Map.Entry&lt;K, V&gt;&gt;（对SetMultiMap来说，Collection实际上是个Set) keySet将MultiMap中所有的key去重，返回一个set。 keys方法将MultiMap中的所有keys看成一个MultiSet，并且和key相关联的values有着相同的多样性。 元素可以从MultiSet移除，但是不能添加；改变会导致原MultiMap改变。 values()方法返回MultiMap里所有的values为一个多重集的Collection&lt;V&gt;，所有的value都在这一个Collection。类似于Iterables.concat(multimap.asMap.values()) Multimap不仅仅是mapA Multimap&lt;K, V&gt; 不仅仅是一个Map&lt;K, Colleciton&lt;V&gt;&gt;，尽管这样的一个map可能被Multimap的某个实现使用，显著区别如下： Multimap.get(key) 始终返回一个非null的，可能的空集合. 这并不意味着multimap花费了任何内存关联那个key，相反，返回的集合是一个允许你添加key映射的视图。 如果更倾向于类似Map的行为，如对于multimap中不存在的key返回null，可以使用asMap()视图来得到一个Map&lt;K,Collection&lt;V&gt;&gt;。（或者，从ListMultiMap得到一个Map&lt;K,List&lt;v&gt;&gt;，使用静态Multimaps.asMap()方法，类似方法适用于SetMultimap、SetMultimap、SortedSetMultimap) Multimap.containsKey(key)仅仅当有任何元素和key相关联时才返回true。特别地，如果一个k以前在multimap存在映射关系，但是后来移除映射关系了，该方法返回false Multimap.entries()返回multimap中的所有key的所有entries。如果想要得到所有key-collection entires，使用asMap.entrySet(). Multimap.size()返回MultiMap中所有的entries数目，不是对key去重后的数目。使用 Multimap.keySet().size() 可以得到去重后的key数目 实现类Multimap提供很多实现，可以在大多数想使用Map&lt;K, Colleciton&lt;V&gt;&gt;的场合使用。 实现 Key行为类似 Values行为类似 ArrayListMultimap HashMap ArrayList，同key对应values有顺序可重复 HashMultimap HashMap HashSet,同key对应values不可重复 LinkedListMultimap LinkedHashMap LinkedList 同key对应value有顺序可重复 LinkedHashMultimap LinkedHashMap LinkedHashSet 同key对应value有顺序不重复 TreeMultimap TreeMap TreeSet，同key对应的value有顺序 ImmutableListMultimap ImmutableMap ImmutableList ImmutableSetMultimap ImmutableMap ImmutableSet 每一个实现，除了不可变的那些，都支持key和value为null。 LinkedListMultimap.entries()，对于不重复的key value保持了迭代时的顺序。 LinkedHashMultimap，保持了映射项entries的插入顺序，包括键keys的插入顺序、和任意一个key关联的values所有值的插入顺序。 要知道以上的所有实现中并不是所有的实现都通过Map&lt;K, Collection&lt;V&gt;&gt;（特别的，几个MultiMap实现使用了自定义hash表来最小化开销） 如果你想要更多自定义，使用MultiMaps.newMultimap(Map, Supplier&lt;Collection)或者list、set自定义实现来支撑自定义multimap。 BiMap 双向Map传统映射values到key的方式是维护2个独立的map，保持他们同步，但是这种方式当一个value已经在map里存在时令人极度困惑且感觉像是bug。如： Map&lt;String, Integer&gt; nameToId = Maps.newHashMap(); Map&lt;Integer, String&gt; idToName = Maps.newHashMap(); nameToId.put(&quot;Bob&quot;, 42); idToName.put(42, &quot;Bob&quot;); // 如果“Bob”或42已经存在，当我们刚好又忘记保持他们同步的时候，就会发生奇怪的错误。 A BiMap&lt;K, V&gt; 是一个Map&lt;K,V&gt;： 允许你使用inverse()方法来得到反转视图BiMap&lt;V,K&gt; 确保values是不重复的，使values类似一个Set 所有，BiMap的特点是key、value都不能重复。若尝试添加一个key到已经存在的value映射会报参数异常。若想删除预先存在的entry（指定的value），则使用BiMap.forcePut(key, value)。 public static void main(String[] args) { BiMap&lt;String, String&gt; biMap = HashBiMap.create(); biMap.put(&quot;1&quot;, &quot;2&quot;); biMap.put(&quot;2&quot;, &quot;2&quot;); System.out.println(biMap); } #报参数异常 public static void main(String[] args) { BiMap&lt;String, String&gt; biMap = HashBiMap.create(); biMap.put(&quot;1&quot;, &quot;2&quot;); String s = biMap.inverse().get(&quot;1&quot;); System.out.println(s); System.out.println(biMap.inverse().get(&quot;2&quot;)); } #null #1 实现 Key-Value Map实现类 Value-Key Map 实现类 对应BiMap HashMap HashMap HashBiMap ImmutableMap ImmutableMap ImmutableBiMap EnumMap EnumMap EnumBiMap EnumMap HashMap EnumHashBiMap Note: BiMap的工具方法如synchronizedBiMap在Maps里实现。 表格TableTable&lt;DateOfBirth, LastName, PersonalRecord&gt; records = HashBasedTable.create(); records.put(someBirthday, &quot;Schmo&quot;, recordA); records.put(someBirthday, &quot;Doe&quot;, recordB); records.put(otherBirthday, &quot;Doe&quot;, recordC); records.row(someBirthday); // returns a Map mapping &quot;Schmo&quot; to recordA, &quot;Doe&quot; to recordB records.column(&quot;Doe&quot;); // returns a Map mapping someBirthday to recordB, otherBirthday to recordC 通常，当你想同一时间对不止一个的key检索的时候，你会想出使用类似Map&lt;FirstName, Map&lt;LastName, Person&gt;&gt;，这种方式丑陋难以使用。 Guava提供一个新的集合类型，表格Table，支持“行row”类型，和“column”列类型。表格Table支持很多种视图来让你可以使用从任何角度的数据，包括： rowMap(), 该方法将Table&lt;R,C,V&gt;视作Table&lt;R,Map&lt;C,V&gt;&gt;。类似rowKeySet返回一个Set. row(r)返回一个非null的Map&lt;C,V&gt;，对这个Map的写操作将穿透到底层Table。 相似的列方法提供如下： columnMap(), columnKeySet(), column(c). (基于column的访问稍微比基于行的访问效率低) cellSet() 返回一个Table.Cell&lt;R,C,V&gt;的set集合，Cell很像Map.Entry，但是区分row和column key。 几种Table实现如下： HashBasedTable, 底层使用HashMap&lt;R,HashMap&lt;C,V&gt;&gt;（Guava20.0使用LinkedHashMap&lt;R, LinkedHashMap&lt;C,V&gt;&gt;实现）。 TreeBasedTable,底层使用TreeMap&lt;R, TreeMap&lt;C, V&gt;&gt;. ImmutableTable,底层使用ImmutableMap&lt;R, ImmutableMap&lt;C, V&gt;&gt;. (Note: ImmutableTable针对稀疏和稠密的数据集有单独的优化实现) ArrayTable, 需要在构建的时候传递全部的row和column数据，当数据是紧密的数据时通过2维数组来提高速度、内存利用率。ArrayTable和其他实现原理有稍微不同. ClassToInstanceMap 类型到实例的映射Map有时，map的key并不都是相同的类型，可能有多个类型，你可能想映射类型到values，可以使用ClassToInstanceMap.除了扩展Map接口，ClassToInstanceMap提供方法T getInstance(Class&lt;T&gt;) 和T putInstance(Class, T)，省去了手动进行类型转换。 ClassToInstanceMap只有一个名称为B的类型参数，代表map管理的类型的上层限制，如： ClassToInstanceMap&lt;Number&gt; numberDefaults = MutableClassToInstanceMap.create(); numberDefaults.putInstance(Integer.class,Integer.valueOf(0); 严格说，ClassToInstanceMap实现了接口Map&lt;Class&lt;? extends B&gt;, B&gt; – 或者是从B的子类型class到B的映射的一个map，这会令ClassToInstanceMap的反省类型有些令人困惑，但记住B始终是map中类型的上层限制（上界）–通常，B就是Object类。 Guava提供MutableClassToInstanceMap、ImmutableClassToInstanceMap。 注意: 像其他Map&lt;Class, Object&gt;，一个ClassToInstanceMap可能包含基本类型，基本类型和对应包装类型可能对应不同的values。 RangeSetA RangeSet描述了一个不连续的、非空的范围集合，当往一个可变的RangeSet添加一个范围的时候，任何可连续的范围都被合并到一起，空范围被忽略，如下： RangeSet&lt;Integer&gt; rangeSet = TreeRangeSet.create(); rangeSet.add(Range.closed(1, 10)); // {[1, 10]} rangeSet.add(Range.closedOpen(11, 15)); // disconnected range: {[1, 10], [11, 15)} rangeSet.add(Range.closedOpen(15, 20)); // connected range; {[1, 10], [11, 20)} rangeSet.add(Range.openClosed(0, 0)); // empty range; {[1, 10], [11, 20)} rangeSet.remove(Range.open(5, 10)); // splits [1, 10]; {[1, 5], [10, 10], [11, 20)} 记住想要合并范围如Range.closed(1, 10) and Range.closedOpen(11, 15), 必须首先使用Range.canonical(DiscreteDomain)预处理范围，如使用DiscreteDomain.integers(). RangeSet&lt;Integer&gt; rangeSet = TreeRangeSet.create(); rangeSet.add(Range.closed(1, 10).canonical(DiscreteDomain.integers())); // {[1, 10]} rangeSet.add(Range.closedOpen(11, 15)); // disconnected range: {[1, 10], [11, 15)} System.out.println(rangeSet);//[[1‥15)] // canonical可以理解为规范化，效果如下： System.out.println(Range.closed(1, 10).canonical(DiscreteDomain.integers()));[1‥11) System.out.println(Range.closed(1, 10));[1‥10] 注意: RangeSet 在GWT下和JDK1.5之下都不被支持；RangeSet需要全部NavigableMap的特征在JDK1.6中。 视图RangeSet实现支持很多视图： complement(): 返回补集视图，也是一个RangeSet，它包含不连续的、非空范围. subRangeSet(Range&lt;C&gt;): 返回RangeSet和指定范围的range的交叉集合，这会返回惯例的排序的headSet、subSet、tailSet视图。 asRanges():将RangeSet视作Set&lt;Range&lt;C&gt;&gt;，可以迭代遍历。 asSet(DiscreteDomain&lt;C&gt;) (仅仅对ImmutableRangeSet而言): 将RangeSet&lt;C&gt;当做ImmutableSortedSet&lt;C&gt;看待ranges中的元素而非range自己. (这个操作如果DiscreteDomain和RangeSet同时是无穷大或无穷小时不支持) 查询除了视图，RangeSet还直接支持几种查询操作 ，最常用的： contains(C): RangeSet的最基本的方法，查询RangeSet中的任意一个range是否包含指定元素。 rangeContaining(C): 返回包含指定元素的Range，无返回null。 encloses(Range&lt;C&gt;): 测试RangeSet中的任意Range是否包围指定Range span(): 返回包围RangeSet中任意的Range的最小Range。 RangeMapRangeMap是描述不相交、非空范围到values的映射关系。不同于RangeSet，RangeMap不合并相邻映射，即使相邻的Ranges映射到相同的values。如： RangeMap&lt;Integer, String&gt; rangeMap = TreeRangeMap.create(); rangeMap.put(Range.closed(1, 10), &quot;foo&quot;); // {[1, 10] =&gt; &quot;foo&quot;} rangeMap.put(Range.open(3, 6), &quot;bar&quot;); // {[1, 3] =&gt; &quot;foo&quot;, (3, 6) =&gt; &quot;bar&quot;, [6, 10] =&gt; &quot;foo&quot;} rangeMap.put(Range.open(10, 20), &quot;foo&quot;); // {[1, 3] =&gt; &quot;foo&quot;, (3, 6) =&gt; &quot;bar&quot;, [6, 10] =&gt; &quot;foo&quot;, (10, 20) =&gt; &quot;foo&quot;} rangeMap.remove(Range.closed(5, 11)); // {[1, 3] =&gt; &quot;foo&quot;, (3, 5) =&gt; &quot;bar&quot;, (11, 20) =&gt; &quot;foo&quot;} Views RangeMap提供2中视图： asMapOfRanges(): 将RangeMap当做一个Map&lt;Range&lt;K&gt;,V&gt;，当想要迭代RangeMap时可以使用 subRangeMap(Range&lt;K&gt;) 将RangeMap和指定Range的交集当做一个RangeMap，惯例返回headMap, subMap, and tailMap.","categories":[{"name":"译","slug":"译","permalink":"http://zhangxiangnan.com/categories/译/"},{"name":"guava","slug":"译/guava","permalink":"http://zhangxiangnan.com/categories/译/guava/"}],"tags":[{"name":"guava","slug":"guava","permalink":"http://zhangxiangnan.com/tags/guava/"},{"name":"newCollectionsTypes","slug":"newCollectionsTypes","permalink":"http://zhangxiangnan.com/tags/newCollectionsTypes/"}]},{"title":"guava的不可变集合","slug":"guava/collections/guava的不可变集合","date":"2016-10-20T05:10:12.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2016/10/20/guava/collections/guava的不可变集合/","link":"","permalink":"http://zhangxiangnan.com/2016/10/20/guava/collections/guava的不可变集合/","excerpt":"guava的不可变集合讲解-Immutable*","text":"guava的不可变集合讲解-Immutable* jdk的Collections.ImmutableXXX例子package cn.zxn.guava.collections; import java.util.ArrayList; import java.util.Collections; import java.util.List; // jdk的方法修改原始集合会导致不可变集合发生变化 public class ImmutableCollectionsExplained { public static void main(String[] args) { List&lt;String&gt; originalList = new ArrayList&lt;String&gt;(); originalList.add(&quot;S&quot;); originalList.add(&quot;Q&quot;); List&lt;String&gt; unmodifiableList = Collections.unmodifiableList(originalList); System.out.println(unmodifiableList.size());// 输出2 // 原始集合新增一个item originalList.add(&quot;T&quot;); // 不可变集合的大小变化,变为3 System.out.println(unmodifiableList.size());// 输出3 } } guava例子:// 不可变set声明示例 public static final ImmutableSet&lt;String&gt; COLOR_NAMES = ImmutableSet.of( &quot;red&quot;, &quot;orange&quot;, &quot;yellow&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;purple&quot;); class Foo { final ImmutableSet&lt;Bar&gt; immutableBars; Foo(Set&lt;Bar&gt; bars) { this.immutableBars = ImmutableSet.copyOf(bars); // 保护性拷贝，使集合immutableBars不可被删除增加元素，但是可以调用元素自身的方法进行元素的修改 } } 使用不可变对象的原因不可变对象有许多好处，包括： 安全地被不受信任的类库使用 线程安全：可以在多线程中使用而不用考虑(静态条件)加锁同步 不需要支持可变性（自动扩充等机制），可以更好的节省空间、时间。所有的不可变集合实现都比对应的可变集合更能高效的使用内存。 可以当做常量使用，其会保持不变 对对象objects做不可变的拷贝使一项很好的保护性编程技巧。Guava为每一个标准的集合类型提供简单、易用及不可变的版本，包含Guava自己的集合。 JDK提供Collections.unmodifiableXXX类似的方法，但在我们看来: 笨拙且冗长：在你想做保护性拷贝的地方使用起来不方便 不安全：返回的集合仅仅在其他地方没有持有对原始集合的引用前提下才真正不可变，guava则对原始集合的操作（删除、增加）不影响不可变集合。 效率低下：内部数据结构仍然有可变集合会有的开销，包括并发修改检查，hash表中额外的空间等。 当你不想改变一个集合，或者希望一个集合保持不变，进行保护性拷贝原集合到一个不可变集合是一个不错的实践 重点：每一个Guava不可变集合实现类不能存放null值。我们做了一个彻底的对Google内部代码库调查，发现null元素仅仅在5%的情形里允许，其余95%则是若是null则会快速失败。如果你需要使用null值，考虑使用Collections.unmodifiableList及它的相关方法，可以允许null。更多细节见：here 如何使用一个InmutableXXX集合可以通过以下几种方式创建： 使用copyOf方法，例如，ImmutableSet.copyOf(set)； 使用Of方法，如，ImmutableSet.of(“a”, “b”, “c”)或者ImmutableMap.of(“a”, “1”, “b”, 2); 使用一个创建器Builder，如， public static final ImmutableSet&lt;Color&gt; GOOGLE_COLORS = ImmutableSet.&lt;Color&gt;builder() .addAll(WEBSAFE_COLORS) .add(new Color(0, 191, 255)) .build(); 除了排序集合，元素顺序在构建时被保持。如，ImmutableSet.of(“a”, “b”, “c”, “a”, “d”, “b”) 迭代输出会得到结果： “a”, “b”, “c”, “d”. 智能拷贝 有必要记住ImmutableXXX.copyOf尝试避免拷贝数据（如果这么做安全地话）– 确切的细节未指定，但是实现通常是智能的，如， ImmutableSet&lt;String&gt; foobar = ImmutableSet.of(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;); thingamajig(foobar); void thingamajig(Collection&lt;String&gt; collection) { ImmutableList&lt;String&gt; defensiveCopy = ImmutableList.copyOf(collection); ... } 以上代码中，ImmutableList.copyOf(foobar) 将足够智能仅仅返回foobar.asList()，这是ImmutableSet的一个O(1)时间复杂度的方法。 ImmutableXXX.copyOf(ImmutableCollection)通常会在符合以下条件下来尝试来避免线性时间的拷贝： 在常数时间内使用底层数据结果是可能的话：如, ImmutableSet.copyOf(ImmutableList) 不能在常数时间内完成. 不会导致内存泄漏 – 如，如果你有ImmutableList hugeList（超大list）,如果执行ImmutableList.copyOf(hugeList.subList(0, 10)), 就会执行一个显示的拷贝, 以便避免意外地持有hugeList中不必要的引用 不会改变语义 – 所以ImmutableSet.copyOf(myImmutableSortedSet) 将会执行显示的拷贝, 因为ImmutableSet使用的hashCode()和equals拥有跟ImmutableSortedSet的基于comparator的行为不同的语义。这有助于减少良好的防御性编程风格的性能开销。 asList所有的不可变集合通过asList()返回一个不可变的ImmutableList视图，所以 – 如 – 即使你有使用ImmutableSortedSet排序的数据，你也可以使用sortedSet.asList().get(k).来得到第k个最小的元素。 返回ImmutableList是普遍的 – 不总是，但是经常 – 一个常数级开销的视图，而不是执行显示拷贝。即，它比平常的List通常更智能 – 如，它底层使用更高效的contains方法。 jdk可变集合与guava不可变集合对应关系？ 接口 接口属于jdk或guava 不可变版本 Collection JDK ImmutableCollection List JDK ImmutableList Set JDK ImmutableSet SortedSet/NavigableSet JDK ImmutableSortedSet Map JDK ImmutableMap SortedMap JDK ImmutableSortedMap Multiset Guava ImmutableMultiset SortedMultiset Guava ImmutableSortedMultiset Multimap Guava ImmutableMultimap ListMultimap Guava ImmutableListMultimap SetMultimap Guava ImmutableSetMultimap BiMap Guava ImmutableBiMap ClassToInstanceMap Guava ImmutableClassToInstanceMap Table Guava ImmutableTable","categories":[{"name":"译","slug":"译","permalink":"http://zhangxiangnan.com/categories/译/"},{"name":"guava","slug":"译/guava","permalink":"http://zhangxiangnan.com/categories/译/guava/"}],"tags":[{"name":"guava","slug":"guava","permalink":"http://zhangxiangnan.com/tags/guava/"},{"name":"immutableCollections","slug":"immutableCollections","permalink":"http://zhangxiangnan.com/tags/immutableCollections/"}]},{"title":"okhttp之常见使用方法（一）","slug":"http/okhttp/okhttp之常见使用方法（一）","date":"2016-09-25T13:18:48.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2016/09/25/http/okhttp/okhttp之常见使用方法（一）/","link":"","permalink":"http://zhangxiangnan.com/2016/09/25/http/okhttp/okhttp之常见使用方法（一）/","excerpt":"常见的GET同步、异步调用示例，POST提交字符串、提交流示例。","text":"常见的GET同步、异步调用示例，POST提交字符串、提交流示例。 GET方式同步调用package cn.xiangnan.okhttpdemo; /** * Created by zhangxiangnan on 16/9/25. */ import okhttp3.Headers; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.Response; import java.io.IOException; /** * 使用GET方式同步掉调用,输出响应的header及返回内容。 * string方法适合于&lt;=1M的响应,再大的话最好用stream流方式。 */ public class SynchronousGet { private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception { Request request = new Request.Builder() .url(&quot;http://www.baidu.com&quot;)// 可以是需要下载的文件地址 .build(); Response response = null; try { response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); Headers responseHeaders = response.headers(); for (int i = 0; i &lt; responseHeaders.size(); i++) { System.out.println(responseHeaders.name(i) + &quot;: &quot; + responseHeaders.value(i)); } System.out.println(response.body().string()); } catch (Exception e) { e.printStackTrace(); } finally { if (response != null) { response.close(); } } } public static void main(String... args) throws Exception { new SynchronousGet().run(); } } GET方式异步调用package cn.xiangnan.okhttpdemo; /** * Created by zhangxiangnan on 16/9/25. */ import okhttp3.*; import java.io.IOException; /** * 异步GET调用,在一个工作线程中进行文件或者普通页面调用,当响应可读时在另一个线程中执行回调函数; * 在响应头部信息准备好后,就执行回调函数;但是读响应体可能仍然阻塞。 * Okhttp目前不提供对响应体异步分开读取。 */ public final class AsynchronousGet { private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception { Request request = new Request.Builder() .url(&quot;http://www.baidu.com&quot;) .build(); // 异步请求是通过执行入队 client.newCall(request).enqueue(new Callback() { // 失败 public void onFailure(Call call, IOException e) { e.printStackTrace(); } //正常 public void onResponse(Call call, Response response) throws IOException { ResponseBody responseBody = null; try { responseBody = response.body(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); Headers responseHeaders = response.headers(); for (int i = 0, size = responseHeaders.size(); i &lt; size; i++) { System.out.println(responseHeaders.name(i) + &quot;: &quot; + responseHeaders.value(i)); } System.out.println(responseBody.string()); } catch (Exception e) { } finally { responseBody.close(); response.close(); } } }); } public static void main(String... args) throws Exception { new AsynchronousGet().run(); } } 访问头部信息通常HTTP头部类似Map&lt;String,String&gt;工作：每一个字段有一个值或更多。但是一些头部允许多个值，如Guava的MultiMap。例如，HTTP响应体提供多个变化的headers是合法和常见的。OKHttp的API尝试优雅的处理2中情形。 当写入请求体时，使用header(name, value)来设置name和value的首次设置，如果已经存在values，values会被移除，新值会被添加。可以使用addHeader(name,value)来追加header，而不用移除已经存在的headers. 当读取响应的头部时，使用header(name)来获取最近出现的命名的value值。通常这也是仅有的一个值。如果值不存在，header(name)返回null。想要读取一个字段的所有值返回一个list，可以使用headers(name). 想要访问所有的头部，使用Headers类，支持按索引访问。 package cn.xiangnan.okhttpdemo; /** * Created by zhangxiangnan on 16/9/25. */ import java.io.IOException; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.Response; /** * 访问头部,header(name)访问最近的头部,headers(name)返回多个值 */ public final class AccessHeaders { private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception { Request request = new Request.Builder() .url(&quot;https://api.github.com/repos/square/okhttp/issues&quot;) .header(&quot;User-Agent&quot;, &quot;OkHttp Headers.java&quot;) .addHeader(&quot;Accept&quot;, &quot;application/json; q=0.5&quot;) .addHeader(&quot;Accept&quot;, &quot;application/vnd.github.v3+json&quot;) .build(); Response response = null; try { response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); System.out.println(&quot;Server: &quot; + response.header(&quot;Server&quot;)); System.out.println(&quot;Date: &quot; + response.header(&quot;Date&quot;)); System.out.println(&quot;Vary: &quot; + response.headers(&quot;Vary&quot;)); } catch (Exception e) { e.printStackTrace(); } finally { response.close(); } } public static void main(String... args) throws Exception { new AccessHeaders().run(); } } POST提交String字符串使用一个HTTP POST来发送一个请求体到一个服务，因为该API的整个请求体全部在内存里，所以最好&lt;=1m。 package cn.xiangnan.okhttpdemo; /** * Created by zhangxiangnan on 16/9/25. */ import okhttp3.*; import java.io.IOException; /** * 使用一个HTTP POST来发送一个请求体到一个服务，因为该API的整个请求体全部在内存里，所以最好&lt;=1m。 */ public final class PostString { public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;); private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception { String postBody = &quot;&quot; + &quot;Releases\\n&quot; + &quot;--------\\n&quot; + &quot;\\n&quot; + &quot; * _1.0_ May 6, 2013\\n&quot; + &quot; * _1.1_ June 15, 2013\\n&quot; + &quot; * _1.2_ August 11, 2013\\n&quot;; Request request = new Request.Builder() .url(&quot;https://api.github.com/markdown/raw&quot;) .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody)) .build(); Response response = null; try { response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); System.out.println(response.body().string()); } catch (Exception e) { e.printStackTrace(); } finally { response.body(); } } public static void main(String... args) throws Exception { new PostString().run(); } } POST提交流package cn.xiangnan.okhttpdemo; /** * Created by zhangxiangnan on 16/9/25. * POST方式提交流，请求提写入的同时产生；该例直接将流写入到okio * 的buffered sink,可以优先使用OutputStream，并从BufferedSink.outputStream()得到。 * */ import java.io.IOException; import okhttp3.MediaType; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.RequestBody; import okhttp3.Response; import okio.BufferedSink; public final class PostStreaming { public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;); private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception { RequestBody requestBody = new RequestBody() { @Override public MediaType contentType() { return MEDIA_TYPE_MARKDOWN; } @Override public void writeTo(BufferedSink sink) throws IOException { sink.writeUtf8(&quot;Numbers\\n&quot;); sink.writeUtf8(&quot;-------\\n&quot;); for (int i = 2; i &lt;= 997; i++) { sink.writeUtf8(String.format(&quot; * %s = %s\\n&quot;, i, factor(i))); } } private String factor(int n) { for (int i = 2; i &lt; n; i++) { int x = n / i; if (x * i == n) return factor(x) + &quot; × &quot; + i; } return Integer.toString(n); } }; Request request = new Request.Builder() .url(&quot;https://api.github.com/markdown/raw&quot;) .post(requestBody) .build(); Response response = null; try { response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); System.out.println(response.body().string()); } catch (Exception e) { e.printStackTrace(); } finally { response.close(); } } public static void main(String... args) throws Exception { new PostStreaming().run(); } }","categories":[{"name":"http","slug":"http","permalink":"http://zhangxiangnan.com/categories/http/"}],"tags":[{"name":"okhttp","slug":"okhttp","permalink":"http://zhangxiangnan.com/tags/okhttp/"},{"name":"http","slug":"http","permalink":"http://zhangxiangnan.com/tags/http/"},{"name":"译","slug":"译","permalink":"http://zhangxiangnan.com/tags/译/"}]},{"title":"okhttp之连接Connections","slug":"http/okhttp/okhttp之连接Connections","date":"2016-09-25T04:51:16.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2016/09/25/http/okhttp/okhttp之连接Connections/","link":"","permalink":"http://zhangxiangnan.com/2016/09/25/http/okhttp/okhttp之连接Connections/","excerpt":"连接在使用Okhttp发送请求时，尽管你仅仅提供URL，OkHttp使用三种方式来设计连接：URL、Address、和路有route。","text":"连接在使用Okhttp发送请求时，尽管你仅仅提供URL，OkHttp使用三种方式来设计连接：URL、Address、和路有route。 URLs链接URLs（如 https://github.com/square/okhttp ）是HTTP和Internet互联网的基石。为了成为一个为web上任何东西的通用的、去中心化分散的的命名方案，他们也指出了如何访问web资源。 URLs是抽象的： URLS指出调用可能是明文的（http）或者加密的（https），但没有指出哪一种加密算法应该使用，也未指定该如何验证访问者的身份或者何种的凭证应该被信任， 也未指出是否应该使用一个特定的代理服务器或者如何和代理服务器认证。 URLS也是具体的：每一个URL标示一个特定的路径（如/square/okhttp)和查询(如?=q=xx&amp;a=xx)。每一个web服务器管理许多URLS。 Addresses地址地址指定一个web服务器（如github.com），以及连接到服务器所需的静态配置：端口、Https设置、优先的网络协议（如HTTP/2或者SPDY）。 共享相同address地址的URLs可能共享相同的底层的TCP socket连接。共享一个连接对性能有重大提升：低延迟、高吞吐（因为TCP启动较慢，三次握手）以及节省用电.Okhttp使用一个自动重用HTTP/1.x连接的连接池、支持多路复用技术的HTTP/2、SPDY连接。在Okhttp中，address地址的一些字段来自URL（协议，主机，端口），剩余来自OkHttpClient。 路由Routes路由提供动态必需的动态信息来实际连接到一个web服务器。通过特定的ip地址尝试（通过DNS查询发现），使用准确的代理服务器（如果使用了一个ProxySelector），以及TLS协商的版本（针对HTTPS连接）。一个地址可能有许多路由，例如，在多数据中心的一个web服务器可能在DNS应答中返回多个ip地址。 连接当你使用Okhttp请求一个URL，如下是Okhttp请求的内部过程： 1、它使用URL和配置好的OkHttpClient来创建一个address地址，这个address地址指出了我们如何连接到web服务器。 2、它尝试在连接池中检索来获取那个地址的连接 3、若在连接池中没有找到对应连接，它选择一个路由来尝试。这通常意味着发出一个DNS请求来得到服务器的IP地址。如果必须的话，它还会选择一个TLS版本和代理服务器 4、如果是一个新路由，它通过构建一个直接socket连接、一个TLS隧道（针对一个HTTP代理上的HTTPS）、或者一个直接的TLS连接来连接。必要时它会进行TLS握手。 5、最后发送HTTP请求然后读取响应。 如果连接异常，Okhttp将再选择一个路有，再次重试。这允许Okhttp在当一个服务端的多个地址有一部分不可达时，进行恢复。这当一个连接池中的连接过时失效时，或者已经尝试的TLS版本不支持的话，也是有用处的。 一旦响应被接受，连接就会被返回到连接池，以便新的请求可以重用该连接。在一个连接不活跃一段时间后，连接将被从连接池回收。","categories":[{"name":"http","slug":"http","permalink":"http://zhangxiangnan.com/categories/http/"}],"tags":[{"name":"okhttp","slug":"okhttp","permalink":"http://zhangxiangnan.com/tags/okhttp/"},{"name":"http","slug":"http","permalink":"http://zhangxiangnan.com/tags/http/"},{"name":"译","slug":"译","permalink":"http://zhangxiangnan.com/tags/译/"},{"name":"Connections","slug":"Connections","permalink":"http://zhangxiangnan.com/tags/Connections/"}]},{"title":"okhttp之calls","slug":"http/okhttp/okhttp之calls","date":"2016-09-24T12:08:12.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2016/09/24/http/okhttp/okhttp之calls/","link":"","permalink":"http://zhangxiangnan.com/2016/09/24/http/okhttp/okhttp之calls/","excerpt":"okhttp的Calls介绍Http客户端的工作是接受请求，并返回请求的响应，理论简单，实践复杂。Okhttp如何处理的呢？","text":"okhttp的Calls介绍Http客户端的工作是接受请求，并返回请求的响应，理论简单，实践复杂。Okhttp如何处理的呢？ 请求每一个http请求包含一个url，一个方法（get或者post），以及一系列headers。请求也可能包含body请求体：一种指定内容类型的数据流。 响应响应应答请求，返回一个code（如200表示成功，404表示找不到），headers以及可选择的body响应体。 重写请求当你提供http请求给Okhttp时，你以很抽象地描述这个请求：“帮我使用这些headers来抓取这个url的内容”。为了准确性和效率考虑，Okhttp重写请求后才发送该请求。 Okhttp可能增加原始请求中却少的headers，包含内容长度Content-Length,Transfer-Encoding传输编码，User-Agent用户代理，Host主机，连接Connection，内容类型Content-Type。它会添加支持编码Accept-Encoding头为了透明的响应压缩，除非该header已经存在。如果你有cookies，Okhttp会使用你的cookies添加到cookie头。 一些请求会有一个被缓存的响应信息。当这个被缓存的响应不是最新的，Okhttp可以做一个有条件的Get来下载一个更新的响应，如果比缓存的更 新。这需要诸如If-Modified-Since及If-None-Match头部添加到请求中。 重写响应如果使用透明的压缩，Okhttp将会放弃对应的响应头部Content-Encoding和Content-Length，因为这2个头部不适合于解压缩的响应体中。 如果一个有条件的GET成功，来自网络服务端的响应和缓存中的内容将按照规范来合并。 跟踪后续请求当你请求的url被移动，web服务器将返回如302响应码来表明文档的新url地址，Okhttp将调用重定向的地址来获取最终响应。 如果响应应答说需要认证，OkHttp会询问Authenticator（如果配置了一个）来满足认证。如果authenticator认证器提供一个凭证，Okhttp将拿着凭证再一次请求。 Retrying Requests 重试请求有时连接失败：或者是一个被池化的连接过时和断开连接，或者是web服务端自己不可达。OkHttp将使用一个不同的路有（如果有一个可用路有）来重试请求。 Calls有了重写、重定向、跟踪后续请求、重试请求，你的简单的请求可能为更多请求和响应让路。Okhttp使用Call来模型化请求任务，然而许多中间的请求和响应是必须的。通常这种情况不是很多，但知道你的代码会在遇到URL重定向是自动继续跟踪请求或者兜底来请求一个备用ip地址还是很好的。 Calls以以下2种方式的一种来执行: 同步：你的请求线程阻塞直到响应可读。 异步：你在任何线程上将请求加入到队列中，当响应可读时，在另一个线程中获取回调。Calls可以在任何线程中被取消。这将将还未完成的call执行失败，那些正在写请求体或者读响应体的代码将触发IOException. 转发分派 对于同步调用calls，你使用自己创建的线程，并且有责任管理你发出的并发请求，太多并发请求连接浪费资源，对响应时间几乎没有影响。对于异步调用calls，调度器实现控制最大并发请求的策略，你可以设置每台web服务器的最大并发数（默认5），以及全局并发数（默认64）。","categories":[{"name":"http","slug":"http","permalink":"http://zhangxiangnan.com/categories/http/"}],"tags":[{"name":"okhttp","slug":"okhttp","permalink":"http://zhangxiangnan.com/tags/okhttp/"},{"name":"http","slug":"http","permalink":"http://zhangxiangnan.com/tags/http/"},{"name":"译","slug":"译","permalink":"http://zhangxiangnan.com/tags/译/"}]},{"title":"okhttp简介及使用范例","slug":"http/okhttp/okhttp的简介及使用范例","date":"2016-09-24T08:34:32.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2016/09/24/http/okhttp/okhttp的简介及使用范例/","link":"","permalink":"http://zhangxiangnan.com/2016/09/24/http/okhttp/okhttp的简介及使用范例/","excerpt":"okhttp简介Http是现代应用程序的通讯方式，我们用来交换数据和媒体。提高http的效率使我们的项目加载更快、节省带宽。okhttp客户端对请求响应做了哪些优化呢？以及简单get、post如何实现呢？","text":"okhttp简介Http是现代应用程序的通讯方式，我们用来交换数据和媒体。提高http的效率使我们的项目加载更快、节省带宽。okhttp客户端对请求响应做了哪些优化呢？以及简单get、post如何实现呢？ OkHttp是一个默认效率很高的http客户端： Http/2支持所有的对同一个host主机的请求共享同一个socket。 连接池减少链接数目（如果HTTP/2不可用） 默认GZIP压缩减少传输数据大小 缓存响应减少网络请求对于重复的请求。 OkHttp当网络出问题时做如下尝试： 它默默地恢复对于常见的连接问题。如果你的服务有多个ip地址，，OkHttp将选择一个其他可用的地址如果第一次连接请求失败的话。这对IPV6 + IPV4以及多数据中心的服务是很有必要的。OkHttp使用现代的TLS特征（SNI、ALPN）发起新连接，如果握手失败则使用TLS1.0进行兜底。 使用OkHttp很简单，它的请求响应API使用流式创建器及不变性。它同时支持同步调用及带有回调机制的异步调用。 OKHttp支持android&gt;=2.3，java版本最低1.7 Get请求示例package cn.xiangnan.okhttpdemo; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.Response; import java.io.IOException; /**get请求数据 * Created by zhangxiangnan on 16/9/24. */ public class GetDemo { OkHttpClient client = new OkHttpClient(); String doGet(String url) throws IOException { Request request = new Request.Builder() .url(url) .build(); Response response = client.newCall(request).execute(); return response.body().string(); } public static void main(String[] args) throws IOException { GetDemo demo = new GetDemo(); String response = demo.doGet(&quot;https://raw.github.com/square/okhttp/master/README.md&quot;); System.out.println(response); } } POST请求示例（提交json数据）package cn.xiangnan.okhttpdemo; import okhttp3.*; import java.io.IOException; /**post请求发送json数据 * Created by zhangxiangnan on 16/9/24. */ public class PostDemo { public static final MediaType JSON = MediaType.parse(&quot;application/json; charset=utf-8&quot;); OkHttpClient client = new OkHttpClient(); String post(String url, String json) throws IOException { RequestBody body = RequestBody.create(JSON, json); Request request = new Request.Builder() .url(url) .post(body) .build(); Response response = client.newCall(request).execute(); return response.body().string(); } String bowlingJson(String player1, String player2) { return &quot;{&apos;winCondition&apos;:&apos;HIGH_SCORE&apos;,&quot; + &quot;&apos;name&apos;:&apos;Bowling&apos;,&quot; + &quot;&apos;round&apos;:4,&quot; + &quot;&apos;lastSaved&apos;:1367702411696,&quot; + &quot;&apos;dateStarted&apos;:1367702378785,&quot; + &quot;&apos;players&apos;:[&quot; + &quot;{&apos;name&apos;:&apos;&quot; + player1 + &quot;&apos;,&apos;history&apos;:[10,8,6,7,8],&apos;color&apos;:-13388315,&apos;total&apos;:39},&quot; + &quot;{&apos;name&apos;:&apos;&quot; + player2 + &quot;&apos;,&apos;history&apos;:[6,10,5,10,10],&apos;color&apos;:-48060,&apos;total&apos;:41}&quot; + &quot;]}&quot;; } public static void main(String[] args) throws IOException { PostDemo example = new PostDemo(); String json = example.bowlingJson(&quot;Jesse&quot;, &quot;Jake&quot;); String response = example.post(&quot;http://www.roundsapp.com/post&quot;, json); System.out.println(response); } }","categories":[{"name":"http","slug":"http","permalink":"http://zhangxiangnan.com/categories/http/"}],"tags":[{"name":"okhttp","slug":"okhttp","permalink":"http://zhangxiangnan.com/tags/okhttp/"},{"name":"http","slug":"http","permalink":"http://zhangxiangnan.com/tags/http/"},{"name":"译","slug":"译","permalink":"http://zhangxiangnan.com/tags/译/"}]},{"title":"thrift的接口描述语言IDL","slug":"thrift/thrift的接口描述语言IDL","date":"2016-08-01T02:29:05.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2016/08/01/thrift/thrift的接口描述语言IDL/","link":"","permalink":"http://zhangxiangnan.com/2016/08/01/thrift/thrift的接口描述语言IDL/","excerpt":"本文介绍thrift的接口描述语言IDL。","text":"本文介绍thrift的接口描述语言IDL。 简介thrfit的接口描述语言IDL（interface description language）允许使用thrfit类型。thrift编译器处理thrift的IDL文件来根据不同的目标语言，生成对应的代码，以便支持IDL文件中定义的结构体和服务。 IDL结构描述Document每个thrift的document包含0个或者多个headers，后面跟着0个或多个其他定义： [1] Document ::= Header Definition Header一个header是一个thrift的include、一个c++的include、或者一个namespace的定义： [2] Header ::= Include | CppInclude | Namespace Thrift Include该种include使来自另一个文件的所有符号标记对该文件可见（使用前缀），并且添加对应的include语句到该thrift文档所生成的代码中。 [3] Include ::= ‘include’ Literal C++ Include该include添加一个自定义的c++ include到thrift文档对应c++代码生成器生成的代码里。 [4] CppInclude ::= ‘cpp_include’ Literal Namespace一个namespace定义了哪一个namespace、包、模块等。thrift文件定义的类型将在目标语言中声明定义。namespacescope定义了该namespace所适用于哪种语言。范围“ *”表示该namespace适用于所有语言。 [5] Namespace ::= ( ‘namespace’ ( NamespaceScope Identifier ) | ( ‘smalltalk.category’ STIdentifier ) | ( ‘smalltalk.prefix’ Identifier ) ) | ( ‘php_namespace’ Literal ) | ( ‘xsd_namespace’ Literal ) [6] NamespaceScope ::= ‘*‘ | ‘cpp’ | ‘java’ | ‘py’ | ‘perl’ | ‘rb’ | ‘cocoa’ | ‘csharp’ N.B.:smalltalk有2种不同的命名指令；php_namespace与xsd_namespace不建议用。 定义Definition[7] Definition ::= Const | Typedef | Enum | Senum | Struct | Union | Exception | Service Const[8] Const ::= ‘const’ FieldType Identifier ‘=’ ConstValue ListSeparator? Typedef类型定义为一个类型创建别名：[9] Typedef ::= ‘typedef’ DefinitionType Identifier Enum一个枚举创建一个枚举类型，带有命名的值。如果没提供常量值，则第一个元素值要么是0，或者比先前的子序列的数字都大。任何常量值必须非负。","categories":[{"name":"thrift","slug":"thrift","permalink":"http://zhangxiangnan.com/categories/thrift/"}],"tags":[{"name":"thrift","slug":"thrift","permalink":"http://zhangxiangnan.com/tags/thrift/"},{"name":"thrift type","slug":"thrift-type","permalink":"http://zhangxiangnan.com/tags/thrift-type/"}]},{"title":"thrift的数据类型","slug":"thrift/thrift的数据类型","date":"2016-07-31T10:01:47.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2016/07/31/thrift/thrift的数据类型/","link":"","permalink":"http://zhangxiangnan.com/2016/07/31/thrift/thrift的数据类型/","excerpt":"本文介绍thrift的数据类型。","text":"本文介绍thrift的数据类型。 简介apache的thrift框架，facebook开发，用于可扩展的跨语言的服务开发，把软件栈和代码生成引擎结合，来构建高效的、在C++、JAVA、Python、PHP、Ruby、Erlang、Perl、Haskell、C#、Cocoa、JavaScript、Node.js、SmallTalk、Ocami、Dephi及他语言之间无缝的服务。 thrfit的数据类型thrift的类型系统目的在于允许开发人员尽可能使用本地类型，不用管他们使用的是何种编程语言。thrift的IDL提供类型的描述，用来生成每一个目标语言对应的代码。 基本类型简单类型以简单明了作为目标，而不是提供大量简单类型，集中在所有语言共有的关键类型上。 bool：一个布尔值，true或者false，对应java的boolean byte：一个8字节的有符号整数，对应java的byte i16：16位的有符号整数，对应java的short i32：32位有符号整数，对应java的int i64: 一个64位的有符号整数，对应java的long double：一个64位浮点数，对应java的double string：一个使用utf8编码的字符串，对应java的string 注意：没有无符号整数，因为大多数语言没有这种类型。 特殊类型二进制：未编码的字节序列注意：这个类型目前仅仅是上面string类型的特殊形式，为了和java更好的交互性，某些点上考虑也可认为是基本类型。 结构体structs结构体定义了公共对象，本质上等同于OOP语言中的类，但是没有继承的概念。结构体有一系列强类型的字段，每一个都有唯一的命名标识符。字段可能有不同的注解（数字的字段IDs，可选的默认值等。），这些在IDL中描述。 容器类型Containersthrift的容器类型是强类型容器，对应大部分语言中常用和公共的容器类型。有3种容器类型： list：有序的元素列表，被转换为STL vector，java arraylist，脚本语言中的数组等。 set：唯一元素的无序集合，被转换为STL set，java hashset，Python set等，php无sets，转成类似于list对待。 map：严格的唯一键到值得映射，转换为STL map，java hashmap，PHP associative array，Python/ruby的dictionary等。默认时，类型映射未明确绑定，自定义代码生成器可以替换为目标语言的自定义类型（不懂。） 容器类型支持任何有效的thrift type。N.B.: 为了最大的兼容通用性，map的key只能使用基本类型，不能使用容器或者结构体类型，因为有些语言的原始map类型不支持key使用复杂类型，如json协议的key只支持使用基本类型。 异常Exceptions异常功能等同于结构体，除了异常继承自每种语言的原始异常的基类，以便和每个语言的原始本地异常类无缝衔接。 服务Services服务使用thrift的类型定义，一个service的定义语义等同于定义一个接口（或者纯粹的抽象类）在面向对象的编程中。thrift编译器根据服务可生成功能齐全的客户端及实现了服务接口的server存根。 一个service包含一系列命名函数，每一个包含一系列参数和一个返回类型。 注意： void是一个有效的方法返回类型，除了其他定义的thrift类型。此外，一个单向的修饰符关键字可以修饰一个void函数，生成的代码不用等server端返回响应。一个纯粹的void函数是会返回一个响应到客户端的，来保证这个操作已在服务端处理完成。单向方法调用仅仅保证强求在传输层调用成功。同一客户端的单向方法多次调用可能在服务端是并行或者无序执行。","categories":[{"name":"thrift","slug":"thrift","permalink":"http://zhangxiangnan.com/categories/thrift/"}],"tags":[{"name":"thrift","slug":"thrift","permalink":"http://zhangxiangnan.com/tags/thrift/"},{"name":"thrift type","slug":"thrift-type","permalink":"http://zhangxiangnan.com/tags/thrift-type/"}]},{"title":"jvm之gc","slug":"jvm/jvm之gc","date":"2016-07-02T03:23:01.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2016/07/02/jvm/jvm之gc/","link":"","permalink":"http://zhangxiangnan.com/2016/07/02/jvm/jvm之gc/","excerpt":"jvm之gc知识","text":"jvm之gc知识 1、gc如何判定对象是否为垃圾，即如何判定哪些对象还活着，哪些已然死去？ 1、引用计数算法： 有个地方引用某对象，引用加一，引用失效，引用减一，引用为0则该对象为垃圾。其无法解决相互循环引用的问题。主流jvm虚拟机没有采取该算法。 2、可达性分析算法 从一系列gc roots的对象作为起点，向下搜索，gc roots能通过引用关系到达某个对象，则该对象有效，否则垃圾。 2、哪些对象可以作为gc roots 虚拟机栈（栈帧中的本地变量表）中引用的对象 方法去中类静态属性引用的对象 方法去中常亮引用的对象 本地方法栈中JNI（native方法）引用的对象 3、垃圾收集算法原理、特点、用处。 1、标记-清除（清理）算法 mark-sweep，首先标记所有需要回收的对象，标记完成后统一回收。 不足： - 效率问题，标记、清除过程效率不高； - 空间问题，标记清除后产生大量不连续内存碎片，碎片多在分配大对象使时，无法找到连续内存，而触发另一次垃圾收集。 2、复制算法（标记-复制，常用于新生代） 思想是将内存容量分成大小相等2块，每次使用其中一块，一块用完了，将存活对象复制到另一块，然后把已使用的一次清理。 现在商业虚拟机采取这种算法回收新生代，也不是对半分内存，而是分一块较大的Eden伊甸园空，和2块较小的Survivor存活空间，每次使用Eden和一块Survivor空间。回收时，将Eden和Survivor存活的拷贝到另一个Survivor空间（不够有老年代的担保分配机制），然后清理Eden和使用的一个Survivor区。 HotSpot虚拟机默认Eden:Survivor:Survivor = 8:1:1，浪费10%内存。 算法效率比标记清除高，内存利用率低。 3、标记整理算法（标记压缩，常用于老年代） Mark-Compact，与标记清除类似，让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。 减少内存碎片，存活对象移动到一端需要时间。 4、分代收集算法 当前商业虚拟机都采用分代收集（General Collection）算法。 根据对象存货周期将堆内存分新生代，老年代，新生代使用复制算法，老年代使用标记清理或者标记整理算法。 4、minor gc与full gc分别何时触发 Minor GC指发生在新生代的垃圾收集操作，java对象大都朝生熄灭，所以Minor GC非常频繁，速度也较快。 Major GC(Full GC)发生在老年代，经常伴有至少一次的Minor GC，full GC速度比minor GC慢10倍以上。 2中gc触发时间： 多数情况，对象在新生代Eden区分配，当Eden区没有足够空间分配，则发起一次Minor GC。 Minor GC 首先会对Eden区的对象进行标记，标记出来存活的对象。然后把存活的对象copy到From空间。（标记-复制）如果From空间足够，则回收eden区可回收的对象。如果from内存空间不够，则把From空间存活的对象复制到To区，如果TO区的内存空间也不够的话，则把To区存活的对象复制到老年代。如果老年代空间也不够（或者达到触发老年年垃圾回收条件的话）则触发一次full GC。 System.gc()若被调用，触发Full GC。 5、垃圾收集器哪些？CMS与G1收集器的特点并行：parallel，收集线程与用户线程并行工作，收集线程工作时，用户线程处于等待状态并发：concurrent，用户线程与收集线程同时运行。 Serial收集器单线程、串行回收、stop the world工作于新生代，采取复制算法client模式下的默认收集器，无线程切换开销，速度快，适合单cpu或client用户桌面应用场景（新生代一般配置的内存小，回收快）。 ParNew收集器Serial的多线程版本、Stop the world、并行回收工作于新生代，采取复制算法server模式下新生代的首选收集器，CMS只能与Serial和ParNew配合工作。 Parallel Scavenge收集器新生代收集器、采取复制算法，并行多线程关注吞吐量（用户代码执行/用户代码执行 + 垃圾收集）,高效利用cpu，尽快完成运算任务，适合后台运算而不需要太多交互的任务。吞吐量优先收集器-XX：MaxGCPauseMills -XX:GCTimeRatio自适应调节策略，来达到最大的吞吐量或最合适的响应时间。 Serial Old收集器serial的老年代版本，单线程，使用标记-整理算法适合client模式下的虚拟机stop the worldserver模式下，作为JDK1.5以及之前版本与Parallel Scavenge收集器搭配，或者作为CMS收集器的后备。 Parallel Old收集器Parallel Scavenge的老年版本，多线程、使用标记-整理算法JDK1.6提供。吞吐量优先及CPU资源敏感场合，优先考虑Parallel Scavenge + Paralle Old收集器。 CMS收集器：concurrent mark sweep 并发标记清除以获取最短回收停顿时间为目标非常适合服务的响应速度，希望系统停顿时间最短，给用户带来较好体验。基于标记-清除算法分初始标记、并发标记、重新标记、并发清除，前2个过程stop the world。并发低停顿收集器缺点 对cpu资源非常敏感 无法处理浮动垃圾 大量空间碎片 G1收集器面向服务端应用特点： 并行与并发，缩短停顿时间 分代收集，和其他收集器一样的概念 空间整合，整体看是标记-整理 可预测的停顿模型 建立优先列表，优先回收价值最大的区域。 各区域之间通过建立记忆集避免全表扫描引用依赖关系。 总结：G1与CMS相比，若立足于低停顿，CMS是现在选择， 以后可能G1更优秀，G1是可尝试选择。","categories":[{"name":"jvm","slug":"jvm","permalink":"http://zhangxiangnan.com/categories/jvm/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://zhangxiangnan.com/tags/jvm/"},{"name":"gc","slug":"gc","permalink":"http://zhangxiangnan.com/tags/gc/"}]},{"title":"spring如何保证线程安全的","slug":"spring/spring如何保证线程安全的","date":"2016-06-14T05:41:03.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2016/06/14/spring/spring如何保证线程安全的/","link":"","permalink":"http://zhangxiangnan.com/2016/06/14/spring/spring如何保证线程安全的/","excerpt":"spring的常见业务组件采取单例如何保证线程安全？ spring作为ioc框架，一般spring项目管理的bean如controller、api、service、dao大多数是单例（默认单例，配置多例模式使用scope=prototype），既然是单例，那么如何控制单例被多个线程同时访问线程安全呢？","text":"spring的常见业务组件采取单例如何保证线程安全？ spring作为ioc框架，一般spring项目管理的bean如controller、api、service、dao大多数是单例（默认单例，配置多例模式使用scope=prototype），既然是单例，那么如何控制单例被多个线程同时访问线程安全呢？ 首先要理解每个http请求到后台都是一个单独的线程，线程之间共享同一个进程的内存、io、cpu等资源，但线程栈是线程独有，线程之间不共享栈资源。 其次，bean分为有状态bean和无状态bean，有状态bean即类定义了成员变量，可能被多个线程同时访问，则会出现线程安全问题；无状态bean每个线程访问不会产生线程安全问题，因为各个线程栈及方法栈资源都是独立的，不共享。即是，无状态bean可以在多线程环境下共享，有状态bean不能。 所以一般来说，spring管理的api、service、dao都是单例存在，节省内存和cpu、提高单机资源利用率。 spring的dao、service层使用的数据库connection连接等一些有状态bean如何保证线程安全？ spring应用中dao、service一般以单例形式存在，dao、service中使用的数据库connection以及RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等都是有状态bean，而dao、service又是单例，如何保证线程安全呢？ 答案是使用threadLocal进行处理，ThreadLocal是线程本地变量，每个线程拥有变量的一个独立副本，所以各个线程之间互不影响，保证了线程安全。 springMVC的controller并发访问呢？ springMVC中的controller默认是单例的，所以如上所述，属性变量会到值线程安全问题，解决方法包括使用threadLocal或、不使用属性变量、配置为多例均可（加锁控制效率不行）。 spring的几个概念singleton：单例、缺省,就是指一个spring的容器中，只有一个实例存在，和单例模式不同。prototype：原型，多例，指一个spring容器中，每个请求创建一个单独的实例存在。scope属性的其他值：request：请求范围内，session：session范围内。 如何配置单例与多例spring的注解或者xml配置属性scope=singleton表示单例，scope=prototype表示多例。","categories":[{"name":"spring","slug":"spring","permalink":"http://zhangxiangnan.com/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://zhangxiangnan.com/tags/spring/"},{"name":"framework","slug":"framework","permalink":"http://zhangxiangnan.com/tags/framework/"},{"name":"threadsafe","slug":"threadsafe","permalink":"http://zhangxiangnan.com/tags/threadsafe/"},{"name":"concurrent","slug":"concurrent","permalink":"http://zhangxiangnan.com/tags/concurrent/"}]},{"title":"esper介绍","slug":"esper/esper介绍","date":"2016-05-19T10:26:22.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2016/05/19/esper/esper介绍/","link":"","permalink":"http://zhangxiangnan.com/2016/05/19/esper/esper介绍/","excerpt":"项目中遇到某个api连续报错N次则报警、账户风险控制、异地登录监测、衣服有长头发 &amp; 脖子上有不明唇印 &amp; 早出晚归 则判定丈夫出轨、套牌车辆预警，同时还要避免已报警一次的数据不会重复报警导致邮件短信风暴，怎么玩？","text":"项目中遇到某个api连续报错N次则报警、账户风险控制、异地登录监测、衣服有长头发 &amp; 脖子上有不明唇印 &amp; 早出晚归 则判定丈夫出轨、套牌车辆预警，同时还要避免已报警一次的数据不会重复报警导致邮件短信风暴，怎么玩？ 介绍Esper是一个事件流处理（ESP)和事件相关引擎（CEP，复杂事件处理)。针对实时驱动架构（EDA)，Esper当事件条件发生在事件流中时，能够触发使用POJO编写的自定义动作（操作）。Esper为高容量的事件相关性设计，这些场景中产生的数以百万的事件使传统的数据库架构难以存储所有数据以便以后的查询。 一个定制的事件处理语言（EPL）允许表达丰富的事件条件、相关性、可跨越的时间窗口，进而最大限度降低构建一个应对复杂场景的开发工作。 Esper是一个使用java开发的轻量级内核，它可以完全嵌入任何其他java进程、JEE应用服务器、基于java的企业级服务总线。它可以快速开发处理大量的传入消息或者事件的应用程序。 时间流及复杂事件介绍信息对于做出睿智的决定是关键的。这不仅在现实生活中正确而且在计算中也适用，尤其在几个领域很关键，如金融、欺诈检测、商业智能或者战场指挥。信息从不同的来源以信息、事件的形式流动，可以在指定时间给出状态的提示如股票价格。 为什么使用esper？","categories":[{"name":"esper","slug":"esper","permalink":"http://zhangxiangnan.com/categories/esper/"}],"tags":[{"name":"esper","slug":"esper","permalink":"http://zhangxiangnan.com/tags/esper/"},{"name":"esp","slug":"esp","permalink":"http://zhangxiangnan.com/tags/esp/"},{"name":"cep","slug":"cep","permalink":"http://zhangxiangnan.com/tags/cep/"},{"name":"eda","slug":"eda","permalink":"http://zhangxiangnan.com/tags/eda/"}]},{"title":"使用hexo与next主题搭建个人博客","slug":"blog/使用hexo与next主题搭建个人博客","date":"2016-05-10T09:56:39.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2016/05/10/blog/使用hexo与next主题搭建个人博客/","link":"","permalink":"http://zhangxiangnan.com/2016/05/10/blog/使用hexo与next主题搭建个人博客/","excerpt":"借助于github的github pages，通过hexo创建个人博客，本文描述了如何搭建，以及常见的问题及经验。","text":"借助于github的github pages，通过hexo创建个人博客，本文描述了如何搭建，以及常见的问题及经验。 本人环境配置hexo: 3.2.0 nodejs:v4.2.1 npm: 2.14.5 git: 1.9.5.msysgit.1 windows:win7 x64 环境配置 安装git 安装nodejs 安装node的npm包 开发配置快速搭建博客骨架博客目录d:/blog，以下命令均在blog目录下执行： //全局安装hexo $ npm install -g hexo // 创建个目录，命令行进入该目录，执行命令，初始化博客目录 $ hexo init // 新版本hexo自动安装依赖，旧版本估计需要执行如下： $ npm install // 生成静态页面，简写hexo g $ hexo generate // 本地预览，访问localhost:4000 hexo server 点击查看本地预览 // hexo高版本用来安装git部署器，发布博客到github用$ npm install hexo-deployer-git –save 博客部署到github上安装git的部署器博客目录d:/blog，以下命令均在blog目录下执行： // hexo高版本用来安装git部署器，发布博客到github用 $ npm install hexo-deployer-git --save github上创建项目项目名称注意 github上必须创建username.github.io的repository名，才能当作博客，username为你的github用户名。 创建时勾选 Initialize this repository with a README 勾选该复选框，可以立即克隆仓库到本地。 github项目设置deploy keys 选择刚创建的项目，settings-&gt;左边deploy keys-&gt;添加本机的ssh公钥即可 站点配置文件_config.xml配置git信息//在deploy节点下配置type类型(git、老版本貌似是github)、仓库地址、分支 deploy: type: git repository: https://github.com/zhangxiangnan/zhangxiangnan.github.io.git branch: master 克隆项目到本地 克隆刚创建的项目到本地，把.git文件夹拷贝到博客目录下，或者相反都行，然后即可提交到github上。 $ git clone 仓库地址 提交项目到github上$ hexo clean $ hexo generate $ hexo deploy #之后输入用户名、密码 deploy操作会把blog目录下的public文件夹下的内容发布到github上刚创建的项目。 主题及其设定、常见第三方服务见: http://theme-next.iissnan.com/getting-started.html 常用命令清理项目 清理项目 hexo clean 构建生成项目hexo generate 或者hexo g 本地预览项目hexo server 新建文章hexo new title “xx”","categories":[{"name":"blog","slug":"blog","permalink":"http://zhangxiangnan.com/categories/blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://zhangxiangnan.com/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"http://zhangxiangnan.com/tags/hexo/"},{"name":"next theme","slug":"next-theme","permalink":"http://zhangxiangnan.com/tags/next-theme/"}]},{"title":"spring的7种事务传播行为（传播级别、传播属性）","slug":"spring/spring的事务传播属性","date":"2015-06-01T13:23:53.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2015/06/01/spring/spring的事务传播属性/","link":"","permalink":"http://zhangxiangnan.com/2015/06/01/spring/spring的事务传播属性/","excerpt":"spring管理的事务中，事务是否允许嵌套？如何配置无事务？如何配置必有事务？如何配置事务存在则报错？嵌套事务任一方回滚会发生什么？ ……","text":"spring管理的事务中，事务是否允许嵌套？如何配置无事务？如何配置必有事务？如何配置事务存在则报错？嵌套事务任一方回滚会发生什么？ …… 什么是事务传播行为？ 事务保证原子性操作的手段，要么全部操作都提交，要么都回滚，保证数据一致性，避免产生脏数据。 当我们调用spring管理的service方法A时，A运行在spring管理的事务，A可能调用service的B方法，这就是服务接口方法嵌套调用，spring通过事务传播行为控制当前事务如何传播到被嵌套调用的目标服务接口方法中。 就是说，事务传播属性（传播行为、传播级别）定义的是事务的控制范围（影响作用范围），举例简单说就是A方法的事务会传递到B方法吗，B方法用不用新建事务？还是用A的？还是嵌套事务？还是报错？还是将A方法的事务挂起？。 事务传播行为种类spring的TransactionDefinition接口定义了7中类型的事务传播行为，他们规定了事务方法与事务方法在发生嵌套调用时如何传播事务。 int PROPAGATION_REQUIRED = 0; int PROPAGATION_SUPPORTS = 1; int PROPAGATION_MANDATORY = 2; int PROPAGATION_REQUIRES_NEW = 3; int PROPAGATION_NOT_SUPPORTED = 4; int PROPAGATION_NEVER = 5; int PROPAGATION_NESTED = 6; 传播行为 说明 PROPAGATION_REQUIRED 只支持单个事务，有事务就使用这个事务，无则创建一个新事务，事务定义的默认配置，事务同步范围的常用配置。 PROPAGATION_SUPPORTS 有事务则使用当前事务，无事务则以无事务方式执行。 PROPAGATION_MANDATORY 有事务则使用当前事务，当前无事务则抛出异常。 PROPAGATION_REQUIRES_NEW 创建新事务，当前有事务则挂起当前事务。 PROPAGATION_NOT_SUPPORTED 不支持事务，如果存在事务，则将当前事务挂起。 PROPAGATION_NEVER 只能以非事务运行，有事务就报错。 PROPAGATION_NESTED 如果当前环境不存在事务则与PROPAGATION_REQUIRED一样，否则若有事务，则新建子事务，子事务与父事务形成嵌套事务，事务有联系，不是独立的。该行为需基于jdbc3.0，且持久化框架需实现了保存点事务机制。 PROPAGATION_REQUIRES_NEW（新事务）与PROPAGATION_NESTED（嵌套事务）的区别？ PROPAGATION_REQUIRES_NEW(新事务)当前没有事务则创建新事务，当前有事务会将外层事务挂起，新事务执行完毕外层事务继续执行；PROPAGATION_NESTED（嵌套事务）不会挂起外层事务。 PROPAGATION_REQUIRES_NEW创建的新事务和外层事务无关，相互独立地提交和回滚，拥有自己的数据库隔离级别和锁；PROPAGATION_NESTED的嵌套事务和外层事务有关联，外层事务提交或回滚，子事务也会提交回滚。 嵌套事务的提交回滚说明 外层事务相当于父事务，内层事务相当于子事务。 嵌套事务是子事务套在父事务中执行，进入子事务之前，父事务建立一个回滚点或者叫保存点savepoint，然后执行子事务，子事务执行完毕，父事务继续执行。 子事务回滚，父事务发生什么？ 父事务会滚到savepoint，继续执行其他事务与业务逻辑，父事务之前操作不影响，不会自动回滚。 父事务回滚，子事务呢？ 子事务回滚，子事务是父事务的一部分，随着父事务提交而提交。 子事务、父事务提交事务的顺序？外层事务提交时，子事务一并提交，子事务不能先提交。 子事务异常回滚，并抛异常，父事务若捕获异常则可能提交，否则回滚。 PROPAGATION_MANDATORY设置的方法能被其他非事务方法调用吗？不能，会报错，比如controller直接调该方法，则报异常，必须由其他含有事务的业务方法调用，设置该行为的方法一般间接被调用。 PROPAGATION_NEVER被其他有事务的方法调用的话？报错，设置该行为的方法一般是直接调用。 PROPAGATION_NOT_SUPPORTED如何表现？比如A方法调用B方法，A有事务，B配置该传播行为，则B将A的事务挂起，无事务状态运行结束后，继续以有事务状态执行A。A无事务的话，直接运行。 PROPAGATION_NESTED嵌套事务与方法嵌套调用有关系吗？没关系。具体得看相关方法设置的隔离级别，区分是嵌套事务还是新事务。 注意点 事务传播行为是设置在某个具体方法上的","categories":[{"name":"spring","slug":"spring","permalink":"http://zhangxiangnan.com/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://zhangxiangnan.com/tags/spring/"},{"name":"transaction","slug":"transaction","permalink":"http://zhangxiangnan.com/tags/transaction/"},{"name":"propagation","slug":"propagation","permalink":"http://zhangxiangnan.com/tags/propagation/"}]},{"title":"深入了解javaWeb中的中文编解码","slug":"javaweb/深入了解javaWeb中的中文编解码","date":"2015-05-12T01:40:52.000Z","updated":"2019-02-27T05:39:45.000Z","comments":true,"path":"2015/05/12/javaweb/深入了解javaWeb中的中文编解码/","link":"","permalink":"http://zhangxiangnan.com/2015/05/12/javaweb/深入了解javaWeb中的中文编解码/","excerpt":"为什么需要编解码？有几种编解码？javaweb哪些场景需要编解码？常见乱码问题如何分析解决？","text":"为什么需要编解码？有几种编解码？javaweb哪些场景需要编解码？常见乱码问题如何分析解决？ 为啥需要编解码？ 计算机中存储信息的最小单位是字节，一个字节8位，能表示范围是0~255，假如说0表示汉字“我”，1表示。。，这样最多只能表示256个汉字，而汉字有很多。 其他语言也太多，不可能255个字符只用来表示汉字。 那就需要一个新的若干个byte组合的数据结构来表示众多的语言文字-char。从char到byte需要编码，从byte到char需要解码。 常见编解码格式编解码格式定义了从字节到字符，从字符到字节的转化的规则，通过这个规则可以把汉字转成字节传输，可以从字节转成汉字。常见的编解码格式如下表： 编码格式 表示个数 所需字节数 说明 ASCII 128 单字节的低七位表示 0~31为控制字符如回车换行等；32~126为打印字符，可键盘输入能够显示出来 ISO-8859-1 表示256个字符 单字节 扩展ASCII码，ISO8859-1到ISO8859-15，ISO8859-涵盖大多数西欧语言字符，应用最广泛。 GB2312 7445 双字节 A1~A9是符号区，682个；B0~F7是汉字区，共6763个汉字。 GBK 23940 双字节 扩展自GB2312，支持更多汉字，范围从8140~FEFE（去掉XX7F），能表示21003汉字，兼容GB2312。 GBK18030 兼容GB2312 应用不广泛 应用不广泛 UTF-16 处理Unicode编码 双字节 用2字节表示Unicode的转化格式，任何字符都通过2个字节表示，定长表示，效率快，java以UTF-16内存的字符存储格式。适合在本地磁盘和内存之间使用，可以达到字符和字节快速切换。 UTF-8 处理unicode编码 变长 每个编码区域不同字码长度，不同类型字符可以由1~6个字节组成，节省空间，效率不如utf-16，介于gbk和uft-16之间，适合网络传输，对ASCII码单字节存储，单字符损坏不影响后面字符。其通过首字节的前2位确定需要几个字节表示。 说明：unicode是统一码，ISO创建的全新的超语言字典，所有语言都可以通过这个字典相互翻译。 java中哪些场景要编码IO编解码分磁盘IO与网络IO，网络IO见javaWeb中编解码。读文件（字节到字符）：java使用InputStreamReader关联字节到字符的桥梁，进行字节解码，解码由StreamDecoder使用指定charset，无则默认z中文使用GBK。 写文件（字符到字节）：java使用OutputStreamWriter做字符到字节的转换桥梁，进行字符的编码，编码由StringEncoder处理，使用指定charset，无默认GBK。 内存中编解码String提供的方法如下： String s = &quot;hah哈你好&quot;; byte[] b = s.getBytes(&quot;UTF-8&quot;); String n =new String(b, &quot;UTF-8&quot;); Charset的encode和decode方法 其提供char[]到byte[]编码及byte[]到char[]解码，如下： Charset charset = Charset.forName(&quot;UTF-8&quot;); ByteBuffer byteBuffer = charset.encode(string); CharBuffer charBuffer = charset.decode(byteBuffer); ByteBuffer类的软转换ByteBuffer提供char与byte的软转换，转换不需要编解码，只是把16bit的char拆分为2个8bit的byte表示，实际值没有修改，仅仅数据类型做转换： ByteBuffer bytebuffer2 = ByteBuffer.allocate(1024); ByteBuffer byteBuffer = bytebuffer2.putChar(c); javaWeb中涉及的编解码网络传输都是以字节为单位，java对象要经过网络传输必须经过序列化，实现Serializable序列化接口。 用户发起http请求，需要编码的地方有URL、Cookie、Parameter服务端收到htt请求，对URI、Cookie、POST表单参数解码，服务端还可能从数据库、本地或网络其他地方的文本文件读取数据，都可能存在解码问题。servlet处理请求，将响应数据编码通过socket返回到浏览器，浏览器解码为文本信息。 URL的编解码URL中可能有中文，需要编码，根据URL的编码规范RFC3986，浏览器将非ASCII字符按照某编码格式编码然后前面加上%，可以设置编码，不同浏览器不一样。 tomcat对URL的URL部门进行解码的字符集在设置，默认ISO-8859-1，一般URL有中文该项需设置。 URL的QueryString（get请求的url后的请求参数）是通过HTTP的Header的content-type定义传到服务器，要么默认ISO-8859-1，使用自定义的ContentTYpe，需要设置 ，该配置不是针对全部URI采用BodyEncoding编码，而是只针对QueryString部分。 总结：尽量避免在URL中使用非ASCII字符，服务器最好也设置Connector的2个属性。 HTTP Header的编解码Header中的Cookie、redirectPath也可能存在编码问题。tomcat对Header中项解码在调用request.getHeader()时进行。如果请求的Header项没有解码则调用MessageBytes的toString方法，默认使用ISO-8859-1，也不能设置其他格式，如果Header中有非ASCII字符，解码会乱码。 POST表单的编解码POST表单提交的参数的解码在第一次调用request.getParameter时发生，POST表单参数通过http的body传递到服务端。整个流程是点提交时，浏览器根据contenttype的charset对表单参数编码，提交到服务端，服务端同样用contenttype中的字符集进行解码，所以post表单的参数一般不会乱码。通过request.setCharacterEncoding(charset)可以设置。 注意：要在第一次调用request.getParameter方法之前设置request.setCharacterEncoding(charset)，否则POST表单提交的数据可能出现乱码。 HTTP BODY的编解码服务端返回的结果经过编码返回浏览器，浏览器解码，然后显示。编码可以通过response.setCharacterEncoding设置，会覆盖request.setCharacterEncoding的值，通过Header的content-type返回给客户端。浏览器首先根据Content-type解码，无则根据HTML的来解码，无则使用浏览器默认编码解码。 数据库连接的编解码若使用jdbc，存取数据时要和数据的内置编码保持一致，可在jdbc的url中设置编码指定。 url=&quot;jdbc:mysql://localhost:3306/db?useUnicode=true&amp;characterEncoding=GBK&quot; js编解码js文件编解码&lt;html&gt; &lt;head&gt; &lt;script src=&quot;xxx/a.js&quot; charset=&quot;gbk&quot;/&gt; 引入的js文件若有中文，和本html页面的编码若不一致则会乱码，可以手动指定编码格式。 js的url编解码js中发起ajax请求的url默认编码受浏览器不同影响，可使用escape()、encodeURI()、encodeURIComponent()几个函数搞定。java中的URLEncoder、URLDecoder和js的encodeURIComponent对应。 xml文件的编解码xml文件开始设定encoding velocity模板设置编码services.VelocityService.input.encoding=UTF-8 jsp设置编码jsp页面开始设置charset","categories":[{"name":"javaWeb","slug":"javaWeb","permalink":"http://zhangxiangnan.com/categories/javaWeb/"},{"name":"encode decode","slug":"javaWeb/encode-decode","permalink":"http://zhangxiangnan.com/categories/javaWeb/encode-decode/"}],"tags":[{"name":"encode","slug":"encode","permalink":"http://zhangxiangnan.com/tags/encode/"},{"name":"decode","slug":"decode","permalink":"http://zhangxiangnan.com/tags/decode/"},{"name":"javaWeb","slug":"javaWeb","permalink":"http://zhangxiangnan.com/tags/javaWeb/"}]}]}