<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="一块学习">
    <meta name="keyword" content="undefined">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        JAVA泛型 - 张向南的博客 | zhangxiangnan&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> progress everyday </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.png">
        </div>
        <div class="name">
            <i>zhangxiangnan</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li>
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li>
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么用泛型"><span class="toc-text">为什么用泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#泛型类型"><span class="toc-text">泛型类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#类型参数命名规范"><span class="toc-text">类型参数命名规范</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#泛型调用及实例化"><span class="toc-text">泛型调用及实例化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#参数化类型"><span class="toc-text">参数化类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#泛型方法"><span class="toc-text">泛型方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有界（受限）类型参数"><span class="toc-text">有界（受限）类型参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#泛型-amp-继承-amp-子类型"><span class="toc-text">泛型&amp;继承&amp;子类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类型推导"><span class="toc-text">类型推导</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#通配符"><span class="toc-text">通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#上限通配符"><span class="toc-text">上限通配符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#无界通配符"><span class="toc-text">无界通配符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#下界通配符"><span class="toc-text">下界通配符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#通配符和子类型"><span class="toc-text">通配符和子类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#通配符捕获和辅助方法"><span class="toc-text">通配符捕获和辅助方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#通配符的使用场合"><span class="toc-text">通配符的使用场合</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类型擦除"><span class="toc-text">类型擦除</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#泛型类型擦除"><span class="toc-text">泛型类型擦除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#泛型方法擦除"><span class="toc-text">泛型方法擦除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#桥接方法"><span class="toc-text">桥接方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#泛型的限制"><span class="toc-text">泛型的限制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#不能使用基本类型实例化泛型类型"><span class="toc-text">不能使用基本类型实例化泛型类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#不能创建类型参数的实例"><span class="toc-text">不能创建类型参数的实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#不能声明类型为类型参数的静态字段"><span class="toc-text">不能声明类型为类型参数的静态字段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#针对参数化类型不能使用cast或instanceof"><span class="toc-text">针对参数化类型不能使用cast或instanceof</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#不能创建参数化的数组类型"><span class="toc-text">不能创建参数化的数组类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#不能创建、捕获、抛出序列化类型的对象"><span class="toc-text">不能创建、捕获、抛出序列化类型的对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#形式类型参数擦除后类型一样的不能重载"><span class="toc-text">形式类型参数擦除后类型一样的不能重载</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#非具体化类型"><span class="toc-text">非具体化类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#堆污染"><span class="toc-text">堆污染</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input">
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> progress everyday </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        JAVA泛型
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2017-12-18 20:46:15</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#generics" title="generics">generics</a>
        <span>/</span>
        
        <a class="tag" href="/tags/#java" title="java">java</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>

    </div>
    <div class="post-content ">
        <p>Java中的泛型详解！<br><a id="more"></a></p>
<h4 id="为什么用泛型"><a href="#为什么用泛型" class="headerlink" title="为什么用泛型"></a>为什么用泛型</h4><p>泛型支持在定义类、接口、方法时将类型当作参数，称作类型参数/类型变量，和形参类似，形参是输入值不同，类型参数是输入类型不同。</p>
<ul>
<li>编译时更强的类型检测，避免更多运行时异常，减少bug</li>
<li>消除强转</li>
<li>实现支持不同类型集合的泛型算法，更安全、易懂</li>
</ul>
<h4 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h4><p>泛型是类型参数化的泛型类或接口。<br>不用泛型时(可放各种类型，所以运行时强转时容易异常)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Box &#123;</span><br><span class="line">  private Object object;</span><br><span class="line">  public void set(Object object) &#123; this.object = object; &#125;</span><br><span class="line">  public Object get() &#123; return object; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>泛型类的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class name&lt;T1, T2, ..., Tn&gt; &#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Box&lt;T&gt; &#123;</span><br><span class="line">    // T stands for &quot;Type&quot;</span><br><span class="line">    private T t;</span><br><span class="line"></span><br><span class="line">    public void set(T t) &#123; this.t = t; &#125;</span><br><span class="line">    public T get() &#123; return t; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类型变量T可以在类中任何地方使用，类型变量可以是任何非基本类型的类型：任意类类型、接口类型、以至另一个类型变量。</p>
<h5 id="类型参数命名规范"><a href="#类型参数命名规范" class="headerlink" title="类型参数命名规范"></a>类型参数命名规范</h5><p>约定俗成，类型参数单字母、大写，常用的如下：</p>
<ul>
<li>E 元素 (java集合框架常用）</li>
<li>K Key</li>
<li>N Number</li>
<li>T Type</li>
<li>V Value</li>
<li>S,U,V等</li>
</ul>
<h5 id="泛型调用及实例化"><a href="#泛型调用及实例化" class="headerlink" title="泛型调用及实例化"></a>泛型调用及实例化</h5><p>泛型类型的调用(也称参数化类型)：Box<integer> integerBox;<br>实例化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;();</span><br><span class="line">Box&lt;Integer&gt; integerBox = new Box&lt;&gt;();//&gt;=jdk7</span><br></pre></td></tr></table></figure></integer></p>
<h5 id="参数化类型"><a href="#参数化类型" class="headerlink" title="参数化类型"></a>参数化类型</h5><p>类型参数也可以是参数化类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OrderedPair&lt;String, Box&lt;Integer&gt;&gt; p = new OrderedPair&lt;&gt;(&quot;primes&quot;, new Box&lt;Integer&gt;(...));</span><br></pre></td></tr></table></figure></p>
<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>泛型方法指引入类型参数的方法，在方法的返回类型之前声明，使用&lt;&gt;，可以有多个类型参数，适用于静态、非静态、构造方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  public class Util &#123;</span><br><span class="line">      public static &lt;K, V&gt; boolean compare(Pair&lt;K, V&gt; p1, Pair&lt;K, V&gt; p2) &#123;</span><br><span class="line">          return p1.getKey().equals(p2.getKey()) &amp;&amp;</span><br><span class="line">                 p1.getValue().equals(p2.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public class Pair&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">  private K key;</span><br><span class="line">  private V value;</span><br><span class="line"></span><br><span class="line">  public Pair(K key, V value) &#123;</span><br><span class="line">      this.key = key;</span><br><span class="line">      this.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setKey(K key) &#123; this.key = key; &#125;</span><br><span class="line">  public void setValue(V value) &#123; this.value = value; &#125;</span><br><span class="line">  public K getKey()   &#123; return key; &#125;</span><br><span class="line">  public V getValue() &#123; return value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  Pair&lt;Integer, String&gt; p1 = new Pair&lt;&gt;(1, &quot;apple&quot;);</span><br><span class="line">  Pair&lt;Integer, String&gt; p2 = new Pair&lt;&gt;(2, &quot;pear&quot;);</span><br><span class="line">  boolean same = Util.&lt;Integer, String&gt;compare(p1, p2);</span><br><span class="line">  boolean same = Util.compare(p1, p2);//类型推导</span><br></pre></td></tr></table></figure></p>
<h4 id="有界（受限）类型参数"><a href="#有界（受限）类型参数" class="headerlink" title="有界（受限）类型参数"></a>有界（受限）类型参数</h4><p>  有些情况想限制类型参数的参数类型为某个类型或及其子类型，用extends表示.<br>  extends此处表示类的继承和接口的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public &lt;U extends Number&gt; void inspect(U u)&#123;</span><br><span class="line">      System.out.println(&quot;T: &quot; + t.getClass().getName());</span><br><span class="line">      System.out.println(&quot;U: &quot; + u.getClass().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有界类型参数可以调用界限类型里定义的方法，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class NaturalNumber&lt;T extends Integer&gt; &#123;</span><br><span class="line">  private T n;</span><br><span class="line">  public NaturalNumber(T n)  &#123; this.n = n; &#125;</span><br><span class="line">  public boolean isEven() &#123;</span><br><span class="line">      return n.intValue() % 2 == 0;</span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>界限可以有多个，用&amp;连接，多个界限中最多只能有一个类；如果有一个类，多个接口，则该类必须在最左，如<t extends b1 & b2 b3> （B1为类）</t></p>
<p>有界类型参数是泛型算法实现的关键，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparable&lt;T&gt; &#123;</span><br><span class="line">  public int compareTo(T o);</span><br><span class="line">&#125;</span><br><span class="line">public static &lt;T extends Comparable&lt;T&gt;&gt; int countGreaterThan(T[] anArray, T elem) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    for (T e : anArray)</span><br><span class="line">        if (e.compareTo(elem) &gt; 0)</span><br><span class="line">            ++count;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="泛型-amp-继承-amp-子类型"><a href="#泛型-amp-继承-amp-子类型" class="headerlink" title="泛型&amp;继承&amp;子类型"></a>泛型&amp;继承&amp;子类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;Number&gt; box = new Box&lt;Number&gt;();</span><br><span class="line">box.add(new Integer(10));   // OK</span><br><span class="line">box.add(new Double(10.1));  // OK</span><br><span class="line"></span><br><span class="line">public void boxTest(Box&lt;Number&gt; n) &#123; &#125;</span><br><span class="line">boxTest(new Box(10))</span><br><span class="line">//error,Box&lt;Integer&gt;、Box&lt;Double&gt;都不是Box&lt;Number&gt;的子类型。</span><br></pre></td></tr></table></figure>
<p>A继承于B，但是不代表Class<a>继承于Class<b></b></a></p>
<p>泛型的继承可以通过extends或implements来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; -&gt; List&lt;String&gt; -&gt; Collection&lt;String&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><p>Java编译器从方法调用传入的类型以及对应的方法声明的参数类型来推断出使方法调用最合理的参数类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; T pick(T a1, T a2) &#123; return a2; &#125;</span><br><span class="line">Serializable s = pick(&quot;d&quot;, new ArrayList&lt;String&gt;())</span><br></pre></td></tr></table></figure></p>
<p>有了类型推导，在泛型方法调用、实例化泛型类、泛型类/非泛型类的泛型构造方法调用都可以省略。<br>类型推导只通过调用参数、目标类型、返回值类型来推导，而不是用程序后续的结果类型。</p>
<h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>泛型中，问号标记“？”叫通配符，表示一种未知类型，通配符可以用在以下情形：参数的类型、字段、本地变量、返回值；不用于泛型方法调用的类型参数、泛型类的创建、父类型。</p>
<h5 id="上限通配符"><a href="#上限通配符" class="headerlink" title="上限通配符"></a>上限通配符</h5><p>上限通配符用来放宽变量的限制，比如想定义一个方法，适用于 List<integer>, List<double>, and List<number>类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void process(List&lt;? extends Number&gt;) &#123;&#125;</span><br></pre></td></tr></table></figure></number></double></integer></p>
<p>List<number>限制所有类型只能为Number，但List&lt;? extends Number&gt;可匹配Number及Number子类型，并且每个元素都可以调用Number类里的方法。</number></p>
<h5 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h5><p>使用?定义，如List&lt;?&gt;，称作未知类型的list，适用场合：</p>
<ul>
<li>如果在写一个可以使用Object类中的功能实现的方法</li>
<li>当代码在泛型中使用不依赖类型参数的方法，如List.size List.clear，实际上Class&lt;?&gt;最常用，因为Class<t>里的多数方法不依俩T。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 不适用于List&lt;Integer&gt;、List&lt;String&gt;等</span><br><span class="line">public static void printList(List&lt;Object&gt; list) &#123;</span><br><span class="line">  for (Object elem : list)</span><br><span class="line">      System.out.println(elem + &quot; &quot;);</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印，适合任务类型</span><br><span class="line">public static void printList(List&lt;?&gt; list) &#123;</span><br><span class="line">  for (Object elem: list)</span><br><span class="line">      System.out.print(elem + &quot; &quot;);</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</t></li>
</ul>
<p>List&lt;?&gt;与List<object>不一样，List<object>可以往里面添加Object、及Object的任务子类型，但是List&lt;?&gt;声明的变量只能往里添加null。</object></object></p>
<h5 id="下界通配符"><a href="#下界通配符" class="headerlink" title="下界通配符"></a>下界通配符</h5><p>下届通配符用 ? super Foo 表示只能是Foo或Foo的父类型，不能同时声明下届和上界。</p>
<p>List<integer>和List&lt;? super Integer&gt;不一样，List<integer>匹配Integer的列表，但是List&lt;? super Integer&gt;匹配Integer及Integer的父类型。</integer></integer></p>
<h5 id="通配符和子类型"><a href="#通配符和子类型" class="headerlink" title="通配符和子类型"></a>通配符和子类型</h5><p>A extends B，但是Class<a>和Class<b>没有继承关系，如何让两者有关系？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Integer&gt; intList = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;? extends Number&gt;  numList = intList;  // OK. List&lt;? extends Integer&gt;是List&lt;? extends Number&gt;的子类型</span><br></pre></td></tr></table></figure></b></a></p>
<p>List&lt;?&gt;是List<integer>和List<number>的父类型。</number></integer></p>
<p>List<integer> -&gt; List&lt;? extends Integer&gt; -&gt; List&lt;? extends Number&gt; -&gt; List&lt;?&gt;</integer></p>
<p>List<number> -&gt; List&lt;? super Number&gt; -&gt; List&lt;? super Integer&gt; -&gt; List&lt;?&gt;</number></p>
<p>List<number> -&gt; List&lt;? extends Number&gt;</number></p>
<p>List<integer> -&gt; List&lt;? super Integer&gt;</integer></p>
<h5 id="通配符捕获和辅助方法"><a href="#通配符捕获和辅助方法" class="headerlink" title="通配符捕获和辅助方法"></a>通配符捕获和辅助方法</h5><p>有些情况下，编译器可以捕获到通配符的类型，这种叫通配符捕捉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class WildcardError &#123;</span><br><span class="line"></span><br><span class="line">  void foo(List&lt;?&gt; i) &#123;</span><br><span class="line">      i.set(0, i.get(0));//报包含capture of ?的错误</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>添加辅助方法来解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class WildcardFixed &#123;</span><br><span class="line">  void foo(List&lt;?&gt; i) &#123;</span><br><span class="line">      fooHelper(i);</span><br><span class="line">  &#125;</span><br><span class="line">  // 创建辅助方法以便可以通过类型推导来进行通配符类型捕获</span><br><span class="line">  private &lt;T&gt; void fooHelper(List&lt;T&gt; l) &#123;</span><br><span class="line">      l.set(0, l.get(0));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="通配符的使用场合"><a href="#通配符的使用场合" class="headerlink" title="通配符的使用场合"></a>通配符的使用场合</h5><p>何时使用上界通配符、何时使用下界通配符？首先通配符主要用在方法的形式参数声明上，应避免使用在方法返回类型上（调用者需要处理通配符）</p>
<ul>
<li>输入变量(In)就是一个提供数据给代码使用的变量，如拷贝方法copy(src, dst)，src就是输入变量，因为src提供了用来拷贝的数据（producer）；</li>
<li>输出变量(Out)就是一个保存数据以便在其他地方使用的变量，如copy方法的dst变量，数据拷贝到了dst接受了拷贝的数据(consumer)</li>
<li>又用于输入且用于输出的变量</li>
</ul>
<p>使用指南（方法的参数声明）：</p>
<ul>
<li>输入变量使用上界通配符，extends，此时变量只读</li>
<li>输出变量使用下界通配符，super，此时变量只可写</li>
<li>针对输入变量可以使用Object类里定义的方法访问时，使用无界通配符</li>
<li>当代码同时需要将变量当作输入、输出变量时，不使用通配符</li>
</ul>
<p>以上描述总结出PECS－Producer extends, consumer super.</p>
<p>List&lt;? extends …&gt;定义的变量可以认为只读，但是不是严格意义的只读，只是说不能修改已有元素、不能新增元素，但是仍可以执行如下：</p>
<ul>
<li>clear</li>
<li>插入null</li>
<li>迭代与删除</li>
<li>通过通配符捕捉来写入元素</li>
</ul>
<h4 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h4><p>Java引入泛型来加强编译器类型检查以及支持泛型编程，java使用类型擦除来实现泛型：</p>
<ul>
<li>替换泛型类型中所有的类型参数为他们的边界类型或者为Object（类型参数无界时）,因为生成的字节码都是普通的类、接口、方法</li>
<li>如果需要保持类型安全，插入类型转换指令</li>
<li>生成桥接方法来保持泛型类型继承中的多态性</li>
</ul>
<p>java针对参数化类型不会生成新的类，所以泛型不会产生运行时开销。</p>
<h5 id="泛型类型擦除"><a href="#泛型类型擦除" class="headerlink" title="泛型类型擦除"></a>泛型类型擦除</h5><p>类型擦除时，编译器擦除所有的类型参数，并每个都使用最左边界类型或者Object(无界类型)来替换 ，Node<t>中T是无界通配符。</t></p>
<h5 id="泛型方法擦除"><a href="#泛型方法擦除" class="headerlink" title="泛型方法擦除"></a>泛型方法擦除</h5><p>泛型方法擦除时，和类型擦除一样。</p>
<h5 id="桥接方法"><a href="#桥接方法" class="headerlink" title="桥接方法"></a>桥接方法</h5><p>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Node&lt;T&gt; &#123;</span><br><span class="line">public T data;</span><br><span class="line">public Node(T data) &#123; this.data = data; &#125;</span><br><span class="line">  public void setData(T data) &#123;</span><br><span class="line">      System.out.println(&quot;Node.setData&quot;);</span><br><span class="line">      this.data = data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class MyNode extends Node&lt;Integer&gt; &#123;</span><br><span class="line">public MyNode(Integer data) &#123; super(data); &#125;</span><br><span class="line">  public void setData(Integer data) &#123;</span><br><span class="line">      System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">      super.setData(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类型擦除后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Node &#123;</span><br><span class="line">  public Object data;</span><br><span class="line">  public Node(Object data) &#123; this.data = data; &#125;</span><br><span class="line">  public void setData(Object data) &#123;</span><br><span class="line">      System.out.println(&quot;Node.setData&quot;);</span><br><span class="line">      this.data = data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyNode extends Node &#123;</span><br><span class="line">  public MyNode(Integer data) &#123; super(data); &#125;</span><br><span class="line">  public void setData(Integer data) &#123;</span><br><span class="line">      System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">      super.setData(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>擦除后setData方法不能覆盖父类的setData方法，为了保持泛型类型在擦除后的多态特性，java编译器自动生成桥接方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class MyNode extends Node &#123;</span><br><span class="line">  //桥接方法</span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        setData((Integer) data);</span><br><span class="line">    &#125;</span><br><span class="line">    public void setData(Integer data) &#123;</span><br><span class="line">        System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">        super.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="泛型的限制"><a href="#泛型的限制" class="headerlink" title="泛型的限制"></a>泛型的限制</h4><h5 id="不能使用基本类型实例化泛型类型"><a href="#不能使用基本类型实例化泛型类型" class="headerlink" title="不能使用基本类型实例化泛型类型"></a>不能使用基本类型实例化泛型类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;int, char&gt; p = new Pair&lt;&gt;(8, &apos;a&apos;);//error</span><br><span class="line">Pair&lt;Integer, Character&gt; p = new Pair&lt;&gt;(8, &apos;a&apos;);// 8，&apos;a&apos;会自动装箱</span><br></pre></td></tr></table></figure>
<h5 id="不能创建类型参数的实例"><a href="#不能创建类型参数的实例" class="headerlink" title="不能创建类型参数的实例"></a>不能创建类型参数的实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void append(List&lt;E&gt; list) &#123;</span><br><span class="line">  E elem = new E();  // compile-time error</span><br><span class="line">  list.add(elem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static &lt;E&gt; void append(List&lt;E&gt; list, Class&lt;E&gt; cls) throws Exception &#123;</span><br><span class="line">  E elem = cls.newInstance();   // 反射可以实现</span><br><span class="line">  list.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="不能声明类型为类型参数的静态字段"><a href="#不能声明类型为类型参数的静态字段" class="headerlink" title="不能声明类型为类型参数的静态字段"></a>不能声明类型为类型参数的静态字段</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class MobileDevice&lt;T&gt; &#123;</span><br><span class="line">  private static T os;//编译错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为静态字段是所有类的实例共享，多个实例实例化时传入不同的T类型，则无法确定os字段属于哪一个类型。</p>
<h5 id="针对参数化类型不能使用cast或instanceof"><a href="#针对参数化类型不能使用cast或instanceof" class="headerlink" title="针对参数化类型不能使用cast或instanceof"></a>针对参数化类型不能使用cast或instanceof</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void rtti(List&lt;E&gt; list) &#123;</span><br><span class="line">  if (list instanceof ArrayList&lt;Integer&gt;) &#123; //编译错误</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void rtti(List&lt;?&gt; list) &#123;</span><br><span class="line">  if (list instanceof ArrayList&lt;?&gt;) &#123;  // 无界通配符OK; instanceof需要一个具体化的类型</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; li = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Number&gt;  ln = (List&lt;Number&gt;) li;  //编译错误</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; l1 = ...;</span><br><span class="line">ArrayList&lt;String&gt; l2 = (ArrayList&lt;String&gt;)l1;  // OK</span><br></pre></td></tr></table></figure>
<h5 id="不能创建参数化的数组类型"><a href="#不能创建参数化的数组类型" class="headerlink" title="不能创建参数化的数组类型"></a>不能创建参数化的数组类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt;[] arrayOfLists = new List&lt;Integer&gt;[2];  //编译错误，数组声明时需要具体化的类型</span><br></pre></td></tr></table></figure>
<h5 id="不能创建、捕获、抛出序列化类型的对象"><a href="#不能创建、捕获、抛出序列化类型的对象" class="headerlink" title="不能创建、捕获、抛出序列化类型的对象"></a>不能创建、捕获、抛出序列化类型的对象</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 不能隐式地继承Throwable</span><br><span class="line">class MathException&lt;T&gt; extends Exception &#123;  &#125;    // compile-time error</span><br><span class="line"></span><br><span class="line">// 不能显式地继承Throwable</span><br><span class="line">class QueueFullException&lt;T&gt; extends Throwable &#123; &#125; // compile-time error</span><br><span class="line"></span><br><span class="line">// 不能创建类型参数的实例</span><br><span class="line">public static &lt;T extends Exception, J&gt; void execute(List&lt;J&gt; jobs) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">      for (J job : jobs)</span><br><span class="line">          // ...</span><br><span class="line">  &#125; catch (T e) &#123;   // compile-time error</span><br><span class="line">      // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">可以在throws子句中使用类型参数</span><br><span class="line">class Parser&lt;T extends Exception&gt; &#123;</span><br><span class="line">  public void parse(File file) throws T &#123;     // OK</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="形式类型参数擦除后类型一样的不能重载"><a href="#形式类型参数擦除后类型一样的不能重载" class="headerlink" title="形式类型参数擦除后类型一样的不能重载"></a>形式类型参数擦除后类型一样的不能重载</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">  public void print(Set&lt;String&gt; strSet) &#123; &#125;</span><br><span class="line">  public void print(Set&lt;Integer&gt; intSet) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="非具体化类型"><a href="#非具体化类型" class="headerlink" title="非具体化类型"></a>非具体化类型</h4><p> 具体化类型是指运行时完全可以获取到其类型信息的类型，如基本类型、非泛型类型、裸（原始）类型、或者无界通配符的调用。<br> 非具体化类型是指编译时类型信息被擦除,如泛型类型的调用（无界通配符除外），非具化类型运行时没有足够的类型信息。如JVM运行时无法区分List<string>、List<integer>。非具化类型不能用于：instaceof表达式、或者作为数组的元素。</integer></string></p>
<h5 id="堆污染"><a href="#堆污染" class="headerlink" title="堆污染"></a>堆污染</h5><p>当参数化类型的变量引用非参数化类型的对象时，就会发生堆污染。在编译或运行时如果无法验证包含参数话类型当操作如转换、调用的正确性，就会报未经检查的警告，需要引起注意。</p>

        
        <br>
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
