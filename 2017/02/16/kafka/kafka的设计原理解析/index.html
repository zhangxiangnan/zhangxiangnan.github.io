<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="一块学习">
    <meta name="keyword" content="undefined">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        kafka的设计原理解析 - 张向南的博客 | zhangxiangnan&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> progress everyday </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.png">
        </div>
        <div class="name">
            <i>zhangxiangnan</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li>
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li>
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#kafka的设计目标"><span class="toc-text">kafka的设计目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#持久性"><span class="toc-text">持久性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#文件系统性能并不差"><span class="toc-text">文件系统性能并不差</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常量级别时间"><span class="toc-text">常量级别时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO优化提升效率"><span class="toc-text">IO优化提升效率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#端到端的批量消息压缩End-to-end-Batch-Compression"><span class="toc-text">端到端的批量消息压缩End-to-end Batch Compression</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生产者"><span class="toc-text">生产者</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#负载均衡"><span class="toc-text">负载均衡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#异步发送"><span class="toc-text">异步发送</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#消费者"><span class="toc-text">消费者</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#推或者拉"><span class="toc-text">推或者拉</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input">
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> progress everyday </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        kafka的设计原理解析
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2017-02-16 16:03:01</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#kafka" title="kafka">kafka</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>

    </div>
    <div class="post-content ">
        <p>kafka的设计原理解析，其设计目标，及其为了这个目标作出的设计方案<br><a id="more"></a></p>
<h3 id="kafka的设计目标"><a href="#kafka的设计目标" class="headerlink" title="kafka的设计目标"></a>kafka的设计目标</h3><p>Kafka 的定位是作为一个统一的处理实时数据流的平台，其必须能够处理一个「大公司」每天可能产生的消息量级。因此，在设计之初 Kafka 就考虑要满足多样的应用场景：</p>
<ul>
<li>高吞吐量：必须具有高吞吐量以便支持大容量事件流，如实时日志聚合服务</li>
<li>加载离线数据：必须能够支持优雅地处理大数据量的backlog积压，以便能够支持来自离线系统的定期数据加载</li>
<li>低延迟：必须能够处理低延迟的消息传递应用以便支持更多的传统的消息系统的使用场景</li>
<li>最好能够支持对订阅源的分区、分布式、及实时处理，并产生新的派生订阅源，这促使产生了kafka的分区和消费者模型</li>
<li>高可用性：在流数据被馈送到其他数据系统用于服务的场景中，需要在机器故障时支持容错</li>
</ul>
<p>为了支持上述的场景，设计了一些独特的元素，类似于数据库日志，而非传统的消息系统。</p>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><h4 id="文件系统性能并不差"><a href="#文件系统性能并不差" class="headerlink" title="文件系统性能并不差"></a>文件系统性能并不差</h4><p>kafka在存储和缓存消息上很大程度上依赖了文件系统。有个普遍的观念认为硬盘很慢，这让人觉着基于硬盘的持久性结构设计是不是能提供高性能。实际上恰当设计的硬盘结构通常可以和网络一样快。<br>影响硬盘性能的关键事实是随着过去十年的磁盘寻道耗费的延迟的大幅缩小，硬盘驱动器的吞吐量大幅提升，在具有六个7200rpm SATA RAID-5阵列的JBOD配置上线性写入的性能约为600MB/s，但随机写入性能仅为100k/s，相差超过6000倍。这些现行读取和写入是左右使用模式中最可预测的，操作系统也对此进行了大量优化。现代操作系统提供预读和后写技术，以大块多次预取数据并将较小的逻辑写入分组为大型物理写入。有些情况下的硬盘顺序访问可能比内存的随机访问更快。</p>
<p><img src="http://deliveryimages.acm.org/10.1145/1570000/1563874/jacobs3.jpg" alt="jacobs3"></p>
<h4 id="常量级别时间"><a href="#常量级别时间" class="headerlink" title="常量级别时间"></a>常量级别时间</h4><p>消息系统中使用的持久化数据结构通常是跟BTree或者其他通用用途的随机访问数据结构每个消费者一个队列来维护消息的元数据信息。Btrees是可用的最通用的数据结构，并且使得可以在消息队列中支持各种各样的事务和非事务的语义。同时也带来了相当高的成本，Btree操作时间复杂度为O(log N)。通常O(log N)被认为基本上等同于恒定时间，但是这不适用于磁盘操作。磁盘一次寻道需要10ms，并且一次只能寻一个，因此并行化受限。因此即使少量的磁盘也导致很高的开销。</p>
<p>Kafka 采用 log append 的方式写磁盘，可以为消息的读写操作提供 O(1)的复杂度，并且读写互相不会 block 其他操作。由于读写操作的复杂度和数据量无关，使得 Kafka 可以运行在普通机器组成的集群中，每台 server 所能存储的消息量也非常大。<br>这同时带来了另外一些便利，与其他消息系统在消息被消费后即删除的方式不同，kafka 可以将消息保存较长的一段时间，为 Consumer 带来很大的灵活性。</p>
<h3 id="IO优化提升效率"><a href="#IO优化提升效率" class="headerlink" title="IO优化提升效率"></a>IO优化提升效率</h3><p>我们已经付出了很大努力来提高效率。 我们的主要用例之一是处理网络活动数据，这是非常高的量：每个页面视图可能会生成几十个写入。 此外，我们假设每个发布的消息由至少一个消费者（通常很多）阅读，因此我们努力使消费尽可能廉价。</p>
<p>从以往构建和运行类似多个系统的经验看来，我们发现，对于有效地多租户操作效率是关键。如果下游基础设施服务在应用程序使用中由于小的突变很容易成为瓶颈，那么这样的变化总会产生问题。如果性能很快，便有助于确保应用程序不会由于基础设施的小问题而产生故障。这对于在中央集群上运行支持几十或上百的应用程序的集中式服务时特别重要，因为使用方式的变化几乎每天都发生。</p>
<p>上述讨论消除了不良的磁盘访问模式，对于这类系统仍有两个常见的效率低下的原因：太多的小I/O操作，太多的字节复制操作。<br>小的I/O问题在客户端和服务端以及服务端自身的持久化操作都有发生。<br>为了避免这个问题，Kafka使用的协议构建于一种自然地将消息分组到一起的“消息集”的抽象。这允许网络请求将消息分组到一起，而不是一次发送一条消息，缓冲了网络往返的开销。服务器则一次性将消息块追加到log文件中，客户端也一次性抓取大的连续消息块。</p>
<p>这个简单的优化产生数量级的速度。 批处理导致更大的网络包，更大的顺序磁盘操作，连续的内存块等等，所有这些都允许Kafka将随机消息写入的突发流转换为流向消费者的线性写入</p>
<p>另一个效率低下的地方是字节复制。消息比较少时不是问题，但是一旦负载升高，影响就很大。为了避免这个问题，Kafka采取生产者、代理broker服务器、消费者共享的标准二进制格式（这样数据块无需更改便可在三者间传递）。<br>代理服务器维护的消息日志本身就是一个文件组成的目录，每个文件由生产者和消费者共同使用的格式已经写入到磁盘的一系列消息集组成。维护这种通用格式有助于优化最重要的操作：持久日志块的网络传输。现代Unix操作系统提供了高度优化的代码用来将数据从页高速缓冲存储器传输到socket；Linux里则通过sendfile系统调用完成。</p>
<p>为了理解sendfile的影响，有必要理解数据从文件传递到socket几个常见步骤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 操作系统将数据从磁盘读入到内核空间的页高速缓存存储器</span><br><span class="line">- 应用程序将数据从内核空间读入到用户空间缓存区</span><br><span class="line">- 应用程序将数据写会到内核空间中的sokcet缓冲区</span><br><span class="line">- 操作系统从socket缓冲区复制数据到NIC缓冲区，并通过网络发送</span><br></pre></td></tr></table></figure></p>
<p>  <img src="https://www.ibm.com/developerworks/linux/library/j-zerocopy/figure1.gif" alt="copy"><br>  DMA copy:direct memory copy；直接内存访问</p>
<p>很显然，这种方式效率低下，有四次复制操作，两次系统调用。使用sendfile后，通过允许操作系统直接发送页缓存的数据到网络而避免重复拷贝的操作，仅仅只需要最后拷贝到NIC缓冲区的操作。</p>
<p>对于一个主题多个消费者的常见使用情形，使用上述的零拷贝优化，数据只有一次被拷贝到页缓存，每次消费都重复使用，而不是加载到内存里当每次读取的时候被复制到内核空间。这使得消息被消费的速率取决于网络连接的限制。<br>页缓存和sendfile的结合意味着消费者大多出现的集群上，你可能观察不到任何磁盘活动，因为都是从缓存提供数据。</p>
<p>更多Java对零拷贝的支持和sendfile的背景，看<a href="http://www.ibm.com/developerworks/linux/library/j-zerocopy" target="_blank" rel="noopener">http://www.ibm.com/developerworks/linux/library/j-zerocopy</a></p>
<h3 id="端到端的批量消息压缩End-to-end-Batch-Compression"><a href="#端到端的批量消息压缩End-to-end-Batch-Compression" class="headerlink" title="端到端的批量消息压缩End-to-end Batch Compression"></a>端到端的批量消息压缩End-to-end Batch Compression</h3><p>I在其他场景下，CPU、硬盘其实不是瓶颈，而是网络带宽。很常见的就是需要通过广域网在各个数据中心之间发送消息的数据流水线。当然，用户也总是可以一次压缩信息，而不需要Kafka的帮助，但这样的压缩比通常很低，因为大多数的冗余来自于相同类型的消息间的重复而不是单条消息本身(如，JSON中的字段名称，web日志中的用户代理，公共的字符串值. 高效的压缩需要一次压缩多条消息而不是每次只压缩一条消息。</p>
<p>Kafka允许通过遍历消息集来实现消息批量压缩。多条信息可以放到一起压缩，然后发送压缩后的内容到服务器。这些消息也会按着压缩的格式来写入，并在日志文件中保持压缩格式，并且只会由消费者解压缩。Kafka支持GZIP、Snappy、LZ4压缩协议，更多压缩细节见<a href="https://cwiki.apache.org/confluence/display/KAFKA/Compression" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/KAFKA/Compression</a></p>
<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>生产者直接发送数据到某分区的leader消息代理服务器，而不经过任何中间路由层。为了协助生产者实现这个功能，Kafka各个节点都能随时应答对于那些服务器存活、对于某个主题的所有分区leaders服务器地址的请求，协助生产者发送请求到恰当的服务器。</p>
<p>客户端控制着发布消息到哪一个分区，这可以通过随机、实现某种负载均衡的随机、某些语义层面的分区函数来实现。Kafka提供了语法上的分区接口，通过允许用户指定一个关键字分区，然后使用该接口hash到一个分区（如果有必要也可以选择重写分区函数）。例如，如果选择用户id作为关键字，这样对于指定用户的所有消息都被发送到相同分区中。 这反过来将允许消费者对他们的消费进行局部性假设。 这种分区风格被明确地设计为允许消费者进行对局部敏感的处理。</p>
<h4 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h4><p>批处理是效率的主要驱动因素之一，为了启用批处理，Kafka生产者将尝试在内存中累积数据，并在单个请求中发送更大的批次。 批处理可以配置为累积不超过固定数量的消息，并且等待不超过一定的固定等待时间（例如64k或10ms）。 这允许累积更多的字节发送，并且在服务器上几乎没有更大的I / O操作。 这种缓冲是可配置的，并且提供了一种机制来折衷少量的额外延迟以获得更好的吞吐量。</p>
<p>生产者配置见：<a href="https://kafka.apache.org/documentation/#producerconfigs" target="_blank" rel="noopener">https://kafka.apache.org/documentation/#producerconfigs</a><br>api细节：<a href="http://kafka.apache.org/082/javadoc/index.html?org/apache/kafka/clients/producer/KafkaProducer.html" target="_blank" rel="noopener">http://kafka.apache.org/082/javadoc/index.html?org/apache/kafka/clients/producer/KafkaProducer.html</a></p>
<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>Kafka通过向Kafka服务器发送提取请求，来获取它想要消费的消息所在分区的leader地址。消费者在每次请求中指定日志中消息的偏移量，然后获取到一个从那个位置开始的日志块。这样消费者拥有对消费消息位置的控制权，如果有需要还能够重设其值来重复消费数据。</p>
<h4 id="推或者拉"><a href="#推或者拉" class="headerlink" title="推或者拉"></a>推或者拉</h4><p>kafka考虑的一个问题：是否消费者应该从服务器拉取数据还是服务器应该推送数据到消费者。在这个角度，Kafka遵循了一个更加传统的设计，也是大多数消息系统使用的 ，生产者发送数据到服务器，消费者从服务器拉取数据。一些集中式日志系统，如Scribe、Apache Flume，遵循的是一种非常不同的基于推的数据推送到下游的思路。两种设计各有利弊，基于推的系统不好应对多样化的消费者，因为服务器控制数据传输的速率。而通常的目标则是让消费者以自己最大的消费速率来消费数据；不幸的是，在推送的系统中，当消费速率跟不上生产速率时，消费者往往被压制（类似于消费者被攻击）。一个基于拉的系统有更好的性能，消费者只是简单的落后于生产者，在可能的时候赶上.</p>

        
        <br>
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
