<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="一块学习">
    <meta name="keyword" content="undefined">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        java注解详解 - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> progress everyday </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.png">
        </div>
        <div class="name">
            <i>zhangxiangnan</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li>
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li>
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#注解基本点"><span class="toc-text">注解基本点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#注解的形式"><span class="toc-text">注解的形式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#注解可以用在哪儿"><span class="toc-text">注解可以用在哪儿</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#类型注解"><span class="toc-text">类型注解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#定义注解类型"><span class="toc-text">定义注解类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#已有注解类型"><span class="toc-text">已有注解类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java语言使用的注解"><span class="toc-text">java语言使用的注解</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Deprecated"><span class="toc-text">@Deprecated</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Override"><span class="toc-text">@Override</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#SuppressWarnings"><span class="toc-text">@SuppressWarnings</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#SafeVarargs"><span class="toc-text">@SafeVarargs</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#FunctionalInterface"><span class="toc-text">@FunctionalInterface</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#应用到其他注解的注解"><span class="toc-text">应用到其他注解的注解</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Retention"><span class="toc-text">@Retention</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Documented"><span class="toc-text">@Documented</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Target"><span class="toc-text">@Target</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Inherited"><span class="toc-text">@Inherited</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Repeatable"><span class="toc-text">@Repeatable</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类型注解-amp-可插拔类型系统"><span class="toc-text">类型注解&amp;可插拔类型系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可重复注解"><span class="toc-text">可重复注解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#重新获取注解"><span class="toc-text">重新获取注解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#设计考虑"><span class="toc-text">设计考虑</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input">
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> progress everyday </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        java注解详解
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2018-01-05 19:16:57</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#注解" title="注解">注解</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>

    </div>
    <div class="post-content ">
        <p>java注解学习</p>
<a id="more"></a>
<p>注解是元数据的一种形式,提供程序相关的数据,但不是程序本身的一部分,注解不会直接操作他们所标注的代码。</p>
<p>注解有很多用途:</p>
<pre><code>- 编译器所需的信息,如编译器可以用注解来检测错误或禁止警告
- 编译时或发布时处理,如软件工具可以处理注解信息来生成代码、xml文件等
- 运行时处理,某些注解在运行时也可以检测到
</code></pre><h4 id="注解基本点"><a href="#注解基本点" class="headerlink" title="注解基本点"></a>注解基本点</h4><h5 id="注解的形式"><a href="#注解的形式" class="headerlink" title="注解的形式"></a>注解的形式</h5><p>最简单的:</p>
<pre><code>@Entity
</code></pre><p>@符号后的信息对编译器表明这是一个注解。</p>
<p>以下注解的名称是Override:</p>
<pre><code>@Override
void mySuperMethod() {  }
</code></pre><p>注解也可以包含元素,元素可以有名称,也可以没有名称,他们也有对应的值:</p>
<pre><code>@Author(
   name = &quot;Benjamin Franklin&quot;,
   date = &quot;3/27/2003&quot;
)
class MyClass() { }

@SuppressWarnings(value = &quot;unchecked&quot;)
void myMethod() { }
</code></pre><p>如果只有一个命为value的元素,那么名称可以省略,如:</p>
<pre><code>@SuppressWarnings(&quot;unchecked&quot;)
void myMethod() {}
</code></pre><p>如果注解没有元素,那么圆括号可以省略,如@Override注解的例子。</p>
<p>在相同声明的位置可以使用多个注解:</p>
<pre><code>@Author(name = &quot;Jane Doe&quot;)
@EBook
class MyClass { }
</code></pre><p>如果注解有相同的类型,称为可重复注解(&gt;=Jdk8):</p>
<pre><code>@Author(name = &quot;Jane Doe&quot;)
@Author(name = &quot;John Smith&quot;)
class MyClass { }
</code></pre><p>注解可以使用java.lang或java.lang.annotation包下定义的注解,也可以使用自定义注解。</p>
<h5 id="注解可以用在哪儿"><a href="#注解可以用在哪儿" class="headerlink" title="注解可以用在哪儿"></a>注解可以用在哪儿</h5><p>注解可以用在声明的地方:</p>
<pre><code>- 类/接口(含注解类型)/枚举声明
- 方法声明
- 字段(含枚举常量)声明
- 形参声明
- 构造函数声明
- 本地变量声明
- 注解类型声明
- 包声明
- 类型参数声明
- 类型的使用
</code></pre><p>使用时注解约定占一行。</p>
<h5 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h5><p>Java8中支持类型使用的注解,称为类型注解,如:<br>实例化对象的表达式:</p>
<pre><code>new @Interned MyObject();
</code></pre><p>类型强转:</p>
<pre><code>myString = (@NonNull String) str;
</code></pre><p>implements子句:</p>
<pre><code>class UnmodifiableList&lt;T&gt; implements
    @Readonly List&lt;@Readonly T&gt; {  }
</code></pre><p>异常声明:</p>
<pre><code>void monitorTemperature() throws
    @Critical TemperatureException {  }
</code></pre><h4 id="定义注解类型"><a href="#定义注解类型" class="headerlink" title="定义注解类型"></a>定义注解类型</h4><p>注解可以替换注释为代码,设想:</p>
<pre><code>public class Generation3List extends Generation2List {
   // Author: John Doe
   // Date: 3/17/2002
   // Current revision: 6
   // Last modified: 4/12/2004
   // By: Jane Doe
   // Reviewers: Alice, Bill, Cindy
   // class code goes here
}
</code></pre><p>将这些注释信息如何转化为一个注解?首先必须定一个注解类型,如下:</p>
<pre><code>@interface ClassPreamble {
   String author();
   String date();
   int currentRevision() default 1;
   String lastModified() default &quot;N/A&quot;;
   String lastModifiedBy() default &quot;N/A&quot;;
   // Note use of array
   String[] reviewers();
}
</code></pre><p>注解类型的定义有点像接口的声明,但是在interface关键字前加@符号。注解是接口的一种形式,其元素的声明像方法,可以指定默认值。</p>
<pre><code>@ClassPreamble (
   author = &quot;John Doe&quot;,
   date = &quot;3/17/2002&quot;,
   currentRevision = 6,
   lastModified = &quot;4/12/2004&quot;,
   lastModifiedBy = &quot;Jane Doe&quot;,
   // Note array notation
   reviewers = {&quot;Alice&quot;, &quot;Bob&quot;, &quot;Cindy&quot;}
)
public class Generation3List extends Generation2List {}
</code></pre><p>注意:如果想在Javadoc生成的文档中包含@ClassPreamble中描述的信息,需要在其注解的定义上加@Documented注解。</p>
<pre><code>@Documented
@interface ClassPreamble {
}
</code></pre><h4 id="已有注解类型"><a href="#已有注解类型" class="headerlink" title="已有注解类型"></a>已有注解类型</h4><p>Java预先定义了一些注解,有些被java编译器使用,有些应用到其他注解中。</p>
<h5 id="java语言使用的注解"><a href="#java语言使用的注解" class="headerlink" title="java语言使用的注解"></a>java语言使用的注解</h5><p>java.lang定义的注解为:@Deprecated, @Override, and @SuppressWarnings.</p>
<h6 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h6><p>该注解表明被标注的元素已过时,不该再被使用。使用有过时注解标注的方法、类、字段,编译器都会警告。如果元素过时,也应该使用Javadc的过时标记@deprecated来标注,两个注解一个大写,一个小写。</p>
<pre><code>// Javadoc comment follows
 /**
  * @deprecated
  * explanation of why it was deprecated
  */
 @Deprecated
 static void deprecatedMethod() { }
</code></pre><h6 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h6><p>@Override注解通知编译器被标注元素覆盖了父类的元素:</p>
<pre><code>// 重写方法约定加覆盖注解
@Override
int overriddenMethod() { }
</code></pre><p>虽然不强制使用覆盖标记,但是使用了有助于发现错误。</p>
<h6 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h6><p>@SuppressWarnings注解告诉编译器忽略可能产生的某种特定的警告,如下忽略了过时方法调用警告:</p>
<pre><code>@SuppressWarnings(&quot;deprecation&quot;)
 void useDeprecatedMethod() {
     // deprecation warning
     // - suppressed
     objectOne.deprecatedMethod();
 }
</code></pre><p>每一种编译器警告都属于一个分类,java语言规范定义了2中分类:deprecation and unchecked. 想要忽略多种分类的警告,如下:</p>
<pre><code>@SuppressWarnings({&quot;unchecked&quot;, &quot;deprecation&quot;})
</code></pre><h6 id="SafeVarargs"><a href="#SafeVarargs" class="headerlink" title="@SafeVarargs"></a>@SafeVarargs</h6><p>@SafeVarargs注解当使用在方法或构造函数上时,断言了代码不可能对可变参数执行潜在的不安全操作。当使用该注解后,跟可变参数使用相关的unchecked警告会被忽略。</p>
<h6 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="@FunctionalInterface"></a>@FunctionalInterface</h6><p>@FunctionalInterface在java8中引入,表明当前类型声明是一个函数接口。</p>
<h5 id="应用到其他注解的注解"><a href="#应用到其他注解的注解" class="headerlink" title="应用到其他注解的注解"></a>应用到其他注解的注解</h5><p>这类注解成为元注解, java.lang.annnotation中定义的几个元注解如下:</p>
<h6 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h6><p>@Retention注解指明了被标记注解如何存储:</p>
<pre><code>- RetentionPolicy.SOURCE, 被标记注解仅仅在源文件级别保留,编译时被忽略
- RetentionPolicy.CLASS ,被标记注解在编译时被编译器保留,但是在JVM运行时被忽略
- RetentionPolicy.RUNTIME ,被标记注解被jvm保留,在运行时环境中可以使用
</code></pre><h6 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h6><p>@Documented注解表示被标注的注解在使用Javadoc工具生成文档时会被记录到文档中,默认注解是不被记录的。</p>
<h6 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h6><p>@Target注解标记其他注解来限制注解可以应用的java元素,如:</p>
<pre><code>- ElementType.CONSTRUCTOR 可应用到构造函数上
- ElementType.FIELD 可应用到字段或属性上
- ElementType.LOCAL_VARIABLE 可应用到本地变量上
- ElementType.METHOD 可应用到方法级别的注解上
- ElementType.PACKAGE 可应用到包声明上
- ElementType.PARAMETER 可应用到方法的参数上
- ElementType.TYPE 可应用到类的任何元素上
</code></pre><h6 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h6><p>@Inherited表示注解可以从父类继承,默认不可以。 当用户查询注解类型时,若当前类没有该类型的注解,会接着查询父类的该注解。该注解只可用于类声明上。</p>
<h6 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h6><p>@Repeatable在java8引入,表示被标记注解可以多次应用到相同声明或类型使用</p>
<h4 id="类型注解-amp-可插拔类型系统"><a href="#类型注解-amp-可插拔类型系统" class="headerlink" title="类型注解&amp;可插拔类型系统"></a>类型注解&amp;可插拔类型系统</h4><p>Jdk8以前,注解只能应用在声明上,jdk8里注解可以应用到任何类型使用上,这意味着可以在你使用一个类型的任何地方使用。<br>类型注解引入是为了提升java程序的分析来提供更强的类型检查,java8不提供类型检查框架,但是它允许我们来使用多个可插拔类型检查框架来配合java编译器进行更强大的类型检查。</p>
<p>如,想要确保某一个特定的变量不能被赋值为null,来避免NPE异常的话,可以编写一个自定义插件来检查这一点,类似如下:</p>
<pre><code>@NonNull String str;
</code></pre><p>可以加载多种插件来加强类型检查,减少错误。</p>
<h4 id="可重复注解"><a href="#可重复注解" class="headerlink" title="可重复注解"></a>可重复注解</h4><p>有些情形可能想要使用相同的注解多次,java8引入类型注解。<br>如想要定义多个时间点执行方法,如下:</p>
<pre><code>@Schedule(dayOfMonth=&quot;last&quot;)
@Schedule(dayOfWeek=&quot;Fri&quot;, hour=&quot;23&quot;)
public void doPeriodicCleanup() { }
</code></pre><p>可重复注解可以在任何使用标准注解的地方使用,如也可在类声明上使用,如:</p>
<pre><code>@Alert(role=&quot;Manager&quot;)
@Alert(role=&quot;Administrator&quot;)
public class UnauthorizedAccessException extends SecurityException { }
</code></pre><p>为了兼容,可重复注解保存在java编译器自动生成的注解容器里,需要以下两步声明:</p>
<ul>
<li><p>一是定义可重复注解:</p>
<pre><code>import java.lang.annotation.Repeatable;
@Repeatable(Schedules.class)
public @interface Schedule {
  String dayOfMonth() default &quot;first&quot;;
  String dayOfWeek() default &quot;Mon&quot;;
  int hour() default 12;
}
</code></pre><p>  @Repeatable元注解圆括号里定义的是注解容器的类型,java编译器用来存储可重复注解。</p>
<p>  这个例子里,注解容器是Scheudles,所以可重复注解@Schedule存储在@Schedules注解里。</p>
</li>
<li><p>二是声明容器枚举类型</p>
<p>  容器枚举类型必须有一个数组类型的元素,数组的数据类型必须是可重复注解的类型,如:</p>
<pre><code>public @interface Schedules {
    Schedule[] value();
}
</code></pre></li>
</ul>
<h5 id="重新获取注解"><a href="#重新获取注解" class="headerlink" title="重新获取注解"></a>重新获取注解</h5><p>反射API中有几个方法可用来获取注解信息,返回一个单独注解的方法,如AnnotatedElement.getAnnotation(Class<t>)的行为不变,因为仅仅返回请求类型的一个注解(如果存在),如果请求类型存在多个注解,可以先得到其容器注解。</t></p>
<p>java8也引入其他方法来遍历容器注解来一次获取多个注解,如AnnotatedElement.getAnnotationsByType(Class<t>)。</t></p>
<h5 id="设计考虑"><a href="#设计考虑" class="headerlink" title="设计考虑"></a>设计考虑</h5><p>当设计注解类型时,必须考虑注解类型的使用次数,因为有了可重复注解,可使用多次;也可以通过@Target元注解来限制注解的使用元素范围。</p>
<p>总之,要让使用者使用起来尽可能灵活、强大。</p>

        
        <br>
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
