<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张向南的博客 | zhangxiangnan&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/8b49612074cca29633fcf2c5a21f5185</icon>
  <subtitle>progress everyday</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhangxiangnan.com/"/>
  <updated>2019-07-05T09:18:21.000Z</updated>
  <id>http://zhangxiangnan.com/</id>
  
  <author>
    <name>zhangxiangnan</name>
    <email>1194256997@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java中的异步计算学习</title>
    <link href="http://zhangxiangnan.com/2019/07/05/java/java%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0/"/>
    <id>http://zhangxiangnan.com/2019/07/05/java/java中的异步计算学习/</id>
    <published>2019-07-05T11:56:39.000Z</published>
    <updated>2019-07-05T09:18:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Runnable接口"><a href="#Runnable接口" class="headerlink" title="Runnable接口"></a>Runnable接口</h3><ul><li>不返回任务结果</li><li>不抛出受检异常</li><li>函数接口，抽象run方法</li></ul><h3 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h3><ul><li>返回结果</li><li>抛出受检异常</li><li>函数接口，call方法</li></ul><h3 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h3><p>对Runnable、Callable进行封装.</p><p>功能：</p><ul><li>可以取消任务（任务未结束或者未被取消）</li><li>可以获取任务执行结果（可以重复获取）</li></ul><p>主要方法：</p><ul><li>boolean cancel(boolean myaInterruptIfRunning)<ul><li>如果任务已经完成或者已经被取消或者因为某些原因(通常是已经执行完成)无法取消则返回取消失败；</li><li>如果取消时任务已经开始，可以通过参数决定是否中断任务；</li><li>如果取消时任务未开始则永不会开始</li><li>该方法调用后，后续调用isDone方法总返回true，后续调用isCancelled方法如果当前返回true则总返回为true</li></ul></li><li>boolean isCancelled()  返回在任务执行完成前是否被取消</li><li>boolean isDone() 返回任务是否结束，包括正常结束、异常、被取消都是结束，返回true</li><li>V get() throws InterruptedException, ExecutionException; 阻塞调用线程，直到任务执行完毕返回结果，如果任务已完毕则直接返回结果</li><li>V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; 阻塞调用线程，直到任务返回结果或者等待时间结束</li></ul><h4 id="ListenableFuture-guava"><a href="#ListenableFuture-guava" class="headerlink" title="ListenableFuture(guava)"></a>ListenableFuture(guava)</h4><p>继承自Future，增加了addListener(Runnable listener, Excutor executor)接口，可以注册指定的listener监听器到指定线程池执行</p><ul><li>MoreExecutors.listeningDecorator将ExecutorService转为ListeningExecutorService或者通过SettableFuture</li><li>不确保执行顺序按添加顺序</li><li>确保每一个监听器会被执行</li></ul><h4 id="SettableFuture"><a href="#SettableFuture" class="headerlink" title="SettableFuture"></a>SettableFuture</h4><p>继承自AbstractFuture，可以设置结果，结果一旦被设置完成，则立即唤醒等待线程</p><h4 id="ScheduledFuture"><a href="#ScheduledFuture" class="headerlink" title="ScheduledFuture"></a>ScheduledFuture</h4><p>可以取消的延迟结果，通常适用于ScheduledExecutorService</p><h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><p>实现了Future接口、Runnable接口，可以获取结果、取消任务、超时等待，任务不可以重复执行（除非使用runAndReset()）</p><p>状态转换如下：</p><ul><li>新建-&gt;执行中-&gt;正常结束</li><li>新建-&gt;执行中-&gt;异常结束</li><li>新建-&gt;被取消</li><li>新建-&gt;中断中-&gt;被中断结束</li></ul><p>实现机制：通过CAS保证多线程操作的安全结合LockSupport实现线程间通信</p><h4 id="ListenFutureTask"><a href="#ListenFutureTask" class="headerlink" title="ListenFutureTask"></a>ListenFutureTask</h4><p>可以添加监听器的FutureTask</p><h3 id="CompletionService-amp-ExecutorCompletionService"><a href="#CompletionService-amp-ExecutorCompletionService" class="headerlink" title="CompletionService &amp; ExecutorCompletionService"></a>CompletionService &amp; ExecutorCompletionService</h3><h3 id="CompletionStage"><a href="#CompletionStage" class="headerlink" title="CompletionStage"></a>CompletionStage</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>执行一个动作或者当另一个阶段完成时计算一个值的异步阶段，一个阶段当计算结束时就结束，或者触发其他依赖的阶段执行。</p><p>使用方式：</p><ul><li>stage执行的计算形式可以是Function、Consumer、Runnable，对应方法包含apply、accept、run，具体使用哪个取决于是否有入参及是否有返回结果决定;compose组合形式组合的是stag的funciton形式</li><li>一个stage的执行可能通过另一个阶段的执行完成、或者两个阶段的执行完成、或者两个阶段中的一个执行完成（不确保哪个执行完成）.</li><li>阶段的执行可以同步执行，可以在默认fork/join线程池执行，也可以在指定线程池执行</li><li>一个stag异常结束，其他依赖的stag也异常结束；一个stag A同时依赖2个stag，且都异常结束，则A以依赖的两个中的一个异常结束；一个stag B依赖其余2个依赖的一个，其中一个异常，一个正常结束，则B不确定是正常还是异常结束</li></ul><h4 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h4><ul><li>当前stag正常执行结束的结果为入参，计算后返回新的stag<ul><li>thenApply(Function) 当前线程同步计算，其他方法类似</li><li>thenApplyAsync(Function) 默认线程池异步计算 其他方法类似</li><li>thenApplyAsync(Function, Executor) 指定线程池异步计算  其他方法类似，后续不再单独列</li></ul></li><li>当前stag正常执行结束的结果为入参，计算后返回Void<ul><li>thenAccept(Consumer)</li><li>thenAcceptAsync</li></ul></li><li>当前stag正常执行后，执行指定逻辑返回新stag<ul><li>thenRun(Runnable)</li><li>thenRunAsync(Runnable)</li></ul></li><li>当前stag正常执行执行结束后，将stag作为入参，计算指定逻辑后返回新stag；组合，并行执行，用于结果汇总计算<ul><li>thenCompose(Function)</li><li>thenComposeAsync</li></ul></li><li>当前stag和另一个stag都正常执行结束后的结果作为入参，计算后返回新的stag<ul><li>thenCombine(CompletionStage, BiFunction)</li><li>thenCombineAsync</li></ul></li><li>当前stag和另一个stag都正常执行结束后的结果作为入参，计算后返回Void<ul><li>thenAcceptBoth(CompletionStag, BiConsumer)</li><li>thenAcceptBothAsync</li></ul></li><li>当前stag和另一个stag都正常执行结束后，执行指定的计算<ul><li>runAfterBoth(CompletionStage, Runnable)</li><li>runAfterBothAsync</li></ul></li><li>当前stag和另一个stag任意一个正常执行结束后的结果为入参，计算后返回新stag<ul><li>applyToEither(CompletionStage, Function)</li><li>applyToEitherAsync</li></ul></li><li>当前stag和另一个stag任意一个正常执行结束后的结果为入参，计算后返回新stag<ul><li>acceptEither(CompletionStage, Consumer)</li><li>acceptEitherAsync</li></ul></li><li>当前stag和另一个stag任意一个正常执行结束后，执行指定计算<ul><li>runAfterEither(CompletionStage, Runnable)</li><li>runAfterEitherAsync</li></ul></li><li>当前stag正常执行结束的结果或发生异常时的异常作为入参，计算后返回新stag(新stag有和原stag一样的结果或者异常信息)<ul><li>exceptionally(Function&lt;Throwable, ? extends T&gt; fn)</li></ul></li><li>当前stag正常执行结束的结果或者发生异常时的异常作为入参，执行给定计算，返回新stag(新stag有和原stag一样的结果或者异常信息)<ul><li>whenComplete(BiConsumer)</li><li>whenCompleteAsync</li></ul></li><li>当前stag正常执行结束的结果或者发生异常时的异常作为入参，执行给定计算，返回新stag（其结果是计算后的结果）<ul><li>handle(BiFunction)</li><li>handleAsync</li></ul></li></ul><h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>一个未完成的异步事件继承Future、Completage接口，可以主动设置其结果和状态来显式完成该事件，也可以当做CompleteStage使用（计算执行结束触发依赖的函数或者计算）</p><p>相比于Future有以下优点：</p><ul><li>主动完成计算</li><li>回调</li><li>等待所有future完成计算</li><li>等待多个Future中最快完成的一个即返回结果</li><li>合成多个异步计算为一个，可能有相互依赖关系</li></ul><p>CompletableFuture实现CompletionStage，遵循以下原则：</p><ul><li>同步的方法执行线程可能是当前线程，或者其他调用completion方法的线程</li><li>所有的异步方法如果未指定线程池，默认使用ForkJoinPool.commonPool()，所有的异步任务都是CompletableFuture.AsynchronousCompletionTask的实例</li><li>所有覆盖CompletionStage的方法，都是独立于其他public方法</li></ul><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="CompletableFuture对象创建"><a href="#CompletableFuture对象创建" class="headerlink" title="CompletableFuture对象创建"></a>CompletableFuture对象创建</h5><ul><li>allOf(CompletableFuture) <ul><li>静态方法，当给定所有CompletableFuture完成时，返回的CompletableFuture也会结束；</li><li>如果给定的其中一个CompletableFuture计算异常，则返回的CompletableFuture也会异常结束;</li><li>返回的结果为Void</li><li>常用使用方式 CompletableFuture.allOf(xx).join();</li></ul></li><li>anyOf(CompletableFuture)<ul><li>任意一个future计算结束则返回的CompletableFuture计算结束（这些future有相同的返回结果）</li><li>如果一个异常，则返回的CompletableFuture异常</li></ul></li><li>无参及有参构造方法<br>创建未完成的CompletableFuture、完成的CompletableFuture</li><li>completedFuture方法<br>静态方法，创建一个已完成的</li><li>supplyAsync<br>在默认ForkJoinPool或指定线程池执行的异步任务，无入参，返回带返回结果的CompletableFuture</li><li>runAsync<br>在默认ForkJoinPool或指定线程池执行的异步任务，返回Void的CompletableFuture</li></ul><h5 id="CompletableFuture的状态判断-amp-获取结果"><a href="#CompletableFuture的状态判断-amp-获取结果" class="headerlink" title="CompletableFuture的状态判断&amp;获取结果"></a>CompletableFuture的状态判断&amp;获取结果</h5><ul><li>isDone<br>task是否结束，包括正常、异常、或取消</li><li>isCancelled<br>判断task是否在正常结束之前被取消</li><li>isCompletedExceptionally<br>判断task是否异常结束(被取消，显式异常结束，执行异常)</li><li>join<br>等待计算完成获取结果，可能会抛出执行及取消异常，等待不可中断</li><li>get<br>等待计算完成获取结果，可能抛出执行、取消、中断异常</li><li>get(timeout)<br>超时等待，可能抛出执行、取消、中断异常，等待时间按当前线程调用时的时间+等待时间</li><li>getNow<br>如果任务已完成，返回结果或异常；未完成则返回默认值</li></ul><h5 id="控制状态"><a href="#控制状态" class="headerlink" title="控制状态"></a>控制状态</h5><ul><li>cancel<br>如果任务还未计算完成，则取消任务（取消异常），依赖的CompletableFutures任务也会以取消异常结束；是否中断的入参没有作用。</li><li>complete<br>如果任务还未完成，主动完成计算，设置任务的结果来结束任务</li><li>completeExceptionally<br>如果任务还未完成，设置任务异常结束</li></ul><h5 id="结果转换-消费-组合"><a href="#结果转换-消费-组合" class="headerlink" title="结果转换/消费/组合"></a>结果转换/消费/组合</h5><ul><li>CompletableFuture + (Runnable/Consumer/Function)</li><li>CompletableFuture + CompletableFuture</li><li>CompletableFuture + 结果处理转换</li><li>thenCompose／thenComposeAsync</li></ul><h5 id="方法的规律总结"><a href="#方法的规律总结" class="headerlink" title="方法的规律总结"></a>方法的规律总结</h5><ul><li>async结尾的都是异步方法，可以用默认ForkJoinPool线程池或者指定线程池</li><li>run开头的方法，方法入参的lambda表达式为Runnable无入参，无返回结果</li><li>supply开头的方法，方法入参的lambda表达式为Supplier，无入参，有返回值</li><li>accept开头或结尾的方法，方法入参的lambda表达式为Consumer，有入参，无返回值</li><li>apply开头或结尾的方法，方法入参的lambda表达式为Function，有入参，有返回值</li><li>either结尾的方法，哪一个先完成先计算、消费或之后执行，参数类型需要一样</li></ul><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><h5 id="无入参执行异步计算返回结果"><a href="#无入参执行异步计算返回结果" class="headerlink" title="无入参执行异步计算返回结果"></a>无入参执行异步计算返回结果</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;supply&quot;);</span><br><span class="line">            return &quot;completeResult&quot;;</span><br><span class="line">        &#125;);</span><br><span class="line">        String result = future.get();</span><br><span class="line">        System.out.println(result);</span><br></pre></td></tr></table></figure><h5 id="等待所有CompletableFuture计算完毕后"><a href="#等待所有CompletableFuture计算完毕后" class="headerlink" title="等待所有CompletableFuture计算完毕后"></a>等待所有CompletableFuture计算完毕后</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;supply1&quot;);</span><br><span class="line">            return &quot;completeResult1&quot;;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;supply2&quot;);</span><br><span class="line">            return &quot;completeResult2&quot;;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;String&gt; future3 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;supply3&quot;);</span><br><span class="line">            return &quot;completeResult3&quot;;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        CompletableFuture.allOf(future1, future2, future3).join();// 等待所有future执行完毕</span><br><span class="line">//        CompletableFuture.allOf(future1, future2, future3).get();// 阻塞等待</span><br><span class="line">//        CompletableFuture.allOf(future1, future2, future3).get(3, TimeUnit.SECONDS);// 超时等待</span><br><span class="line">        System.out.println(future1.get());</span><br><span class="line">        System.out.println(future2.get());</span><br><span class="line">        System.out.println(future3.get());</span><br><span class="line">        System.out.println(&quot;final&quot;);</span><br></pre></td></tr></table></figure><h5 id="等待最快的future计算完成则返回结果"><a href="#等待最快的future计算完成则返回结果" class="headerlink" title="等待最快的future计算完成则返回结果"></a>等待最快的future计算完成则返回结果</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">           System.out.println(&quot;supply1&quot;);</span><br><span class="line">           return &quot;completeResult1&quot;;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               Thread.sleep(3000);</span><br><span class="line">               System.out.println(&quot;supply2&quot;);</span><br><span class="line">           &#125; catch (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           return &quot;completeResult2&quot;;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       CompletableFuture.anyOf(future1, future2).join();// 等待所有future执行完毕</span><br><span class="line">       System.out.println(&quot;final&quot;);</span><br><span class="line">       System.out.println(future1.get());</span><br></pre></td></tr></table></figure><h5 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;supply1&quot;);</span><br><span class="line">            return &quot;completeResult1&quot;;</span><br><span class="line">        &#125;).whenComplete((r, e) -&gt; &#123;</span><br><span class="line">            if(e != null)&#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(r != null)&#123;</span><br><span class="line">                System.out.println(&quot;回调&quot; + r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(&quot;final&quot;);</span><br></pre></td></tr></table></figure><h5 id="主动计算"><a href="#主动计算" class="headerlink" title="主动计算"></a>主动计算</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">           System.out.println(&quot;supply1&quot;);</span><br><span class="line">           try &#123;</span><br><span class="line">               Thread.sleep(3000);</span><br><span class="line">           &#125; catch (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           return &quot;completeResult1&quot;;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       future1.complete(&quot;completeResult2&quot;);</span><br><span class="line">       System.out.println(future1.get());</span><br><span class="line">       System.out.println(&quot;final&quot;);</span><br></pre></td></tr></table></figure><h5 id="后一个异步计算依赖前一个"><a href="#后一个异步计算依赖前一个" class="headerlink" title="后一个异步计算依赖前一个"></a>后一个异步计算依赖前一个</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(&quot;supply1&quot;);</span><br><span class="line">    return &quot;completeResult1&quot;;</span><br><span class="line">&#125;).thenApplyAsync(r1 -&gt; &#123;</span><br><span class="line">    System.out.println(r1);</span><br><span class="line">    System.out.println(&quot;thenExecute&quot;);</span><br><span class="line">    return r1 + &quot;x&quot;;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(future1.get());</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Runnable接口&quot;&gt;&lt;a href=&quot;#Runnable接口&quot; class=&quot;headerlink&quot; title=&quot;Runnable接口&quot;&gt;&lt;/a&gt;Runnable接口&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;不返回任务结果&lt;/li&gt;
&lt;li&gt;不抛出受检异常&lt;/li&gt;
&lt;l
      
    
    </summary>
    
      <category term="blog" scheme="http://zhangxiangnan.com/categories/blog/"/>
    
    
      <category term="JCP" scheme="http://zhangxiangnan.com/tags/JCP/"/>
    
      <category term="Future" scheme="http://zhangxiangnan.com/tags/Future/"/>
    
      <category term="CompletableFuture" scheme="http://zhangxiangnan.com/tags/CompletableFuture/"/>
    
  </entry>
  
  <entry>
    <title>maven实战学习</title>
    <link href="http://zhangxiangnan.com/2019/04/14/maven/maven%E5%AE%9E%E6%88%98%E5%AD%A6%E4%B9%A0/"/>
    <id>http://zhangxiangnan.com/2019/04/14/maven/maven实战学习/</id>
    <published>2019-04-14T09:32:01.000Z</published>
    <updated>2019-04-14T10:06:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>maven是服务于java平台的项目构建、依赖管理、项目信息管理的框架，跨平台(windows、linux)的项目管理工具;<br>maven消除了构建的重复，抽象了构建的生命周期，包含清理、编译、测试到生成报告、打包、部署。</p><h3 id="同类框架比较"><a href="#同类框架比较" class="headerlink" title="同类框架比较"></a>同类框架比较</h3><ul><li>make<br>使用系统命令，不跨平台，语法格式问题</li><li>ant<br>xml定义构建脚本，友好；跨平台，需自己指定构建过程细节</li><li>maven<br>跨平台，有现成的构建插件</li></ul><h3 id="maven安装使用建议"><a href="#maven安装使用建议" class="headerlink" title="maven安装使用建议"></a>maven安装使用建议</h3><ul><li>版本maven3</li><li>复制maven/conf/settings.xml到用户目录~/.m2/settings.xml下</li><li>不适用ide内嵌maven</li></ul><h3 id="pom-xml文件"><a href="#pom-xml文件" class="headerlink" title="pom.xml文件"></a>pom.xml文件</h3><p>project object model项目对象模型，是maven项目的核心，声明项目依赖，如何构建等</p><ul><li>modelVersion 模型版本，maven2+后是4.0.0</li><li>groupId、artifactId、version定义了一个jar、war、pom，项目最基本坐标；groupId是项目所属项目组如com.xx.hellowrold，artifactId定义项目在当前项目组里的唯一id，唯一项目名，如helloworld。version指定版本</li><li>所有pom默认继承超级pom文件</li></ul><h3 id="maven的约定"><a href="#maven的约定" class="headerlink" title="maven的约定"></a>maven的约定</h3><ul><li>pom放项目根目录</li><li>主代码目录 src/main/java</li><li>资源文件 src/main/resources</li><li>测试代码目录 src/test/java</li><li>项目的包结构一般根据groupId+artifactId+细分包名</li><li>编译输出目录为target/classes/</li><li>包输出目录为target/</li></ul><h3 id="maven知识"><a href="#maven知识" class="headerlink" title="maven知识"></a>maven知识</h3><h4 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h4>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;groupId&gt;com.company.projecta&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;projecta&lt;/artifactId&gt;</span><br><span class="line">&lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line">&lt;version&gt;2.2.1&lt;/version&gt;</span><br><span class="line">&lt;name&gt;projecta&lt;/name&gt;</span><br></pre></td></tr></table></figure><ul><li>groupId定义项目所属项目组，定义maven项目所属实际项目，如com.company.projecta</li><li>artifactId定义实际项目的一个maven模块，推荐用实际项目名作为前缀，如projecta-service、projecta-dao</li><li>version，版本</li><li>packaging 打包方式，默认jar</li></ul><h4 id="依赖dependency"><a href="#依赖dependency" class="headerlink" title="依赖dependency"></a>依赖dependency</h4>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.company.xx&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;xx-service&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0.3&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;exclusions&gt;&lt;/exclusions&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>import 导入依赖范围</li><li>type 类型，对应packaging    </li><li>exclusions排除传递性依赖</li><li>optional 可选依赖</li><li>scope依赖范围<br>  依赖范围，控制依赖与编译classpath、测试classpath、运行classpath的关系</li></ul><h4 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h4><table><thead><tr><th>依赖范围scope</th><th>对编译classpath有效</th><th>对测试classpath有效</th><th>对运行classpath有效</th><th>例子</th></tr></thead><tbody><tr><td>compile</td><td>有效</td><td>有效</td><td>有效</td><td>spring-core</td></tr><tr><td>test</td><td>无效</td><td>有效</td><td>无效</td><td>Junit</td></tr><tr><td>provided</td><td>有效</td><td>有效</td><td>无效</td><td>servlet-api</td></tr><tr><td>runtime</td><td>无效</td><td>有效</td><td>有效</td><td>jdbc驱动的实现</td></tr><tr><td>system</td><td>有效</td><td>有效</td><td>无效</td><td>本地jar，不在maven仓库中</td></tr></tbody></table><h4 id="传递性依赖"><a href="#传递性依赖" class="headerlink" title="传递性依赖"></a>传递性依赖</h4><p>  A依赖B，B依赖C，项目会间接引入C，而不需显示声明，A对于B是第一直接依赖，B对于C是第二直接依赖，A对于C是传递性依赖。</p><table><thead><tr><th></th><th>compile</th><th>test</th><th>provided</th><th>runtime</th></tr></thead><tbody><tr><td>compile</td><td>compile</td><td>-</td><td>-</td><td>runtime</td></tr><tr><td>test</td><td>test</td><td>-</td><td>-</td><td>test</td></tr><tr><td>provided</td><td>provided</td><td>-</td><td>provided</td><td>provided</td></tr><tr><td>runtime</td><td>runtime</td><td>-</td><td>-</td><td>runtime</td></tr></tbody></table><h4 id="依赖调解"><a href="#依赖调解" class="headerlink" title="依赖调解"></a>依赖调解</h4><ul><li>第一原则路径短优先<br>A-&gt;B-&gt;C-&gt;D(1.0),A-&gt;E-&gt;D(2.0)，后者路径短，路径最近者优先</li><li>第二原则第一声明者优先<br>A-&gt;B-&gt;C,A-&gt;D-&gt;C，看B、D谁先被声明，就使用谁。</li></ul><ul><li>可选依赖<br>optional的依赖不会被传递依赖，理想不应该出现可选依赖，单一职责。</li></ul><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><ul><li>排除依赖<br>指定groupdId、artefactId即可，不需指定version</li><li>归类依赖<br>同一类相同版本的依赖，指定properties声明版本，来${xx}引用</li><li>优化依赖<ul><li>mvn dependency:list 已解析依赖</li><li>mvn dependency:tree 依赖树</li><li>mvn dependency:analyze 分析编译、测试用的依赖，解决使用未声明的依赖，代码直接使用的依赖应该直接显示声明，而不是间接依赖。</li></ul></li></ul><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><h4 id="构建存放规则"><a href="#构建存放规则" class="headerlink" title="构建存放规则"></a>构建存放规则</h4><p>groupId/artifactId/version/artifactId-version.packaging</p><h4 id="仓库分类："><a href="#仓库分类：" class="headerlink" title="仓库分类："></a>仓库分类：</h4><ul><li>本地仓库</li><li>远程仓库（中央仓库 + 其他公共库 + 局域网内的私服）</li></ul><h4 id="私服："><a href="#私服：" class="headerlink" title="私服："></a>私服：</h4><ul><li>私服代理广域网的仓库服务供内部用户使用</li><li>内部用户上传构件供其他用户使用</li><li>节省外网带宽</li><li>加速maven构建</li><li>提升稳定性，权限控制等</li><li>降低中央仓库负荷</li></ul><h4 id="本机仓库地址"><a href="#本机仓库地址" class="headerlink" title="本机仓库地址"></a>本机仓库地址</h4><p>~/m2/repository</p><h4 id="构件查找顺序"><a href="#构件查找顺序" class="headerlink" title="构件查找顺序"></a>构件查找顺序</h4><p>先查本地，本地无，查远程</p><h4 id="仓库相关配置"><a href="#仓库相关配置" class="headerlink" title="仓库相关配置"></a>仓库相关配置</h4><ul><li><p>settings.xml配置私服认证信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;servers&gt;</span><br><span class="line">    &lt;server&gt;</span><br><span class="line">        &lt;id&gt;idxx&lt;/id&gt;//id与pom中的仓库id一致</span><br><span class="line">        &lt;username&gt;&lt;/username&gt;</span><br><span class="line">        &lt;password&gt;xx&lt;/password&gt;</span><br><span class="line">    &lt;/server&gt;</span><br><span class="line">&lt;/servers&gt;</span><br></pre></td></tr></table></figure></li><li><p>settings.xml配置仓库信息 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;repositories&gt;</span><br><span class="line">&lt;repository&gt;</span><br><span class="line">    &lt;id&gt;xx-releases&lt;/id&gt;</span><br><span class="line">    &lt;name&gt;Repository for releases artifacts&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;http://xx/repository/group-releases&lt;/url&gt;</span><br><span class="line">    &lt;snapshots&gt;</span><br><span class="line">        &lt;enabled&gt;false&lt;/enabled&gt;</span><br><span class="line">    &lt;/snapshots&gt;</span><br><span class="line">    &lt;releases&gt;</span><br><span class="line">        &lt;enabled&gt;true&lt;/enabled&gt;</span><br><span class="line">        &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;</span><br><span class="line">    &lt;/releases&gt;</span><br><span class="line">&lt;/repository&gt;</span><br><span class="line">&lt;/repositories&gt;</span><br></pre></td></tr></table></figure><p>updatePolicy表示从远程仓库检查更新的频率：always表示每次构建都更新，daily每天检查一次，never从不检查更新，internal每隔多少分钟检查一次更新；mvn clean install -U 强制检查更新</p></li><li><p>pom配置内部组件上传仓库的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;distributionManagement&gt;  </span><br><span class="line">      &lt;repository&gt;  </span><br><span class="line">          &lt;id&gt;nexus-releases&lt;/id&gt;  </span><br><span class="line">          &lt;url&gt;  </span><br><span class="line">              http://xx/repositories/releases/  </span><br><span class="line">          &lt;/url&gt;  </span><br><span class="line">      &lt;/repository&gt;  </span><br><span class="line">      &lt;snapshotRepository&gt;  </span><br><span class="line">          &lt;id&gt;nexus-snapshots&lt;/id&gt;  </span><br><span class="line">          &lt;url&gt;  </span><br><span class="line">              http://xx/repositories/snapshots/  </span><br><span class="line">          &lt;/url&gt;  </span><br><span class="line">      &lt;/snapshotRepository&gt;  </span><br><span class="line">  &lt;/distributionManagement&gt;</span><br></pre></td></tr></table></figure><p>部署构建与下载认证方式一样，settings.xml配置认证信息即可， id要对应</p><h4 id="仓库搜索服务"><a href="#仓库搜索服务" class="headerlink" title="仓库搜索服务"></a>仓库搜索服务</h4></li><li>sonatype nexus 这个即可</li><li>jarvana</li><li>mvnbrowser</li></ul><h4 id="maven常见公共仓库"><a href="#maven常见公共仓库" class="headerlink" title="maven常见公共仓库"></a>maven常见公共仓库</h4><ul><li>central</li><li>jboss</li><li>java.net</li></ul><h3 id="快照与发布版本"><a href="#快照与发布版本" class="headerlink" title="快照与发布版本"></a>快照与发布版本</h3><ul><li>快照版本只应该内部组织使用，不应该依赖任何外部快照版本</li><li>项目发布上线时要用release版本</li><li>maven的快照最新版本是根据maven-metadata.xml将本地远程仓库元数据合并解析得到当前快照版本的最新构建版本</li></ul><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>X可以提供Y仓库存储的所有内容，则X是Y的一个镜像，提供更快、更优质的服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   &lt;mirrors&gt;</span><br><span class="line">&lt;mirror&gt;</span><br><span class="line">&lt;id&gt;xxid&lt;/id&gt;</span><br><span class="line">&lt;name&gt;xxid mirror&lt;/name&gt;</span><br><span class="line">&lt;url&gt;http://yy/repository/xxx&lt;/url&gt;</span><br><span class="line">&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;//所有仓库的镜像地址，对于所有仓库的请求转移到该地址；支持更复杂配置，省略</span><br><span class="line">&lt;/mirror&gt;</span><br><span class="line">&lt;/mirrors&gt;</span><br></pre></td></tr></table></figure></p><h3 id="maven声明周期"><a href="#maven声明周期" class="headerlink" title="maven声明周期"></a>maven声明周期</h3><h4 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h4><p>  清理项目，分三个阶段：</p><ul><li>pre-clean</li><li>clean</li><li>post-clean</li></ul><h4 id="defalut"><a href="#defalut" class="headerlink" title="defalut"></a>defalut</h4><ul><li>validate</li><li>initialize</li><li>generate-sources</li><li>process-sources</li><li>generate-resources</li><li>process-resources 复制主资源文件到主输出目录</li><li>compile 编译项目主源码到主classpath</li><li>process-classes</li><li>generate-test-sources</li><li>process-test-sources</li><li>generate-test-resources</li><li>process-test-resources</li><li>test-compile 编译测试代码到测试classpath</li><li>process-test-classes</li><li>test 运行测试代码，测试代码不会打包或部署</li><li>prepare-package</li><li>package 打包编译好的代码</li><li>pre-integration-test</li><li>integration-test</li><li>post-integration-test</li><li>verif</li><li>install 将包安装到本地仓库，供本地其他maven项目使用</li><li>deploy 将包复制到远程仓库</li></ul><h4 id="site生命周期"><a href="#site生命周期" class="headerlink" title="site生命周期"></a>site生命周期</h4><p>  建立、发布项目站点</p><ul><li>pre-site</li><li>site</li><li>post-site</li><li>site-deploy</li></ul><h4 id="独立-amp-依赖顺序"><a href="#独立-amp-依赖顺序" class="headerlink" title="独立&amp;依赖顺序"></a>独立&amp;依赖顺序</h4><p>各个生命周期是相互独立的，但是各个生命周期内部阶段是有前后依赖顺序的</p><ul><li>mvn clean 执行clean生命周期的pre-clean+clean阶段</li><li>mvn test 执行default生命周期的所有前置阶段知道test阶段</li><li>mvn clean install 执行clean声明周期+default声明周期的对应阶段</li><li>mvn clean deploy site-deploy</li></ul><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><h4 id="插件目标"><a href="#插件目标" class="headerlink" title="插件目标"></a>插件目标</h4><p>dependency:tree maven-dependency-plugin插件的分析依赖树为目标，其他类似。</p><h4 id="插件绑定"><a href="#插件绑定" class="headerlink" title="插件绑定"></a>插件绑定</h4><p>生命周期的阶段与插件的目标绑定，来完成某个具体的构建任务</p><ul><li>内置绑定</li><li>自定义绑定</li></ul><p>多个插件绑定到同一个阶段，声明的先后顺序决定执行顺序；不同声明周期的阶段，按声明周期的顺序执行</p><h4 id="插件的配置"><a href="#插件的配置" class="headerlink" title="插件的配置"></a>插件的配置</h4><p>pom或者settings.xml（profile结点配置repositories或pluginRespositories）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;pluginRepositories&gt;</span><br><span class="line">    &lt;pluginRepository&gt;</span><br><span class="line">        &lt;id&gt;xx-releases-plugin&lt;/id&gt;</span><br><span class="line">        &lt;name&gt;Repository for plugin releases artifacts&lt;/name&gt;</span><br><span class="line">        &lt;url&gt;http://xx/repository/group-releases&lt;/url&gt;</span><br><span class="line">        &lt;snapshots&gt;</span><br><span class="line">            &lt;enabled&gt;false&lt;/enabled&gt;</span><br><span class="line">        &lt;/snapshots&gt;</span><br><span class="line">        &lt;releases&gt;</span><br><span class="line">            &lt;enabled&gt;true&lt;/enabled&gt;</span><br><span class="line">            &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;</span><br><span class="line">            &lt;checksumPolicy&gt;ignore&lt;/checksumPolicy&gt;</span><br><span class="line">        &lt;/releases&gt;</span><br><span class="line">    &lt;/pluginRepository&gt;</span><br><span class="line">&lt;/pluginRepositories&gt;</span><br></pre></td></tr></table></figure></p><h4 id="插件解析机制"><a href="#插件解析机制" class="headerlink" title="插件解析机制"></a>插件解析机制</h4><ul><li>插件仓库，可以配置pluginRepositories</li><li>插件默认groupId，不推荐</li><li>解析插件版本,要显示指定插件版本,不要让maven自动解析最新版本</li><li>解析插件前缀，根据前缀得到插件坐标，找不到报错</li></ul><h4 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h4><p>pluginManagement结点只是声明插件，不会造成实际的插件调用行为</p><h3 id="聚合与继承"><a href="#聚合与继承" class="headerlink" title="聚合与继承"></a>聚合与继承</h3><p>一个项目的各个子模块应该有同样的groupId，artifactId应该有相同的前缀，各个子模块应该有相同的versioin。</p><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><ul><li>maven聚合，多模块，聚合模块的packaging必须为pom。</li><li>一般模块名称应该与目录名对应。</li><li>聚合模块里声明modules结点来声明多个模块</li><li>聚合模块一般为顶层模块，其他模块作为聚合模块子目录存在</li><li>聚合模块仅有一个pom文件，无其他内容如src/main/java，仅仅作为聚合其他模块构建的工具，无实质性内容</li><li>聚合模块与其他模块可以是父子关系，也可以平行关系  </li></ul><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul><li>父模块，打包类型必须为pom，用来消除配置的重复，其他模块通过parent结点使用,无实质内容</li><li>子模块可以从父模块继承groupId、version的值</li><li>dependencyManagement可以让子模块继承父模块，又保证子模块灵活性，并约束dependencies下的依赖使用（不用指定版本，减少版本不一致几率）；子模块dependencies里不声明依赖则不会依赖父模块dependencyManagement声明的依赖</li><li>可继承的pom元素<ul><li>groupId</li><li>version</li><li>description、organization、url、inceptionyear</li><li>distributionManagement</li><li>properties</li><li>dependencies</li><li>dependencyManagement</li><li>repositories</li><li>build</li><li>..</li></ul></li></ul><h3 id="常见打包类型"><a href="#常见打包类型" class="headerlink" title="常见打包类型"></a>常见打包类型</h3><ul><li>jar </li><li>war</li><li>pom</li><li>maven-plugin</li><li>ear</li></ul><h3 id="maven反应堆"><a href="#maven反应堆" class="headerlink" title="maven反应堆"></a>maven反应堆</h3><p>maven的各个模块构建顺序，及如何跳过某个模块构建，如何裁剪反应堆</p><h3 id="maven测试"><a href="#maven测试" class="headerlink" title="maven测试"></a>maven测试</h3><h4 id="测试路径"><a href="#测试路径" class="headerlink" title="测试路径"></a>测试路径</h4><p>默认的测试源码路径，src/test/java下的如下规范的测试类：</p><ul><li>Test开头.java</li><li>Test结尾.java</li><li>TestCase结尾.java</li></ul><h4 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h4><p>mvn package-DskipTests</p><h4 id="跳过测试代码编译"><a href="#跳过测试代码编译" class="headerlink" title="跳过测试代码编译"></a>跳过测试代码编译</h4><p>mvn package-Dmaven.test.skip=true  跳过测试代码编译、运行</p><h4 id="运行指定的测试"><a href="#运行指定的测试" class="headerlink" title="运行指定的测试"></a>运行指定的测试</h4><p>mvn test -Dtest=xxTest</p><h4 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h4><p>cobertura测试覆盖率统计工具，mvn cobertura:cobertura来生成报告</p><h4 id="打包测试代码"><a href="#打包测试代码" class="headerlink" title="打包测试代码"></a>打包测试代码</h4><p>maven-jar-plugin的test-jar目标</p><h3 id="maven构建web项目"><a href="#maven构建web项目" class="headerlink" title="maven构建web项目"></a>maven构建web项目</h3><p>建议使用jar，内嵌jetty启动，尽量不要使用jsp，改为模板引擎.</p><h4 id="WAR文件目录结构："><a href="#WAR文件目录结构：" class="headerlink" title="WAR文件目录结构："></a>WAR文件目录结构：</h4><p>-war/</p><ul><li>META-INF/</li><li>WEB-INF/<ul><li>classess/<ul><li>ServletA.class</li><li>config.properties</li><li>…</li></ul></li><li>lib/<ul><li>xx.jar</li></ul></li><li>web.xml</li></ul></li><li>img/</li><li>css/</li><li>js/</li><li>xx.jsp</li><li>xx.html</li></ul><h4 id="mavend的web项目："><a href="#mavend的web项目：" class="headerlink" title="mavend的web项目："></a>mavend的web项目：</h4><ul><li>指定打包类型为war</li><li>指定finalName设置简洁的war包名称</li><li>jsp&amp;servlet的jar要指定为provided类型，不然打到war里和容器的已有jar冲突</li><li>maven的web项目结构约定：<ul><li>project<ul><li>pom.xml</li><li>src/<ul><li>main/<ul><li>java/<ul><li>ServletA.class</li><li>..</li></ul></li><li>resources/<ul><li>config.properties</li><li>..</li></ul></li><li>webapp/<ul><li>WEB-INF/<ul><li>web.xml</li></ul></li><li>img/</li><li>css/</li><li>js/</li><li>xx.jsp</li></ul></li></ul></li><li>test/<ul><li>java/</li><li>resources/</li></ul></li></ul></li></ul></li></ul></li></ul><p>规律：</p><ul><li>src/main/resources文件打包后到war/classes下(classpath)</li><li>src/main/webapp下的文件打包后到war/下</li></ul><h4 id="web项目测试"><a href="#web项目测试" class="headerlink" title="web项目测试"></a>web项目测试</h4><ul><li>jetty-maven-plugin</li><li>只有org.apache.maven.plugins、org.codehaus.mojo这两个groupId下的插件才支持简化的命令行调用；jetty如果想实现简化，需要在settings.xml的pluginGroups结点下添加其groupId</li><li>mvn jettry:run -Djetty.port=xx 指定端口</li></ul><h3 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h3><h4 id="发布版本发布的时机"><a href="#发布版本发布的时机" class="headerlink" title="发布版本发布的时机"></a>发布版本发布的时机</h4><ul><li>所有自动化测试都通过</li><li>项目没有任何快照版本的依赖</li><li>没有配置任何快照版本的插件</li><li>项目的代码全部提交到版本管理系统中</li></ul><h4 id="maven版本号约定"><a href="#maven版本号约定" class="headerlink" title="maven版本号约定"></a>maven版本号约定</h4><p>主版本.次版本.增量版本-里程碑版本</p><ul><li>主版本 项目重构架构变更</li><li>次版本 较大范围内的功能增加变化、bug修复</li><li>增量版本  重大bug修复</li><li>里程碑版本 不是很稳定需要测试</li></ul><p>不过也可以简单如1.2.5、1.2.6-SNAPSHOT、1.2.8-RELEASE</p><h3 id="灵活构建"><a href="#灵活构建" class="headerlink" title="灵活构建"></a>灵活构建</h3><h4 id="maven属性"><a href="#maven属性" class="headerlink" title="maven属性"></a>maven属性</h4><ul><li>内置属性 ${basedir}</li><li>pom属性 ${project.artifactId}</li><li>自定义属性 properties定义</li><li>settings属性 ${settings.localRepository}</li><li>Java系统属性  ${user.home}</li><li>环境变量属性 ${env.JAVA_HOME}</li></ul><h4 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h4><p>pom里可以配置profile，针对不同环境dev、test、staging、prod不来执行不同的资源或配置</p><h5 id="激活profile"><a href="#激活profile" class="headerlink" title="激活profile"></a>激活profile</h5><ul><li>命令行 mvn clean install -Pdev</li><li>settings.xml里配置所有项目都激活某个profile</li><li>系统属性存在、符合某个条件等时激活</li></ul><h5 id="推荐配置"><a href="#推荐配置" class="headerlink" title="推荐配置"></a>推荐配置</h5><p>当前项目的pom文件里设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;profiles&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">      &lt;id&gt;dev&lt;/id&gt;</span><br><span class="line">      &lt;build&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">          &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;src/main/profiles/dev&lt;/directory&gt;</span><br><span class="line">          &lt;/resource&gt;</span><br><span class="line">          &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">          &lt;/resource&gt;</span><br><span class="line">        &lt;/resources&gt;</span><br><span class="line">      &lt;/build&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">      &lt;id&gt;test&lt;/id&gt;</span><br><span class="line">      &lt;activation&gt;</span><br><span class="line">        &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">      &lt;/activation&gt;</span><br><span class="line">      &lt;build&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">          &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;src/main/profiles/test&lt;/directory&gt;</span><br><span class="line">          &lt;/resource&gt;</span><br><span class="line">          &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">          &lt;/resource&gt;</span><br><span class="line">        &lt;/resources&gt;</span><br><span class="line">      &lt;/build&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">      &lt;id&gt;staging&lt;/id&gt;</span><br><span class="line">      &lt;build&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">          &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;src/main/profiles/staging&lt;/directory&gt;</span><br><span class="line">          &lt;/resource&gt;</span><br><span class="line">          &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">          &lt;/resource&gt;</span><br><span class="line">        &lt;/resources&gt;</span><br><span class="line">      &lt;/build&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">      &lt;id&gt;prod&lt;/id&gt;</span><br><span class="line">      &lt;build&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">          &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;src/main/profiles/prod&lt;/directory&gt;</span><br><span class="line">          &lt;/resource&gt;</span><br><span class="line">          &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">          &lt;/resource&gt;</span><br><span class="line">        &lt;/resources&gt;</span><br><span class="line">      &lt;/build&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">  &lt;/profiles&gt;</span><br></pre></td></tr></table></figure><h3 id="常用maven插件"><a href="#常用maven插件" class="headerlink" title="常用maven插件"></a>常用maven插件</h3><ul><li>maven-clean-plugin</li><li>maven-compiler-plugin</li><li>maven-deploy-plugin</li><li>maven-install-plugin</li><li>maven-resources-plugin</li><li>maven-surefire-plugin</li><li>maven-jar-plugin</li><li>maven-war-plugin</li><li>maven-javadoc-plugin</li><li>maven-archetype-plugin</li><li>maven-dependency-plugin</li><li>maven-source-plugin</li><li>tomcat-maven-plugin</li><li>version-maven-plugin</li><li>jetty-maven-plugin</li></ul><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul><li>maven实战-许晓斌</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;maven是服务于java平台的项目构建、依赖管理、项目信息管理的框架，跨平台(windows、linux)的项目管理工具;&lt;br&gt;mave
      
    
    </summary>
    
      <category term="maven" scheme="http://zhangxiangnan.com/categories/maven/"/>
    
    
      <category term="maven" scheme="http://zhangxiangnan.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>微服务总体认识</title>
    <link href="http://zhangxiangnan.com/2019/03/30/microservice/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%80%BB%E4%BD%93%E8%AE%A4%E8%AF%86/"/>
    <id>http://zhangxiangnan.com/2019/03/30/microservice/微服务总体认识/</id>
    <published>2019-03-30T15:27:01.000Z</published>
    <updated>2019-03-30T15:50:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么选用微服务？"><a href="#为什么选用微服务？" class="headerlink" title="为什么选用微服务？"></a>为什么选用微服务？</h3><p>微服务相对单体应用而言，单体应用即单个服务包含所用功能，统一维护部署；微服务是单体应用拆分的多个小些的服务。</p><h4 id="单体应用的缺点"><a href="#单体应用的缺点" class="headerlink" title="单体应用的缺点"></a>单体应用的缺点</h4><ul><li>包含所有功能，改一处功能或者一处功能有问题影响整个服务稳定性</li><li>随着业务迭代，项目易变得庞大混乱，团队代码合并成本高，定位故障也复杂</li><li>单体应用使用统一框架、语言，可能有些模块使用其他语言更适合，无法个性化</li><li>编译、部署时间长，成本高<br>单体与微服务要根据具体业务体量及团队大小，不能盲目追随微服务。</li></ul><h4 id="微服务的缺点"><a href="#微服务的缺点" class="headerlink" title="微服务的缺点"></a>微服务的缺点</h4><ul><li>一个人可能需要维护很多小型服务（维护成本高）</li><li>单个服务独立部署会浪费些硬件资源</li><li>可能引入跨服务事务即分布式事务、跨库查询的问题（耦合的数据库逻辑最好不要拆到多个服务）</li><li>性能下降</li><li>可用性问题</li><li>测试、排查问题成本高</li><li>系统架构变复杂</li></ul><h3 id="什么是服务化？"><a href="#什么是服务化？" class="headerlink" title="什么是服务化？"></a>什么是服务化？</h3><p>单体应用各个maven模块之间通过jar依赖调用自身服务的本地方法，是单个进程内的调用逻辑；或者直接调用自身服务的某个service类，服务化即单体应用按业务或其他原则拆分多个小服务后，小服务间通过rpc（http、thrift等）调用，是多个进程间，多个主机间的调用逻辑</p><p>微服务是更细粒度的服务化</p><ul><li>拆分粒度更细，某个模块也可以单独拆</li><li>单独部署维护</li></ul><h3 id="如何拆分"><a href="#如何拆分" class="headerlink" title="如何拆分"></a>如何拆分</h3><ul><li>纵向，按业务领域、业务功能模块拆分，如拆为首页服务、价格、预定、生单等</li><li>横向，将公共公用、独立的功能拆分出来，提供服务给多个服务使用，如用户服务可以作为公共基础服务给多个使用方提供用户信息的查询</li><li>一个业务进行读写拆分，提升稳定性</li><li>按qps高低拆分</li></ul><p>拆分太细，维护成本太高，性能也会变差，要把我合适的粒度，综合分析有必要拆再拆</p><h3 id="何时拆分"><a href="#何时拆分" class="headerlink" title="何时拆分"></a>何时拆分</h3><p>团队规模逐步扩大，业务逐渐复杂，多人协作维护一个单体应用时沟通、编译、发布、维护等成本变高时，或者为了某个功能的稳定性，当掌握微服务相关技术栈后可以考虑拆分</p><h3 id="服务化引入的问题"><a href="#服务化引入的问题" class="headerlink" title="服务化引入的问题"></a>服务化引入的问题</h3><ul><li>服务间通信采用何种协议，http、rpc以及接口的格式、规范、版本、兼容性等问题</li><li>服务如何注册发现？注册中心</li><li>服务监控包括性能，调用链路成功率，稳定性</li><li>服务间的调用治理，包括超时、重试、熔断降级、截流等，以及服务的上下链路调用与被调用服务的管理（哪些服务，哪些机器提供、机房分布等）</li><li>问题排查需要各个服务间有一个追踪标识，请求id等唯一标识请求</li></ul><h3 id="微服务的基本组件"><a href="#微服务的基本组件" class="headerlink" title="微服务的基本组件"></a>微服务的基本组件</h3><ul><li><p>服务描述（接口文档、api）</p><p>服务提供的接口名称，参数格式（参数名、类型），返回结果格式（值及类型），常见服务描述方式：</p><ul><li>RESTFul API，描述http、https协议的服务描述，swagger管理</li><li>xml配置，rpc协议的服务描述</li><li>idl，thrift、grpc跨语言服务调用框架</li></ul></li><li><p>注册中心</p><p>可以自己实现，或者使用开源框架，如zookeeper、nacos、consul、eureka等</p><ul><li>1、服务提供者将提供的服务、服务ip地址、端口号登记到注册中心；</li><li>2、服务消费者根据其配置文件中描述的服务信息从注册中心订阅所需服务</li><li>3、注册中心返回服务提供者地址列表给服务消费者，服务消费者根据得到的服务提供者的ip、端口等信息，通过轮询、一致性hash等负载均衡策略，直接发起调用（不经过注册中心）</li><li>4、服务提供者下线、上线机器/节点时，注册中心将变更通知给服务消费者（如zookeeper的临时有序节点实现节点下线通知），服务消费者剔除/增加节点信息。 </li></ul></li><li><p>服务框架</p><p>注册中心使服务消费者得到服务提供者的地址，要有以下信息才可以调用：</p><ul><li>服务通信协议 四层的tcp、udp、七层http…</li><li>数据传输方式 同步、异步，连接是单连接、多路复用</li><li>数据压缩格式 压缩减少网络传输时间及带宽，json、protbuf、xml、hession、kyro、java序列化、thrift等</li></ul></li><li><p>服务监控</p><p>对服务消费者与服务提供者之间的调用次数、成功率等指标收集、统计、展示</p><ul><li>指标收集 每次请求耗时、成功与否、源ip、目的ip、接口名称等</li><li>聚合处理 每秒qps，平均耗时、tp95、tp90、tp99、tp99.9、成功率等</li><li>监控展示 界面化展示查看，可添加监控报警，按不同时间（小时、天、周等）、维度（主机、接口名等）聚合统计</li></ul></li><li><p>服务追踪</p><p>分布式服务追踪，用于排查问题，一个traceid或requestid查询所有服务的日志，分析原因</p></li><li><p>服务治理</p><ul><li>单节点故障自动摘除</li><li>机房故障自动切换其他机房，中心故障自动切换其他中心，本地不可用切异地</li><li>熔断截流机制</li><li>超时重试</li><li>同机房、同中心、同地域优先调用</li><li>服务手动禁用、下线</li><li>自动弹性扩容</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;为什么选用微服务？&quot;&gt;&lt;a href=&quot;#为什么选用微服务？&quot; class=&quot;headerlink&quot; title=&quot;为什么选用微服务？&quot;&gt;&lt;/a&gt;为什么选用微服务？&lt;/h3&gt;&lt;p&gt;微服务相对单体应用而言，单体应用即单个服务包含所用功能，统一维护部署；微服务是单体应
      
    
    </summary>
    
      <category term="微服务" scheme="http://zhangxiangnan.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="微服务" scheme="http://zhangxiangnan.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>互联网mysql数据库开发设计运维规范</title>
    <link href="http://zhangxiangnan.com/2019/03/23/mysql/%E4%BA%92%E8%81%94%E7%BD%91mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1%E8%BF%90%E7%BB%B4%E8%A7%84%E8%8C%83/"/>
    <id>http://zhangxiangnan.com/2019/03/23/mysql/互联网mysql数据库开发设计运维规范/</id>
    <published>2019-03-23T15:07:10.000Z</published>
    <updated>2019-03-23T15:17:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础规范"><a href="#基础规范" class="headerlink" title="基础规范"></a>基础规范</h3><ul><li>绝大部分场景存储引擎必须使用InnoDB<br>  支持事务</li><li>字符集编码必须使用utf8mb4字符集(支持4字节emoji表情以及部分不常见汉字，utf8只支持3字节)，是utf8的超集<br>utf8mb4对应字符的比较排序常用排序字符集utf8mb4_unicode_ci、utf8mb4_general_ci。utf8mb4_unicode_ci能在各种语言精准排序；utf8mb4_general_ci性能好一点，但对于特殊字符排序不是非常准确，两者都可。建议utf8mb4_unicode_ci。</li><li>数据表、字段必须加注释</li><li>不要使用触发器、存储过程、视图、外键约束、events、udf<ul><li>能放业务层处理的逻辑都放业务层处理；</li><li>业务层可扩展性强（数据库一般一主多从，主节点没法横向扩展），且便于调试，查问题</li><li>为了高并发</li></ul></li><li>不要存文件、图片等大数据及TEXT、BLOB类型<ul><li>使用文件服务器、图片服务器等文件系统存储，数据库里可以存储url</li><li>非用不可则拆到单独表，使用主键做关联 </li></ul></li><li>线下环境服务禁止直连线上数据库，各环境数据库隔离</li><li>禁止针对线上数据库进行压力测试，影响性能及正常业务，可能导致故障</li><li>库备份可以以类似backup为前缀＋数据库名＋日期为后缀，从库以-s为后缀，备库以-ss为后缀，只要能标示即可。</li></ul><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul><li>dev、test环境可以使用ip直连数据库，stag&amp;prod需使用内网域名连接，其他类似尽可能线上使用域名连接，有利于依赖方对自身服务机器的运维</li><li>数据库名称尽量合项目或业务名称一样，各个环境的库名最好一样</li><li>库名、表名、字段名要用小写，下划线风格，&lt;=32个字符，名称和业务绑定要有意义，不得拼音英文混合。</li><li>索引名，唯一索引名为uk_字段名，普通索引idx_字段名，小写</li><li>表名单数</li></ul><h3 id="表设计规范"><a href="#表设计规范" class="headerlink" title="表设计规范"></a>表设计规范</h3><ul><li>表必须要有主键id<ul><li>表碎片率低，顺序insert效率高；</li><li>推荐unsigned整数（BIGINT），值自增或者业务设置</li><li>不要用varchar、char、uuid、md5、hash作为主键，变为随机写入，效率低；</li><li>无主键表说是删除表时，对于row模式主从复制架构，从库的数据是以主键为依据进行更新，导致从库会挂住</li></ul></li><li>禁止使用外键，影响性能，可能会死锁，造成表与表耦合</li><li>大字段，冷门字段可以拆分到单独表，分离冷热数据</li></ul><h3 id="字段设计规范"><a href="#字段设计规范" class="headerlink" title="字段设计规范"></a>字段设计规范</h3><ul><li>必须把字段定义为NOT NULL并提供默认值<ul><li>表及索引都需要额外空间标示，而且会使索引无效</li><li>mysql针对其特殊处理导致性能下降</li><li>比较只能IS NULL，IS NOT NULL，不能用＝、in、&lt;&gt;、!=、not in，如name != ‘xx’结果不会包含name为null的记录</li><li>使列索引、值比较、统计时都复杂，难优化</li></ul></li><li>禁止使用text、blob类型，影响性能</li><li>货币、钱不能使用浮点数存储会损失精度，用整数单位为分，或者用bigdecimal，注意精度。</li><li>手机号存储使用varchar(20)，不要用整数<ul><li>支持模糊查询，查询188开头的</li><li>手机号可能会有国家号、区号</li></ul></li><li>禁止用enum类型，用tinyint代替<ul><li>增加新enum类型，要执行ddl语句</li></ul></li><li>根据业务区分使用tinyint/int/bigint，占用1/4/8字节，合理的类型减少空间浪费</li><li>根据业务区分使用char/varchar<ul><li>长度固定，或近似使用char，减少内存碎片，提升查询性能</li><li>字段长度相差大，或更新较少，用varchar，节省磁盘及内存空间；字符长度小于5000使用varchar，否则text类型，拆单独表存储，避免影响效率</li></ul></li><li>根据业务区分使用datetime/timestamp<ul><li>存储年用YEAR，日期用DATE，时间datetime</li></ul></li><li>使用INT UNSIGNED存储IPv4，不要用char(15)，减少存储空间，查询时使用INET_ATON()、INET_NTOA()进行转换</li><li>每个表都建议添加id、create_time（创建时间，datetime类型）、update_time（更新时间，datetime类型）、creator（创建者）、modifier（修改者）</li><li>严禁明文存储密码、身份证、信用卡号、银行卡号等机密数据，要加密，存储密文，进行数据脱敏</li><li>整型字段，若为非负，必须UNSIGNED类型，扩大数值范围</li></ul><h3 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h3><ul><li>单表的索引建议&lt;=5，包括唯一id索引<ul><li>太多索引导致索引占用太多存储空间，且插入更新操作会更新相关索引，影响性能</li><li>太多索引可能导致mysql选择不出最优索引</li><li>复杂条件查询建议使用es等存储引擎查询</li></ul></li><li>单个索引的字段个数不能超过5个<ul><li>太多字段导致存储空间增大，影响性能；</li><li>另一方面说明选取字段区分度不高，值域较少，不能有效过滤数据</li></ul></li><li>区分度不高、更新频繁的字段禁止建立索引<ul><li>区分度不高的字段不能有效进行数据过滤，如性别字段</li><li>更新频繁的字段每次会更新索引，更新b＋树，影响性能</li></ul></li><li>避免使用join查询<ul><li>尽量放到业务层处理，多次表查询</li><li>必须join的话，需join的字段类型必须相同，且建立索引，否则全表扫描;最多不超过3个表join</li></ul></li><li>组合索引最左前缀原则，不要重复建立索引和已有单列索引重复，复合索引如(a,b,c)，相当于建立(a)，（a,b）,(a,b,c)三个索引</li><li>对字符串使用前缀索引时，前缀索引长度不超过8个字符，太多字符导致索引存储空间大，影响性能；有时可以通过增加冗余列来减少索引长度，提升效率</li><li>复合索引把区分度高，去重后个数多的字段放索引前面</li><li>使用explain进行sql性能分析，是否使用索引，避免extra出现：use file sort，use tempory，导致性能降低</li><li>具有唯一特性的一个或多个字段建立唯一索引，避免脏数据</li><li>sql explain时语句type至少达到range级别（基于索引范围搜索），ref好些(使用索引)，constants(匹配单条记录)最好。</li></ul><h3 id="SQL使用规范"><a href="#SQL使用规范" class="headerlink" title="SQL使用规范"></a>SQL使用规范</h3><ul><li>sql要尽可能简单，拆分</li><li>事务要简单，禁止包含非数据库操作逻辑</li><li><p>禁止使用SELECT ＊，只获取必要的字段</p><ul><li>读取多余列增加CPU、IO、NET消耗，影响性能、带宽、IO</li><li>不能有效利用覆盖索引(假如查询的列都在索引里，直接从索引获取数据，而不必再次读取数据行)</li><li>SELECT * 容易在增加删除字段等表结构变更后后出现问题</li></ul></li><li><p>禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性，容易在增加或者删除字段等表结构变更后出现程序BUG，字段顺序错乱导致的值错乱&amp;sql报错等</p></li><li>禁止使用属性隐式转换<br>  如seelct uid, name from user where phone_num = 18810231321语句不会使用索引（phone_num使用varchar存储且该列建了索引）,导致全表扫描</li><li>禁止where条件的属性上使用函数或者表达式，导致索引不生效，全局扫描;在值上可以使用<br>  如select uid from user where age - 2 &gt; 10可改为 age &gt; 12;</li><li>反向、负向查询以及％开头的模糊查询<ul><li>负向查询如NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等会导致全局扫描；但如果where uid = xx and status != 1类似先执行了uid过滤后进行负向查询的话还可以</li><li>针对字符，左前缀模糊查询导致索引不生效，全表扫描；其他类型后面模糊也不走索引</li></ul></li><li>禁止大表使用join查询，及使用子查询<br>  会产生临时表，消耗内存、cpu，影响性能；避免临时表</li><li>union all不去重，少了排序操作；union去重，性能不如union all</li><li>禁止使用同一字段上的OR查询，改为IN,in也要尽量避免使用，in里个数控制在500或1000个内，OR使索引失效；不同字段的or用union all代替</li><li>应用程序要捕获sql异常，进行处理，便于定位问题</li><li>使用预编译prepared sql，防止注入，提升性能</li><li>重要sql要被索引<ul><li>where条件里的字段</li><li>ORDER BY、GROUP BY、DISTINCT的字段</li></ul></li><li>sql语句建议全部小写，或者全部大写，小写容易读</li><li>避免使用count(*)，会全表扫描，计数实时较强的场景可以用redis等分布式缓存，不强可以用单独的统计表定时更新</li><li>禁止update语句时set a = x ,b = y;写成a = x and b = y，意义不一样</li><li>尽量减少与数据库交互次数，能批量则批量，能一次不2次</li><li>insert使用batch提交时insert into table values (),()..，小于500个，根据数据量酌情定</li><li>sql语句不用不确定值函数及随机函数，如rand()、now()</li><li>减少、避免排序，group by如果不需要排序可以加order by null</li><li>多使用limit n，少用limit m,n，m比较大时影响性能</li><li>使用INSERT … ON DUPLICATE KEY update (INSERT IGNORE)或者replace语句来避免不必要的查询</li><li>尽量使用主键update、delete操作</li><li>用where子句代替having子句，having可能不同执行计划结果不同</li><li>不要一次大量删除、更新或导入导出数据，分批，太多容易出问题</li><li>多表连接查询数据量小的表的条件紧跟where语句后</li><li>count(列名)不会统计列为null的行，所以列要not null</li><li>count(distinct col1)统计col1不为null的不重复数量，列要not null</li><li>count(distinct col1, col2)，col1或col2为null，则返回0，所以列要not null</li><li>count(col)若col列全为null返回0，但是sum(col)则返回null，npe异常，列要not null</li><li>sql delte update语句执行时要先select查看影响条数，及diff语句前后的影响数据</li></ul><h3 id="流程规范"><a href="#流程规范" class="headerlink" title="流程规范"></a>流程规范</h3><ul><li>建表时提前考虑可能的查询场景，并建立对应合适的索引</li><li>表结构更改、加索引需要提前周知dba，梳理表的查询sql，评估风险</li><li>大量批量导入、导出数据及统计类查询，不得使用主库，线上在线的从库</li><li>活动推广，新功能要评估数据库压力</li><li>业务高峰期不做表结构更改，加索引等有风险的操作</li></ul><h3 id="开发规范技巧"><a href="#开发规范技巧" class="headerlink" title="开发规范技巧"></a>开发规范技巧</h3><ul><li>注意整数字段的溢出，业务做参数校验</li><li>注意字符串自动转换为整数的溢出，校验参数</li><li><p>分页技巧<br>limit m, n,m越大，性能越慢，需要先扫描前m条记录，然后往后找n条</p><ul><li>id方式，where id &gt; xx limit 10;</li><li><p>子查询优化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * from table WHERE id &gt;= ( select id from table limit 10000,1 ) limit 10;</span><br></pre></td></tr></table></figure></li><li><p>join优化</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table INNER JOIN (SELECT id FROM table LIMIT 10000,10) USING (id) ;</span><br></pre></td></tr></table></figure></li><li><p>先取id，再次执行in (id1,id2)查询</p></li><li>缓存前若干页热门数据</li></ul></li></ul><h3 id="mysql特点"><a href="#mysql特点" class="headerlink" title="mysql特点"></a>mysql特点</h3><ul><li>mysql的查询缓存适用于更新频率非常低，查询频率非常高的场景，否则建议关闭查询缓存</li><li>简单使用mysql，不要使用外键、分区表、存储过程等特性</li></ul><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><ul><li>通常根据表的某个字段如订单号、userid来进行hash或者range拆分</li><li>单表数据量建议超过千万级别或单表容量&gt;2GB才推荐分库分表，不过有的表数据量亿级容量也可以轻松应对，看情况</li></ul><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><ul><li>主从复制分异步复制，半同步复制</li><li>建议交易环节所有请求都走主库</li></ul><h3 id="对象关系映射"><a href="#对象关系映射" class="headerlink" title="对象关系映射"></a>对象关系映射</h3><ul><li>domain类boolean属性字段不要以is为前缀，有坑;数据库boolean字段加is前缀</li><li>domain类不能直接返回到展示层，需进行到VO或DTO的转换</li><li>mybatis的mapper里不能使用${}，要用#{}，防止sql注入，提升性能，预编译</li><li>mybatis的queryForList(String statementName,int start,int size)不要使用，底层查询所有数据，然后内存截取</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>互联网业务一般高并发，大数据量，然而数据库连接有效，查询&amp;写入必须快速，否则就影响性能，长时间占有连接则影响并发。提升性能则查询尽可能走索引，不要导致全局扫描、文件排序。</li><li>针对数据的统计分析，或者数据的多维度搜索、聚合，建议使用ETL或者搜索引擎</li></ul><h3 id="mysql各数据类型范围"><a href="#mysql各数据类型范围" class="headerlink" title="mysql各数据类型范围"></a>mysql各数据类型范围</h3><table><thead><tr><th>类型</th><th style="text-align:center">占用字节</th><th style="text-align:right">有符号范围</th><th>无符号范围</th></tr></thead><tbody><tr><td>TINYINT</td><td style="text-align:center">1</td><td style="text-align:right">(-128，127)</td><td>(0，255)</td></tr><tr><td>SMALLINT</td><td style="text-align:center">2</td><td style="text-align:right">(-3万，3万)</td><td>(0，6万)</td></tr><tr><td>MEDIUMINT</td><td style="text-align:center">3</td><td style="text-align:right">(-800万，800万)</td><td>(0，约1600万)</td></tr><tr><td>INT或INTEGER</td><td style="text-align:center">4</td><td style="text-align:right">约21亿</td><td>约42亿</td></tr><tr><td>BIGINT</td><td style="text-align:center">8</td><td style="text-align:right">(-922亿亿, 922亿亿)</td><td>(0,1844亿亿)</td></tr><tr><td>DECIMAL</td><td style="text-align:center">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td style="text-align:right">依赖于M和D的值</td><td>依赖于M和D的值</td></tr></tbody></table><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.kancloud.cn/wubx/mysql-sql-standard/600511" target="_blank" rel="noopener">https://www.kancloud.cn/wubx/mysql-sql-standard/600511</a></li><li><a href="https://www.verynull.com/2017/02/18/MySQL%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/" target="_blank" rel="noopener">https://www.verynull.com/2017/02/18/MySQL%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</a></li><li><a href="https://www.jianshu.com/p/7c4f1efbc059" target="_blank" rel="noopener">https://www.jianshu.com/p/7c4f1efbc059</a></li><li><a href="https://www.kancloud.cn/wubx/mysql-sql-standard/600517" target="_blank" rel="noopener">https://www.kancloud.cn/wubx/mysql-sql-standard/600517</a></li><li><a href="https://my.oschina.net/leejun2005/blog/476839" target="_blank" rel="noopener">https://my.oschina.net/leejun2005/blog/476839</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基础规范&quot;&gt;&lt;a href=&quot;#基础规范&quot; class=&quot;headerlink&quot; title=&quot;基础规范&quot;&gt;&lt;/a&gt;基础规范&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;绝大部分场景存储引擎必须使用InnoDB&lt;br&gt;  支持事务&lt;/li&gt;
&lt;li&gt;字符集编码必须使用utf8mb4
      
    
    </summary>
    
      <category term="mysql" scheme="http://zhangxiangnan.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://zhangxiangnan.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>lombok学习记录</title>
    <link href="http://zhangxiangnan.com/2019/03/21/lombok/lombok%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://zhangxiangnan.com/2019/03/21/lombok/lombok学习记录/</id>
    <published>2019-03-21T14:45:01.000Z</published>
    <updated>2019-03-22T11:56:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="lombok介绍"><a href="#lombok介绍" class="headerlink" title="lombok介绍"></a>lombok介绍</h3><p>lombok是一个java的jar包，第三方字节码修改库，简化重复性简单的代码，比如java类的getter、setter、tostring()、equals()、构造函数、hashcode等方法在编译期的自动生成，以及builder模式创建实例。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>使用JSR 269: Pluggable Annotation Processing API来实现<a href="https://jcp.org/en/jsr/detail?id=269，编译期修改抽象语法树，如增加get方法节点等，然后生成字节码" target="_blank" rel="noopener">https://jcp.org/en/jsr/detail?id=269，编译期修改抽象语法树，如增加get方法节点等，然后生成字节码</a></p><h3 id="利弊"><a href="#利弊" class="headerlink" title="利弊"></a>利弊</h3><p>利:</p><ul><li>简化重复的代码，使类看起来简洁</li><li>builder模式好用</li></ul><p>弊:</p><ul><li>破坏源代码完整性，可阅读性</li><li>依赖额外lombok jar包，增加出问题的风险</li><li>ide等必须安装lombok插件，不然报错，而且自动生成的方法没法从调用处跳转<h3 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h3><h4 id="lombok显示声明构造函数的一个坑-字段值顺序乱掉"><a href="#lombok显示声明构造函数的一个坑-字段值顺序乱掉" class="headerlink" title="lombok显示声明构造函数的一个坑-字段值顺序乱掉"></a>lombok显示声明构造函数的一个坑-字段值顺序乱掉</h4>有下例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import lombok.Builder;</span><br><span class="line">import lombok.Getter;</span><br><span class="line">import lombok.Setter;</span><br><span class="line">import lombok.ToString;</span><br><span class="line">@Setter</span><br><span class="line">@Getter</span><br><span class="line">@ToString</span><br><span class="line">@Builder</span><br><span class="line">public class Button &#123;</span><br><span class="line">    private String content;</span><br><span class="line"></span><br><span class="line">    private String color;</span><br><span class="line"></span><br><span class="line">    private String url;</span><br><span class="line"></span><br><span class="line">    public Button(String content, String url, String color) &#123;</span><br><span class="line">        this.content = content;</span><br><span class="line">        this.color = color;</span><br><span class="line">        this.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final Button DEFAULT_BUTTON = Button.builder()</span><br><span class="line">            .content(&quot;xxcontent&quot;)</span><br><span class="line">            .color(&quot;#FE6D4D&quot;)</span><br><span class="line">            .url(&quot;http://www.xx.com&quot;)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Button button = Button.DEFAULT_BUTTON;</span><br><span class="line">        System.out.println(button);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>上例子main函数预期输出为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Button(content=xxcontent, color=#FE6D4D, url=http://www.xx.com)</span><br></pre></td></tr></table></figure><p>而实际为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Button(content=xxcontent, color=http://www.xx.com,url=#FE6D4D)</span><br></pre></td></tr></table></figure></p><p>url的值与color的值顺序乱了，为啥？</p><h5 id="分析编译后的class文件"><a href="#分析编译后的class文件" class="headerlink" title="分析编译后的class文件"></a>分析编译后的class文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Source code recreated from a .class file by IntelliJ IDEA</span><br><span class="line">// (powered by Fernflower decompiler)</span><br><span class="line">//</span><br><span class="line">public class Button &#123;</span><br><span class="line">    private String content;</span><br><span class="line">    private String color;</span><br><span class="line">    private String url;</span><br><span class="line">    public static final Button DEFAULT_BUTTON = builder().content(&quot;xxcontent&quot;).color(&quot;#FE6D4D&quot;).url(&quot;http://www.xx.com&quot;).build();</span><br><span class="line"></span><br><span class="line">    ////这里..，url为第二个形参，与字段声明顺序不一致</span><br><span class="line">    public Button(String content, String url, String color) &#123;</span><br><span class="line">        this.content = content;</span><br><span class="line">        this.color = color;</span><br><span class="line">        this.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Button button = DEFAULT_BUTTON;</span><br><span class="line">        System.out.println(button);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Button.ButtonBuilder builder() &#123;</span><br><span class="line">        return new Button.ButtonBuilder();</span><br><span class="line">    &#125;</span><br><span class="line">    //getter/setter</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Button(content=&quot; + this.getContent() + &quot;, color=&quot; + this.getColor() + &quot;, url=&quot; + this.getUrl() + &quot;)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class ButtonBuilder &#123;</span><br><span class="line">        private String content;</span><br><span class="line">        private String color;</span><br><span class="line">        private String url;</span><br><span class="line"></span><br><span class="line">        ButtonBuilder() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Button.ButtonBuilder content(String content) &#123;</span><br><span class="line">            this.content = content;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Button.ButtonBuilder color(String color) &#123;</span><br><span class="line">            this.color = color;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Button.ButtonBuilder url(String url) &#123;</span><br><span class="line">            this.url = url;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Button build() &#123;</span><br><span class="line">            return new Button(this.content, this.color, this.url);////这里..</span><br><span class="line">        &#125;</span><br><span class="line">        //tostring()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>不仔细看代码或者debug，其实不容易看出来区别，问题就在于ButtonBuilder的build()方法内部使用了Button类的全参构造函数，而且其字段顺序和Button类各个字段顺序一致；而观察Button类内部的全参构造函数发现，url是第二个形参，跟字段顺序不一致，所以导致值错乱。</p><p>建议：构造函数最好使用ide自动生成，形参顺序保持和字段顺序一致，避免出现类似问题。</p><p>说明：如果不显示声明带参数的构造函数，lombok会自动生成带参数的构造函数，是没问题的，顺序是一致的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;lombok介绍&quot;&gt;&lt;a href=&quot;#lombok介绍&quot; class=&quot;headerlink&quot; title=&quot;lombok介绍&quot;&gt;&lt;/a&gt;lombok介绍&lt;/h3&gt;&lt;p&gt;lombok是一个java的jar包，第三方字节码修改库，简化重复性简单的代码，比如java
      
    
    </summary>
    
      <category term="lombok" scheme="http://zhangxiangnan.com/categories/lombok/"/>
    
    
      <category term="lombok" scheme="http://zhangxiangnan.com/tags/lombok/"/>
    
  </entry>
  
  <entry>
    <title>java线程协作通信</title>
    <link href="http://zhangxiangnan.com/2019/03/19/java/java%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C%E9%80%9A%E4%BF%A1/"/>
    <id>http://zhangxiangnan.com/2019/03/19/java/java线程协作通信/</id>
    <published>2019-03-19T15:15:00.000Z</published>
    <updated>2019-03-19T15:20:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>java线程协作即2个线程如何交互，发信号，告诉对方一些信息，触发对方做一些事情。</p><h3 id="一道题说起："><a href="#一道题说起：" class="headerlink" title="一道题说起："></a>一道题说起：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    System.out.println(&quot;step1&quot;);</span><br><span class="line">    Object obj = new Object();</span><br><span class="line">    magic(obj);</span><br><span class="line">    System.out.println(&quot;step2&quot;);</span><br><span class="line">    synchronized (obj)&#123;</span><br><span class="line">        System.out.println(&quot;step3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问如何实现magic方法，使输出按如下顺序，且线程停留在为synchronized (obj)这行（注意：不输出step3）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">step1</span><br><span class="line">step2</span><br></pre></td></tr></table></figure><p>很明显，magic方法里需要获取obj的锁，因为需要返回到main函数，没法在magic方法里用主线程一直锁定obj，所以需要单独开一个线程来锁定obj。那么，子线程锁定obj，锁定多长时间呢，两个线程运行具有不确定性，既然不确定，就让子线程一直锁。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private static void magic(Object obj)  &#123;</span><br><span class="line">       Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">           synchronized (obj)&#123;</span><br><span class="line">               while (true)&#123;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       thread.setName(&quot;xx&quot;);</span><br><span class="line">       thread.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>magic启动子线程后，方法返回，main函数继续执行，此时可能子线程还没有锁定obj，导致和预期不一致。即我们要做的是子线程必须获取到obj锁，才能让magic返回，怎么让子线程告诉主线程我已经获取到了obj锁，你可以继续执行呢？</p><h4 id="主线程睡眠一定时间？？"><a href="#主线程睡眠一定时间？？" class="headerlink" title="主线程睡眠一定时间？？"></a>主线程睡眠一定时间？？</h4><p>这种不靠谱，极端情况下子线程可能在设置的休眠时间内仍然没有得到运行；另外子线程极端时间内得到了锁，但是主线程确休眠，造成cpu浪费</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static void magic(Object obj)  &#123;</span><br><span class="line">        Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (obj)&#123;</span><br><span class="line">                while (true)&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.setName(&quot;xx&quot;);</span><br><span class="line">        thread.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static void magic(Object obj)  &#123;</span><br><span class="line">    final boolean[] getLock = &#123;false&#125;;</span><br><span class="line">    Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">        synchronized (obj)&#123;</span><br><span class="line">            getLock[0] = true;</span><br><span class="line">            while (true)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.setName(&quot;xx&quot;);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    while (!getLock[0])&#123;//不同处理器可能主线程始终读取到的值为false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static void magic(Object obj)  &#123;</span><br><span class="line">    AtomicBoolean getLock = new AtomicBoolean(false);</span><br><span class="line">    Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">        synchronized (obj)&#123;</span><br><span class="line">            getLock.set(true);</span><br><span class="line">            while (true)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.setName(&quot;xx&quot;);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    while (!getLock.get())&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="wait-amp-notify-notifyall"><a href="#wait-amp-notify-notifyall" class="headerlink" title="wait&amp;notify/notifyall"></a>wait&amp;notify/notifyall</h4><p>  wait是已经获取锁的线程释放锁，然后一直阻塞等待其他线程调用相同锁的notify/notifyall方法；notify/notifyall是已经获取锁的线程释放锁，通知其他阻塞在相同锁的wait方法上的其他一个或多个线程中的一个线程继续执行。</p><p>  wait、notify、notifyall与synchronized配合使用</p><p>  可以得出如下方式：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private static void magic(Object obj)  &#123;</span><br><span class="line">    Object obj2 = new Object();</span><br><span class="line"></span><br><span class="line">    synchronized (obj2)&#123;</span><br><span class="line">        Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (obj)&#123;</span><br><span class="line">                // 锁定obj后，获取obj2的锁，获取成功即可nofity主线程继续执行</span><br><span class="line">                synchronized (obj2)&#123;</span><br><span class="line">                    obj2.notify();</span><br><span class="line">                &#125;</span><br><span class="line">                while (true)&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.setName(&quot;xx&quot;);</span><br><span class="line">        thread.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            obj2.wait();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Condition-amp-Lock"><a href="#Condition-amp-Lock" class="headerlink" title="Condition&amp;Lock"></a>Condition&amp;Lock</h4><p>java的ReentrantLock结合Condition，跟notify/wait机制类似.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static void magic(Object obj)  &#123;</span><br><span class="line">    ReentrantLock reentrantLock = new ReentrantLock();</span><br><span class="line">    Condition childThreadHasGetLock = reentrantLock.newCondition();</span><br><span class="line"></span><br><span class="line">    reentrantLock.lock();</span><br><span class="line"></span><br><span class="line">    Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">        synchronized (obj)&#123;</span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            childThreadHasGetLock.signal();</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line"></span><br><span class="line">            while (true)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread.setName(&quot;xx&quot;);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        childThreadHasGetLock.await();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    reentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>CountDownLatch，闭锁，基于AQS（AQS基于volatitle&amp;CAS），阻塞的线程（一个或多个）一旦等闭锁的初始设置的计数值变为0就会恢复执行，最常用场景就是主线程等待多个外部调用都完成后（n个外部调用，闭锁的计数值为n），恢复执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static void magic(Object obj)  &#123;</span><br><span class="line">    CountDownLatch countDownLatch = new CountDownLatch(1);</span><br><span class="line">    Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">        synchronized (obj)&#123;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">            while (true)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.setName(&quot;xx&quot;);</span><br><span class="line">    thread.start();</span><br><span class="line">    try &#123;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>CyclicBarrier，循环屏障，可以重复使用，基于Lock&amp;Condition（Lock，Condition基于volatitle&amp;CAS）,常用场景是一组线程在一个屏障点集合，所有线程到达后才会恢复线程的执行，可以设置在最后一个线程到达后所有线程恢复执行前的执行操作（一个屏障点只执行一次，可以更新一些状态，共享变量等）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private static void magic(Object obj)  &#123;</span><br><span class="line">    CyclicBarrier cyclicBarrier = new CyclicBarrier(2);</span><br><span class="line">    Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">        synchronized (obj)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; catch (InterruptedException |BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            while (true)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.setName(&quot;xx&quot;);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        cyclicBarrier.await();</span><br><span class="line">    &#125; catch (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h4><p>阶段器，基于volatitle&amp;CAS，多个阶段，多个线程分阶段共同开始去完成每一个阶段（每一个阶段完成线程等待未完成线程）的场景，在这大材小用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private static void magic(Object obj)  &#123;</span><br><span class="line">    Phaser phaser = new Phaser(2);</span><br><span class="line">    Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">        synchronized (obj)&#123;</span><br><span class="line">            phaser.arriveAndAwaitAdvance();</span><br><span class="line">            while (true)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.setName(&quot;xx&quot;);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    phaser.arriveAndAwaitAdvance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>信号量，基于AQS，对有限的资源的并发访问控制，相比于加锁性能更高.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static void magic(Object obj) &#123;</span><br><span class="line">    Semaphore semaphore = new Semaphore(0);</span><br><span class="line">    Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">        synchronized (obj) &#123;</span><br><span class="line">            semaphore.release();// 子线程释放一个信号量，主线程才会继续执行</span><br><span class="line">            while (true) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.setName(&quot;xx&quot;);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        semaphore.acquire();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h4><p>SynchronousQueue简单实现，其他类似Queue也行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static void magic(Object obj) &#123;</span><br><span class="line">      SynchronousQueue&lt;Boolean&gt; synchronousQueue = new SynchronousQueue();</span><br><span class="line">      Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">          synchronized (obj) &#123;</span><br><span class="line">              synchronousQueue.offer(true);</span><br><span class="line">              while (true) &#123;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      thread.setName(&quot;xx&quot;);</span><br><span class="line">      thread.start();</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">          synchronousQueue.take();//获取不到一直阻塞</span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h4><p>lock辅助工具类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> private static void magic(Object obj) &#123;</span><br><span class="line">    Thread mainThread = Thread.currentThread();</span><br><span class="line">    Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">        synchronized (obj) &#123;</span><br><span class="line">            LockSupport.unpark(mainThread);</span><br><span class="line">            while (true) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.setName(&quot;xx&quot;);</span><br><span class="line">    thread.start();</span><br><span class="line">    LockSupport.park();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>线程协作（单进程里的多个线程），通信的方式无非是共享变量即共享内存，锁（java提供的线程通讯机制，wait&amp;notify，lock&amp;condition，CountDownLatch等几个并发辅助类都是），管道（SynchronousQueue是队列，也可以理解为管道一种，PipedInputStream实现类似）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;java线程协作即2个线程如何交互，发信号，告诉对方一些信息，触发对方做一些事情。&lt;/p&gt;
&lt;h3 id=&quot;一道题说起：&quot;&gt;&lt;a href=&quot;#一道题说起：&quot; class=&quot;headerlink&quot; title=&quot;一道题说起：&quot;&gt;&lt;/a&gt;一道题说起：&lt;/h3&gt;&lt;figure 
      
    
    </summary>
    
      <category term="线程" scheme="http://zhangxiangnan.com/categories/%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="线程" scheme="http://zhangxiangnan.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>lambda表达式入门</title>
    <link href="http://zhangxiangnan.com/2018/02/05/java/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8/"/>
    <id>http://zhangxiangnan.com/2018/02/05/java/lambda表达式入门/</id>
    <published>2018-02-05T11:47:07.000Z</published>
    <updated>2019-02-28T12:25:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>lambda表达式入门学习</p><a id="more"></a><h4 id="lambda出现的背景"><a href="#lambda出现的背景" class="headerlink" title="lambda出现的背景"></a>lambda出现的背景</h4><p>如果匿名类的实现起来非常简单,如只有一个方法的接口,那么匿名类的语法使用起来看着会不清晰。</p><p>这些情形,看起来像是把功能当做参数传递到其他方法,如当点击按钮时应该执行的操作。Lambda表达式让我们能够把功能/函数/方法当做参数,或者代码当做数据来传递。</p><p>尽管匿名类比非匿名类简洁,但是对于只有一个方法的类,匿名类仍然有些烦琐。Lambda表达式让我们可以更简洁地表达单方法类的实例对象。</p><h4 id="lambda表达式语法"><a href="#lambda表达式语法" class="headerlink" title="lambda表达式语法"></a>lambda表达式语法</h4><p>lambda表达式如(p,q) -&gt; System.out.print(“x”), 包含如下几部分:</p><ul><li>圆括号里逗号分隔的一个或多个形参列表,注意:<ul><li>形参的数据数据类型可以省略不写</li><li>当只有一个形参时,圆括号也可以省略不写,如p -&gt; System.out.print(“x”)</li></ul></li><li>箭头标记</li><li>一个单独表达式或者代码块,如:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.getGender() == Person.Sex.MALE</span><br><span class="line">    &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">    &amp;&amp; p.getAge() &lt;= 25</span><br></pre></td></tr></table></figure><p>如果是一个单独的表达式,jvm计算表达式的值并返回;此外,也可以使用return语句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p -&gt; &#123;</span><br><span class="line">    return p.getGender() == Person.Sex.MALE</span><br><span class="line">        &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">        &amp;&amp; p.getAge() &lt;= 25;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>return语句不是一个表达式。在lambda表达式里,必须使用{}把return的语句块包起来,但若{}包的语句块中的方法为void方法,则可以省略{},如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">email -&gt; System.out.println(email)</span><br></pre></td></tr></table></figure><p>lambda表达式看着很像一个方法声明,可以将lambda表达式认为是匿名的方法调用。</p><p>lambda表达式也可以有多个形参,如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Calculator &#123;</span><br><span class="line">    interface IntegerMath &#123;</span><br><span class="line">        int operation(int a, int b);   </span><br><span class="line">    &#125;</span><br><span class="line">    public int operateBinary(int a, int b, IntegerMath op) &#123;</span><br><span class="line">        return op.operation(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String... args) &#123;</span><br><span class="line">        Calculator myApp = new Calculator();</span><br><span class="line">        IntegerMath addition = (a, b) -&gt; a + b;</span><br><span class="line">        IntegerMath subtraction = (a, b) -&gt; a - b;</span><br><span class="line">        System.out.println(&quot;40 + 2 = &quot; + myApp.operateBinary(40, 2, addition));</span><br><span class="line">        System.out.println(&quot;20 - 10 = &quot; + myApp.operateBinary(20, 10, subtraction));    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lambda表达式理想用例"><a href="#lambda表达式理想用例" class="headerlink" title="lambda表达式理想用例"></a>lambda表达式理想用例</h4><h5 id="创建找出符合某一个特征的人员的搜索方法-找出年龄大于指定值的人"><a href="#创建找出符合某一个特征的人员的搜索方法-找出年龄大于指定值的人" class="headerlink" title="创建找出符合某一个特征的人员的搜索方法(找出年龄大于指定值的人?)"></a>创建找出符合某一个特征的人员的搜索方法(找出年龄大于指定值的人?)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void printPersonsOlderThan(List&lt;Person&gt; roster, int age) &#123;</span><br><span class="line">    for (Person p : roster) &#123;</span><br><span class="line">        if (p.getAge() &gt;= age) &#123;</span><br><span class="line">            p.printPerson();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考: 不支持泛型,改变Person类型就需要重写方法&amp;只支持大于某个年龄,想要找出小于某个年龄的就..</p><h5 id="创建更通用的搜索方法"><a href="#创建更通用的搜索方法" class="headerlink" title="创建更通用的搜索方法"></a>创建更通用的搜索方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void printPersonsWithinAgeRange(</span><br><span class="line">    List&lt;Person&gt; roster, int low, int high) &#123;</span><br><span class="line">    for (Person p : roster) &#123;</span><br><span class="line">        if (low &lt;= p.getAge() &amp;&amp; p.getAge() &lt; high) &#123;</span><br><span class="line">            p.printPerson();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考:支持小于某个年龄,但是假如想找出某个指定性别、或者指定性别结合年龄条件? 假如Person类增加了关系、地域等属性呢?每种属性定义一个搜索方法也可以,但会散乱,<br>可以将搜索条件单独隔离到其他方法里。</p><h5 id="在局部类中指定搜索条件的代码"><a href="#在局部类中指定搜索条件的代码" class="headerlink" title="在局部类中指定搜索条件的代码"></a>在局部类中指定搜索条件的代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void printPersons(</span><br><span class="line">    List&lt;Person&gt; roster, CheckPerson tester) &#123;</span><br><span class="line">    for (Person p : roster) &#123;</span><br><span class="line">        if (tester.test(p)) &#123;</span><br><span class="line">            p.printPerson();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface CheckPerson &#123;</span><br><span class="line">    boolean test(Person p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CheckPersonSelectiveService implements CheckPerson &#123;</span><br><span class="line">    public boolean test(Person p) &#123;</span><br><span class="line">        return p.gender == Person.Sex.MALE &amp;&amp;</span><br><span class="line">            p.getAge() &gt;= 18 &amp;&amp;</span><br><span class="line">            p.getAge() &lt;= 25;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  调用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printPersons(</span><br><span class="line">    roster, new CheckPersonEligibleForSelectiveService());</span><br></pre></td></tr></table></figure></p><p>  思考:改变person类型不需要重写printPersons方法,但引入一个接口及每一种搜索一个局部实现类,可以将局部实现类改为匿名类。</p><h5 id="匿名类中指定搜索条件代码"><a href="#匿名类中指定搜索条件代码" class="headerlink" title="匿名类中指定搜索条件代码"></a>匿名类中指定搜索条件代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">printPersons(</span><br><span class="line">    roster,</span><br><span class="line">    new CheckPerson() &#123;</span><br><span class="line">        public boolean test(Person p) &#123;</span><br><span class="line">            return p.getGender() == Person.Sex.MALE</span><br><span class="line">                &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">                &amp;&amp; p.getAge() &lt;= 25;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>  思考:改为了匿名类,省去局部类的定义,但是匿名类仍然较烦琐,由于CheckPerson接口只有一个方法,则可以考虑使用lambda表达式替换</p><h5 id="使用lambda表达式替换搜索代码"><a href="#使用lambda表达式替换搜索代码" class="headerlink" title="使用lambda表达式替换搜索代码"></a>使用lambda表达式替换搜索代码</h5><p>CheckPerson是一个函数接口,函数接口是仅有一个抽象方法的任何接口(可能包含多个静态方法或默认方法)。由于函数接口仅有一个方法,因为实现该接口时可以忽略方法名称,如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">printPersons(</span><br><span class="line">    roster,</span><br><span class="line">    (Person p) -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">        &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">        &amp;&amp; p.getAge() &lt;= 25</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>思考:可以使用标准函数接口来进一步减少代码</p><h5 id="使用lambda表达式的标准函数接口"><a href="#使用lambda表达式的标准函数接口" class="headerlink" title="使用lambda表达式的标准函数接口"></a>使用lambda表达式的标准函数接口</h5><p>由于CheckPerson接口仅有一个方法,返回bool值,很简单,不必要在程序中自己定义,所以JDK在java.util.function中提供了若干标准函数接口,可以使用Predicate<t>替换CheckPerson:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Predicate&lt;T&gt; &#123;</span><br><span class="line">    boolean test(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p><p>  这是一个泛型接口,替换CheckPerson,如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void printPersonsWithPredicate(</span><br><span class="line">    List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester) &#123;</span><br><span class="line">    for (Person p : roster) &#123;</span><br><span class="line">        if (tester.test(p)) &#123;</span><br><span class="line">            p.printPerson();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  经过匿名类替换+使用lambda表达式,调用方式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">printPersonsWithPredicate(</span><br><span class="line">    roster,</span><br><span class="line">    p -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">        &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">        &amp;&amp; p.getAge() &lt;= 25</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h5 id="整个程序中使用lambda表达式"><a href="#整个程序中使用lambda表达式" class="headerlink" title="整个程序中使用lambda表达式"></a>整个程序中使用lambda表达式</h5><p> 再考虑这个方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void printPersonsWithPredicate(</span><br><span class="line">    List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester) &#123;</span><br><span class="line">    for (Person p : roster) &#123;</span><br><span class="line">        if (tester.test(p)) &#123;</span><br><span class="line">            p.printPerson();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> p.printPerson()是一个void方法,对p操作,假如不是执行printPerson操作而是执行其他类似void操作,那么就需要修改printPersonsWithPredicate方法,考虑将这个操作使用<br>  lambda表达式,JDK提供了Consumer<t>标准函数接口,可改进如下:</t></p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void processPersons(</span><br><span class="line">    List&lt;Person&gt; roster,</span><br><span class="line">    Predicate&lt;Person&gt; tester,</span><br><span class="line">    Consumer&lt;Person&gt; block) &#123;</span><br><span class="line">        for (Person p : roster) &#123;</span><br><span class="line">            if (tester.test(p)) &#123;</span><br><span class="line">                block.accept(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p> 调用:</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">processPersons(</span><br><span class="line">     roster,</span><br><span class="line">     p -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">         &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">         &amp;&amp; p.getAge() &lt;= 25,</span><br><span class="line">     p -&gt; p.printPerson()</span><br><span class="line">);</span><br></pre></td></tr></table></figure></code></pre><p> 假如想验证人员身份或获取联系信息呢?需要一个函数接口,其有一个抽象方法,返回一个值,The Function&lt;T,R&gt;标准接口有一个R apply(T t)方法,应用到如下示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void processPersonsWithFunction(</span><br><span class="line">    List&lt;Person&gt; roster,</span><br><span class="line">    Predicate&lt;Person&gt; tester,</span><br><span class="line">    Function&lt;Person, String&gt; mapper,</span><br><span class="line">    Consumer&lt;String&gt; block) &#123;</span><br><span class="line">    for (Person p : roster) &#123;</span><br><span class="line">        if (tester.test(p)) &#123;</span><br><span class="line">            String data = mapper.apply(p);</span><br><span class="line">            block.accept(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用(获取每一个人的邮箱信息,并打印):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">processPersonsWithFunction(</span><br><span class="line">    roster,</span><br><span class="line">    p -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">        &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">        &amp;&amp; p.getAge() &lt;= 25,</span><br><span class="line">    p -&gt; p.getEmailAddress(),</span><br><span class="line">    email -&gt; System.out.println(email)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="使用泛型使扩展性更强"><a href="#使用泛型使扩展性更强" class="headerlink" title="使用泛型使扩展性更强"></a>使用泛型使扩展性更强</h5><p>processPersonsWithFunction方法的泛型版本如下:</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;X, Y&gt; void processElements(</span><br><span class="line">    Iterable&lt;X&gt; source,</span><br><span class="line">    Predicate&lt;X&gt; tester,</span><br><span class="line">    Function &lt;X, Y&gt; mapper,</span><br><span class="line">    Consumer&lt;Y&gt; block) &#123;</span><br><span class="line">    for (X p : source) &#123;</span><br><span class="line">        if (tester.test(p)) &#123;</span><br><span class="line">            Y data = mapper.apply(p);</span><br><span class="line">            block.accept(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>  调用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">processElements(</span><br><span class="line">    roster,</span><br><span class="line">    p -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">        &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">        &amp;&amp; p.getAge() &lt;= 25,</span><br><span class="line">    p -&gt; p.getEmailAddress(),</span><br><span class="line">    email -&gt; System.out.println(email)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h4 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h4><p>如下聚合操作:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">roster</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(</span><br><span class="line">        p -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">            &amp;&amp; p.getAge() &gt;= 18</span><br><span class="line">            &amp;&amp; p.getAge() &lt;= 25)</span><br><span class="line">    .map(p -&gt; p.getEmailAddress())</span><br><span class="line">    .forEach(email -&gt; System.out.println(email));</span><br></pre></td></tr></table></figure></p><p> filter、map、foreach都是聚合操作,聚会操作从stream流中获取元素,而不是从集合中。</p><p> 流是一系列元素,跟集合不同,流不是存储元素的数据结构,流从数据源如集合中通过管道/流水线传输元素。<br> 管道/流水线是一系列流操作,一系列聚合操作,如filter-map-foreach。聚合操作通常接受lambda表达式作为参数,来自定义行为。</p><p>管道/流水线包含以下几部分:</p><ul><li>数据源<br>可以是一个集合、数组、一个生成器函数、I/O channel等</li><li>0步或多步中间操作<br>如filter就是中间操作,生成一个符合过滤条件的元素组成的新流</li><li>一个结束操作<br>如forEach生成一个非流的结果,如void、基本类型数据、一个集合。<h5 id="聚合操作与迭代的区别"><a href="#聚合操作与迭代的区别" class="headerlink" title="聚合操作与迭代的区别"></a>聚合操作与迭代的区别</h5>聚合操作如forEach,与迭代器看起来类似,但是有一个根本区别:</li><li>聚合操作使用内部迭代<br>聚合操作使用内部迭代,只需要提供迭代集合,内部迭代可以是顺序迭代,也可以是并行迭代(并行计算,合并结果);迭代器是外部迭代,需要提供迭代集合与迭代方式,是顺序迭代方式。</li><li>聚合操作从流获取数据来处理<br>聚合操作从流获取数据,非集合,所以聚合操作也称为流操作。</li><li>支持传递代码/行为为参数(lambada表达式作为参数)<h4 id="归约操作"><a href="#归约操作" class="headerlink" title="归约操作"></a>归约操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">double average = roster</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(p -&gt; p.getGender() == Person.Sex.MALE)</span><br><span class="line">    .mapToInt(Person::getAge)</span><br><span class="line">    .average()</span><br><span class="line">    .getAsDouble();</span><br></pre></td></tr></table></figure></li></ul><p>JDK有很多结束操作,如average、sum、min、max、count,这些操作通过组合流的元素内容来返回一个值,这些操作叫做归约操作(reduction operations)。<br>JDK也有返回一个集合的归约操作,很多归约操作都是执行一个指定的任务,如计算平均值,元素分组。JDK提供了通用的归约操作,Stream.reduce&amp;Stream.collect</p><h5 id="Stream-reduce"><a href="#Stream-reduce" class="headerlink" title="Stream.reduce"></a>Stream.reduce</h5><p>Stream.reduce是通用的归约操作,如下例则使用了Stream.sum 归约操作:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer totalAge = roster</span><br><span class="line">    .stream()</span><br><span class="line">    .mapToInt(Person::getAge)</span><br><span class="line">    .sum();</span><br></pre></td></tr></table></figure></p><p>使用Stream.reduce实现相同的逻辑如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer totalAgeReduce = roster</span><br><span class="line">   .stream()</span><br><span class="line">   .map(Person::getAge)</span><br><span class="line">   .reduce(</span><br><span class="line">       0,</span><br><span class="line">       (a, b) -&gt; a + b);</span><br></pre></td></tr></table></figure></p><p>reduce操作有2个参数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 第一个为标识元素</span><br><span class="line">    是归约的初始值和当流中无元素时的默认返回值</span><br><span class="line">- 累加器函数</span><br><span class="line">    累加器函数有2个参数,归约的部分结果值和流中的下一个要计算的元素</span><br></pre></td></tr></table></figure></p><p>reduce操作每次都返回一个新值,累加器每次处理完一个元素后也是返回一个新值,所以如果想要归约流的元素为一个更复杂的对象,如集合,由于每次会返回一个新的集合,性能低下,可以用Stream.collect</p><h5 id="Stream-collect"><a href="#Stream-collect" class="headerlink" title="Stream.collect"></a>Stream.collect</h5><p>reduce方法每处理一个元素会新建一个值,collect方法则是修改、转换一个已经存在的值。考虑如何计算流中元素的平均值?需要两份数据,一个是所有元素的个数,一个是其和,和reduce方法以及其他所有<br>归约方法一样,collect也只返回一个值,可以创建一个新的数据类型,包含这两个计数,如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Averager implements IntConsumer &#123;</span><br><span class="line">    private int total = 0;</span><br><span class="line">    private int count = 0;</span><br><span class="line"></span><br><span class="line">    public double average() &#123;</span><br><span class="line">        return count &gt; 0 ? ((double) total)/count : 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void accept(int i) &#123; total += i; count++; &#125;</span><br><span class="line"></span><br><span class="line">    public void combine(Averager other) &#123;</span><br><span class="line">        total += other.total;</span><br><span class="line">        count += other.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Averager averageCollect = roster.stream()</span><br><span class="line">    .filter(p -&gt; p.getGender() == Person.Sex.MALE)</span><br><span class="line">    .map(Person::getAge)</span><br><span class="line">    .collect(Averager::new, Averager::accept, Averager::combine);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;Average age of male members: &quot; +</span><br><span class="line">    averageCollect.average());</span><br></pre></td></tr></table></figure></p><p>该例collect方法有三个参数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- supplier</span><br><span class="line">    结果容器创建函数,工厂方法,为collect操作创建一个新实例,创建结果容器的实例,本例则是创建Averager的实例。</span><br><span class="line">- accumulator</span><br><span class="line">    累加器函数合并一个流元素到结果容器中,本例中,即修改Averager的2个计数</span><br><span class="line">- combiner</span><br><span class="line">    合并函数将两个结果容器的内容进行合并,本例中,为对两个Averager容器中的2个计数进行合并相加。</span><br></pre></td></tr></table></figure></p><p>注意:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- supplier是一个lambda表达式或者方法引用,而非reduce操作中的identity元素是一个值。</span><br><span class="line">- accumulator累加器和combiner合并函数不返回值</span><br><span class="line">- 可以结合并行流使用collect操作</span><br></pre></td></tr></table></figure></p><p>尽管JDK提供了average操作来计算平均值,当我们需要计算流中元素的几个值时就可以使用collect操作+自定义类。<br>collect操作最适合集合,如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; namesOfMaleMembersCollect = roster</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(p -&gt; p.getGender() == Person.Sex.MALE)</span><br><span class="line">    .map(p -&gt; p.getName())</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure></p><p>该例collect只需要一个Collector类型参数,该类封装了collect操作所需的三个参数(supplier、accumulator、combiner),Collectors类包含许多有用的操作,如累加元素到集合,根据不同条件分类元素等。<br>Collectors.toList返回的Collector会累加流元素到一个新list。</p><p>按性别分类:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Person.Sex, List&lt;Person&gt;&gt; byGender =</span><br><span class="line">    roster</span><br><span class="line">        .stream()</span><br><span class="line">        .collect(</span><br><span class="line">            Collectors.groupingBy(Person::getGender));</span><br></pre></td></tr></table></figure></p><p>groupingBy方法根据指定的分类函数(getGener)来分类,返回的map的key为getGender的返回值。</p><p>获取集合中的成员姓名并按性别分类:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Person.Sex, List&lt;String&gt;&gt; namesByGender =</span><br><span class="line">    roster</span><br><span class="line">        .stream()</span><br><span class="line">        .collect(</span><br><span class="line">            Collectors.groupingBy(</span><br><span class="line">                Person::getGender,                      </span><br><span class="line">                Collectors.mapping(</span><br><span class="line">                    Person::getName,</span><br><span class="line">                    Collectors.toList())));</span><br></pre></td></tr></table></figure></p><p>本例的groupingBy方法有2个参数,一个分类函数,一个Collector实例,Collector参数称为下游收集器,该收集器应用到另一个收集器的结果。</p><p>因此,groupingBy操作使你可以应用collect方法到groupingBy操作创建的List结果值上。</p><p>该例中,collector mapping将mapping函数应用到流中的每一个元素上,返回的结果流由会员名称组成;包含一个或多个下流收集器的流水线如本例称作多级归约。</p><p>如下例,获取每一种性别的会员的年龄总和:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Person.Sex, Integer&gt; totalAgeByGender =</span><br><span class="line">    roster</span><br><span class="line">        .stream()</span><br><span class="line">        .collect(</span><br><span class="line">            Collectors.groupingBy(</span><br><span class="line">                Person::getGender,                      </span><br><span class="line">                Collectors.reducing(</span><br><span class="line">                    0,</span><br><span class="line">                    Person::getAge,</span><br><span class="line">                    Integer::sum)));</span><br></pre></td></tr></table></figure></p><p>Collectors.reducing归约操作有三个参数:</p><ul><li>identity:<br> 如Stream.reduce操作一样,identity是归约的初始值和默认值(如果流中没有元素),上例中,identity为0</li><li>mapper:<br>归约操作将mapper函数应用到所有流元素,本例是获取每个成员的年龄</li><li>operation:<br>操作函数用来归约映射的值,本例是对年龄求和</li></ul><p>下例是获取每种性别的会员的平均年龄:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Person.Sex, Double&gt; averageAgeByGender = roster</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(</span><br><span class="line">        Collectors.groupingBy(</span><br><span class="line">            Person::getGender,                      </span><br><span class="line">            Collectors.averagingInt(Person::getAge)));</span><br></pre></td></tr></table></figure></p><h4 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h4><p>并行计算涉及到将一个问题分为多个子问题,同时解决子问题(并行中,每一个子问题在一个独立线程中运行),然后合并各个子问题的结果。<br>JavaSE提供了fork/join框架,可以让我们很方便地实现并行计算,然而用这个框架的话,必须指定如何划分问题,通过聚合操作就可以进行问题划分和结果合并。</p><p>对于使用集合的情形,并行计算的一个难点就是操作集合时的线程安全问题,虽然集合框架的同步方法是线程安全的,但是会导致线程竞争,达不到并行的目的。<br>聚合操作以及并行流使我们能够实现提供的非线程安全性集合的并行性,在操作集合时不需要修改集合。<br>注意,并行并不一定比串行快,当有足够的数据和处理器核心时可能并行更有优势。所以,即使聚合操作让我们更容易实现并行计算,但是也要考虑是否适合并行。</p><h5 id="并行执行流操作"><a href="#并行执行流操作" class="headerlink" title="并行执行流操作"></a>并行执行流操作</h5><p>流可以串行执行,也可以并行执行,当并行执行流时,jvm将流分为多个子流,聚合操作并行的迭代处理这些流,并把结果合并。<br>当创建一个流时,默认是串行流,除非使用Collection.parallelStream或者BaseStream.parallel指定为并行流。如下例,并行计算男士的平均年龄:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">double average = roster</span><br><span class="line">    .parallelStream()</span><br><span class="line">    .filter(p -&gt; p.getGender() == Person.Sex.MALE)</span><br><span class="line">    .mapToInt(Person::getAge)</span><br><span class="line">    .average()</span><br><span class="line">    .getAsDouble();</span><br></pre></td></tr></table></figure></p><h5 id="并发归约"><a href="#并发归约" class="headerlink" title="并发归约"></a>并发归约</h5><p>再考虑如下例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Person.Sex, List&lt;Person&gt;&gt; byGender =</span><br><span class="line">    roster</span><br><span class="line">        .stream()</span><br><span class="line">        .collect(</span><br><span class="line">            Collectors.groupingBy(Person::getGender));</span><br></pre></td></tr></table></figure></p><p>对应的并行代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentMap&lt;Person.Sex, List&lt;Person&gt;&gt; byGender =</span><br><span class="line">    roster</span><br><span class="line">        .parallelStream()</span><br><span class="line">        .collect(</span><br><span class="line">            Collectors.groupingByConcurrent(Person::getGender));</span><br></pre></td></tr></table></figure></p><p>上例称作并发归约,jvm在以下条件都为真时会为包含collect操作的指定流水线执行并发归约:</p><ul><li>流是并行流</li><li>collect操作的collector参数的Collector.Characteristics为并发模式,通过Collector.characteristics方法设置</li><li>无论流式无序,或者collector设置了Collector.Characteristics.UNORDERED;确保流式无序的,可以通过BaseStream.unordered操作</li></ul><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>pipeline处理流中元素的顺序依赖于流是串行执行还是并行执行,以及流的数据源本身和中间操作,如下例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Integer[] intArray = &#123;1, 2, 3, 4, 5, 6, 7, 8 &#125;;</span><br><span class="line">List&lt;Integer&gt; listOfIntegers =</span><br><span class="line">    new ArrayList&lt;&gt;(Arrays.asList(intArray));</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;listOfIntegers:&quot;);</span><br><span class="line">listOfIntegers</span><br><span class="line">    .stream()</span><br><span class="line">    .forEach(e -&gt; System.out.print(e + &quot; &quot;));</span><br><span class="line">System.out.println(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;listOfIntegers sorted in reverse order:&quot;);</span><br><span class="line">Comparator&lt;Integer&gt; normal = Integer::compare;</span><br><span class="line">Comparator&lt;Integer&gt; reversed = normal.reversed();</span><br><span class="line">Collections.sort(listOfIntegers, reversed);  </span><br><span class="line">listOfIntegers</span><br><span class="line">    .stream()</span><br><span class="line">    .forEach(e -&gt; System.out.print(e + &quot; &quot;));</span><br><span class="line">System.out.println(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;Parallel stream&quot;);</span><br><span class="line">listOfIntegers</span><br><span class="line">    .parallelStream()</span><br><span class="line">    .forEach(e -&gt; System.out.print(e + &quot; &quot;));</span><br><span class="line">System.out.println(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;Another parallel stream:&quot;);</span><br><span class="line">listOfIntegers</span><br><span class="line">    .parallelStream()</span><br><span class="line">    .forEach(e -&gt; System.out.print(e + &quot; &quot;));</span><br><span class="line">System.out.println(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;With forEachOrdered:&quot;);</span><br><span class="line">listOfIntegers</span><br><span class="line">    .parallelStream()</span><br><span class="line">    .forEachOrdered(e -&gt; System.out.print(e + &quot; &quot;));</span><br><span class="line">System.out.println(&quot;&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">listOfIntegers:</span><br><span class="line">1 2 3 4 5 6 7 8</span><br><span class="line">listOfIntegers sorted in reverse order:</span><br><span class="line">8 7 6 5 4 3 2 1</span><br><span class="line">Parallel stream:</span><br><span class="line">3 4 1 6 2 5 7 8</span><br><span class="line">Another parallel stream:</span><br><span class="line">6 3 1 5 7 8 4 2</span><br><span class="line">With forEachOrdered:</span><br><span class="line">8 7 6 5 4 3 2 1</span><br></pre></td></tr></table></figure></p><h4 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h4><p>一个方法或一个表达式除了返回值及生成一个值,还有一个副作用就是会修改计算机的状态,如可变的reductions操作(collect操作)及System.out.println。<br>JDK对某些副作用处理的很好,特别地,collect方法就是设计针对并行安全有副作用的场景下来执行最常见的stream操作。类似forEach、peek操作可以消除副作用;lambda表达式即使返回void,但如果内部调用了System.out.println,<br>也会产生副作用。</p><h5 id="延迟计算-惰性计算"><a href="#延迟计算-惰性计算" class="headerlink" title="延迟计算/惰性计算"></a>延迟计算/惰性计算</h5><p>所有中间操作都是延迟执行的,表达式、方法或算法如果仅仅在需要的时候才计算其值,则就是延迟计算。中间操作是延迟计算因为当终结操作开始时,才会处理流中的数据。延迟处理流的机制让java编译器及运行时<br>能够优化处理流的方式。比如filter-mapToInt-average流水线操作average可以先从mapToInt操作创建的流中获取几个数,mapToInt则是从filter操作获取元素,average操作则重复着这个流程直至获取所有的数据,然后计算平均值。</p><h5 id="干扰"><a href="#干扰" class="headerlink" title="干扰"></a>干扰</h5><p>流操作中的lambda表达式不应该有干扰。干扰发生在一个流水线处理流时,流的数据源被修改,如下例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    List&lt;String&gt; listOfStrings =</span><br><span class="line">        new ArrayList&lt;&gt;(Arrays.asList(&quot;one&quot;, &quot;two&quot;));</span><br><span class="line"></span><br><span class="line">    String concatenatedString = listOfStrings</span><br><span class="line">        .stream()</span><br><span class="line"></span><br><span class="line">        // 不要在处理流时,对流的数据源进行修改,会发生干扰,导致报错</span><br><span class="line">        .peek(s -&gt; listOfStrings.add(&quot;three&quot;))</span><br><span class="line">        .reduce((a, b) -&gt; a + &quot; &quot; + b)</span><br><span class="line">        .get();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;Concatenated string: &quot; + concatenatedString);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    System.out.println(&quot;Exception caught: &quot; + e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="有状态的lambda表达式"><a href="#有状态的lambda表达式" class="headerlink" title="有状态的lambda表达式"></a>有状态的lambda表达式</h5><p>在流操作中避免使用有状态的lambda表达式当做参数,有状态的lambda表达式是指其结果依赖于在流水线执行过程中可能改变的任何状态,如下例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; serialStorage = new ArrayList&lt;&gt;();</span><br><span class="line">System.out.println(&quot;Serial stream:&quot;);</span><br><span class="line">listOfIntegers</span><br><span class="line">    .stream()</span><br><span class="line">    // 不要这么做,其使用了有状态的lambda表达式</span><br><span class="line">    .map(e -&gt; &#123; serialStorage.add(e); return e; &#125;)</span><br><span class="line"></span><br><span class="line">    .forEachOrdered(e -&gt; System.out.print(e + &quot; &quot;));</span><br><span class="line">System.out.println(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">serialStorage</span><br><span class="line">    .stream()</span><br><span class="line">    .forEachOrdered(e -&gt; System.out.print(e + &quot; &quot;));</span><br><span class="line">System.out.println(&quot;&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(&quot;Parallel stream:&quot;);</span><br><span class="line">List&lt;Integer&gt; parallelStorage = Collections.synchronizedList(</span><br><span class="line">    new ArrayList&lt;&gt;());</span><br><span class="line">listOfIntegers</span><br><span class="line">    .parallelStream()</span><br><span class="line"></span><br><span class="line">    // 使用了有状态的lambda表达式</span><br><span class="line">    .map(e -&gt; &#123; parallelStorage.add(e); return e; &#125;)</span><br><span class="line"></span><br><span class="line">    .forEachOrdered(e -&gt; System.out.print(e + &quot; &quot;));</span><br><span class="line">System.out.println(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">parallelStorage</span><br><span class="line">    .stream()</span><br><span class="line">    .forEachOrdered(e -&gt; System.out.print(e + &quot; &quot;));</span><br><span class="line">System.out.println(&quot;&quot;);</span><br></pre></td></tr></table></figure></p><p>lambda表达式 e -&gt; { parallelStorage.add(e); return e; } 是有状态的lambda表达式,因为每次代码运行其结果都会不同:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Serial stream:</span><br><span class="line">8 7 6 5 4 3 2 1</span><br><span class="line">8 7 6 5 4 3 2 1</span><br><span class="line">Parallel stream:</span><br><span class="line">8 7 6 5 4 3 2 1</span><br><span class="line">1 3 6 2 4 5 8 7</span><br></pre></td></tr></table></figure></p><p>若想要可预测性及确定性结果,要确保流操作中的lambda表达式参数是无状态的。</p><p>注意:ArrayList是非线程安全的,即多个线程不能同时访问指定集合,否则会导致不可预料结果,如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Parallel stream:</span><br><span class="line">8 7 6 5 4 3 2 1</span><br><span class="line">null 3 5 4 7 8 1 2</span><br></pre></td></tr></table></figure></p><h4 id="访问外部范围的局部变量"><a href="#访问外部范围的局部变量" class="headerlink" title="访问外部范围的局部变量"></a>访问外部范围的局部变量</h4><p> 和局部和匿名类类似,lambda表达式也能够捕捉变量,也可以访问外部范围的局部变量,但是不会覆盖外部范围的局部变量。</p><p> 这是因为lambda表达式从词法上被隔离,不会从超类继承任何变量,也不会引入新的变量作用范围,<br> lambda表达式里声明的变量被封闭在lambda表达式里, 如下例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import java.util.function.Consumer;</span><br><span class="line">public class LambdaScopeTest &#123;</span><br><span class="line">    public int x = 0;</span><br><span class="line"></span><br><span class="line">    class FirstLevel &#123;</span><br><span class="line">        public int x = 1;</span><br><span class="line">        void methodInFirstLevel(int x) &#123;</span><br><span class="line"></span><br><span class="line">            Consumer&lt;Integer&gt; myConsumer = (y) -&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(&quot;x = &quot; + x); // Statement A</span><br><span class="line">                System.out.println(&quot;y = &quot; + y);</span><br><span class="line">                System.out.println(&quot;this.x = &quot; + this.x);</span><br><span class="line">                System.out.println(&quot;LambdaScopeTest.this.x = &quot; + LambdaScopeTest.this.x);</span><br><span class="line">            &#125;;</span><br><span class="line">            myConsumer.accept(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String... args) &#123;</span><br><span class="line">        LambdaScopeTest st = new LambdaScopeTest();</span><br><span class="line">        LambdaScopeTest.FirstLevel fl = st.new FirstLevel();</span><br><span class="line">        fl.methodInFirstLevel(23);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x = 23</span><br><span class="line">y = 23</span><br><span class="line">this.x = 1</span><br><span class="line">LambdaScopeTest.this.x = 0</span><br></pre></td></tr></table></figure></p><p>假如把lambda表达式声明替换为如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;Integer&gt; myConsumer = (x) -&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>则会报x已定义的错,这是因为lambda表达式不会引入新的变量作用范围,因此在lambda表达式内部可以直接访问外部范围的字段、方法、局部变量,比如可以直接访问methodInFirstLevel方法形参x,但是要访问FirstLevel<br>的字段x,则需要使用this.</p><h4 id="目标类型"><a href="#目标类型" class="headerlink" title="目标类型"></a>目标类型</h4><p>lambda表达式的类型如何确定呢?是通过目标类型,即如public static void printPersons(List<person> roster, CheckPerson tester)需要CheckPerson类型,则lambda表达式就是该类型(方法声明需要的参数类型)。</person></p><p>java编译器根据lambda表达式使用的上下文或场景里找到目标类型当做lambda表达式的类型,也就是lambda只能用在java编译器能确定目标类型的场景里:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- 变量声明</span><br><span class="line">- 赋值</span><br><span class="line">- return 语句</span><br><span class="line">- 数组初始化</span><br><span class="line">- 方法或者构造函数参数</span><br><span class="line">- lambda表达式体</span><br><span class="line">- ? : 三元表达式</span><br><span class="line">- 转换语句</span><br></pre></td></tr></table></figure></p><p>对于方法参数,java编译器确定lambda表达式类型通过2个特征:重载解析&amp;类型参数推导</p><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>如同非静态内部类一样,强烈建议禁止lambda表达式的序列化。</p><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>我们使用lambda表达式来创建匿名方法时,有时lambda表达式啥也没做只是调用了一个已经存在的方法,针对这些情形,通过方法名称来引用已经存在的方法更简洁直观,方法引用可以做到这点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(rosterAsArray, Person::compareByAge);</span><br></pre></td></tr></table></figure></p><h5 id="方法引用的种类"><a href="#方法引用的种类" class="headerlink" title="方法引用的种类"></a>方法引用的种类</h5><ul><li>引用静态方法<br>  ContainingClass::staticMethodName</li><li>引用非静态实例方法<br>containingObject::instanceMethodName</li><li>引用某个类型的任意对象的实例方法<br>  ContainingType::methodName,如String::compareToIgnoreCase</li><li>引用构造方法<br>  ClassName::new</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;lambda表达式入门学习&lt;/p&gt;
    
    </summary>
    
      <category term="lambda" scheme="http://zhangxiangnan.com/categories/lambda/"/>
    
    
      <category term="lambda" scheme="http://zhangxiangnan.com/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>静态内部类&amp;非静态内部类&amp;局部类&amp;匿名类</title>
    <link href="http://zhangxiangnan.com/2018/01/18/java/%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB-%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB-%E5%B1%80%E9%83%A8%E7%B1%BB-%E5%8C%BF%E5%90%8D%E7%B1%BB/"/>
    <id>http://zhangxiangnan.com/2018/01/18/java/静态内部类-非静态内部类-局部类-匿名类/</id>
    <published>2018-01-18T11:22:06.000Z</published>
    <updated>2019-03-01T16:39:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>  静态内部类&amp;非静态内部类&amp;局部类&amp;匿名类学习笔记</p>  <a id="more"></a><h4 id="内部类-嵌套类"><a href="#内部类-嵌套类" class="headerlink" title="内部类/嵌套类"></a>内部类/嵌套类</h4><h5 id="内部类的定义"><a href="#内部类的定义" class="headerlink" title="内部类的定义"></a>内部类的定义</h5><p>Java语言支持在一个类中定义其他类,叫做内部类,分为2种,若用static修饰,则是静态内部类,否则为非静态内部类,如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class OuterClass &#123;</span><br><span class="line">    static class StaticNestedClass &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    class InnerClass &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意:</p><ul><li>内部类是封闭类/外部类的一个成员,因此内部类可以被声明为private、public、protected、包级private(默认),而外部类只能用public、或包级private修饰。</li><li>非静态内部类可以访问外部类的成员,即时是私有成员,静态内部类则不能访问外部类的成员。</li></ul><h5 id="为什么用内部类"><a href="#为什么用内部类" class="headerlink" title="为什么用内部类"></a>为什么用内部类</h5><ul><li>逻辑分类<br> 如果一个类只会在另一个类中使用,那么将其嵌入到那个类中就很合理,也有利于包结构的精简</li><li>有助于封装<br> 如果有A、B两个类,A的成员为私有,且B只会配合A使用,此时,B如果定义为单独的类就无法访问A的成员,但是如果把A嵌入到B中,则可以访问A的私有成员,且B也可以和外部隔离(因为B只会在A中使用)。</li><li>更高地可读性、可维护性<br> 小的类嵌入到其他类中,可读性更强</li></ul><h5 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h5><p>类似于方法和变量,静态内部类和外部类关联,如静态类方法一样,静态内部类不能直接引用外部类中定义的实例变量或方法,只能通过对象来间接引用。</p><p>注意:静态内部类和外部类的实例对象成员交互时和其他正常类一样,实际上静态内部类和其他正常类一样。</p><p>使用外部类名称来访问静态内部类,如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OuterClass.StaticNestedClass</span><br></pre></td></tr></table></figure></p><p>创建静态内部类的对象实例语法如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OuterClass.StaticNestedClass nestedObject =</span><br><span class="line">     new OuterClass.StaticNestedClass();</span><br></pre></td></tr></table></figure></p><h5 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h5><p>类似于实例方法和实例变量,非静态内部类和外部类的实例相关联,可以直接访问外部类实例的方法和字段,同时非静态内部类本身不能定义任何静态成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class OuterClass &#123;</span><br><span class="line">    class InnerClass &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InnerClass的实例只能存在于OuterClass的实例中,同时能直接访问外部类实例的方法和字段。<br>要实例化内部InnerClass类,必须首先实例化OuterClass外部类,然后使用以下语法在外部对象中创建内部类的对象:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OuterClass.InnerClass innerObject = outerObject.new InnerClass();</span><br></pre></td></tr></table></figure><p>有两种特殊的非静态内部类,局部类&amp;匿名类</p><h5 id="Shadowing"><a href="#Shadowing" class="headerlink" title="Shadowing"></a>Shadowing</h5><p>如果在一个特定范围(如非静态内部类或者方法声明)中,一个类型的声明(如一个成员变量或者参数名称)与外部范围里的另一个声明名称一样的话,那么该类型声明会覆盖外部范围的声明。<br>想要访问被覆盖的声明,仅仅用名称是不够的,如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ShadowTest &#123;</span><br><span class="line">    public int x = 0;</span><br><span class="line"></span><br><span class="line">    class FirstLevel &#123;</span><br><span class="line">        public int x = 1;</span><br><span class="line">        void methodInFirstLevel(int x) &#123;</span><br><span class="line">            System.out.println(&quot;x = &quot; + x);</span><br><span class="line">            System.out.println(&quot;this.x = &quot; + this.x);</span><br><span class="line">            System.out.println(&quot;ShadowTest.this.x = &quot; + ShadowTest.this.x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String... args) &#123;</span><br><span class="line">        ShadowTest st = new ShadowTest();</span><br><span class="line">        ShadowTest.FirstLevel fl = st.new FirstLevel();</span><br><span class="line">        fl.methodInFirstLevel(23);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = 23</span><br><span class="line">this.x = 1</span><br><span class="line">ShadowTest.this.x = 0</span><br></pre></td></tr></table></figure><h5 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h5><p>强烈禁止非静态内部类、包括局部类及匿名类的序列化,这是因为编译器编译这些类时,会创建合成的构造方法,合成构造方法让java编译器能够实现新的java语言特征,而不需要改变jvm,<br>但是由于不同的java编译器实现中合成的构造方法不同,所以序列化与反序列化时若使用的jre实现不同会遇到兼容性问题。</p><h4 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h4><p>局部类是定义在代码块中的类,代码块指{}之间的零个或多个语句,经常是在方法内部定义局部类</p><h5 id="定义局部类"><a href="#定义局部类" class="headerlink" title="定义局部类"></a>定义局部类</h5><p>本地类/局部类是指在代码块中定义的类,代码块指{}括起来的0个或多个语句的组合体,经常是在方法中定义局部类.<br>可以在任何代码块中定义局部类,如可以在方法内部、for循环中、if语句中定局部类。如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class LocalCalssTest &#123;</span><br><span class="line">    private int name ;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        class LocalClass &#123;</span><br><span class="line">          private int age;</span><br><span class="line">        &#125;</span><br><span class="line">        int age = new LocalClass().age;</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="访问外部类-封装类的成员"><a href="#访问外部类-封装类的成员" class="headerlink" title="访问外部类/封装类的成员"></a>访问外部类/封装类的成员</h5><p>局部类可以访问外部类/封装类的成员,上个例子中,LocalClass就可以访问name属性。此外,局部类也可以访问定义为final的局部变量或参数.jdk8后final或等效final(初始化后无更改指令)的都可以访问。<br>jdk8开始,如果在方法中定义局部类,那么该局部类可以访问方法的参数。</p><h5 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h5><p>局部类中一个类型或变量的声明会覆盖外部类中相同名字类型或变量的声明。</p><h5 id="局部类类似于非静态内部类"><a href="#局部类类似于非静态内部类" class="headerlink" title="局部类类似于非静态内部类"></a>局部类类似于非静态内部类</h5><p>2者类似因为都不能定义或声明任何静态成员,静态方法里定义的局部类也仅只能访问外部类的静态成员。</p><p>代码块中不能定义接口,因为接口本质上是静态的,所以如下编译不通过:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void greetInEnglish() &#123;</span><br><span class="line">    interface HelloThere &#123;</span><br><span class="line">       public void greet();</span><br><span class="line">    &#125;</span><br><span class="line">    class EnglishHelloThere implements HelloThere &#123;</span><br><span class="line">        public void greet() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部类中也不能定义静态的方法、静态成员,如下编译不通过:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void sayGoodbyeInEnglish() &#123;</span><br><span class="line">    class EnglishGoodbye &#123;</span><br><span class="line">        public static void sayGoodbye() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部类可以有是常量变量的静态成员</p><ul><li>常量变量指基本类型的变量,或声明为final的对象类型并且是使用编译期常量表达式初始化</li><li>编译期常量表达式指如string的””初始化形式,或者表达式的值在编译器可以计算得到。</li></ul><h4 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h4><p>匿名类使代码更加简洁,可以同时进行类的声明和实例化,类似于局部类除了没名字,用于只使用局部类一次的情形。</p><h5 id="声明匿名类"><a href="#声明匿名类" class="headerlink" title="声明匿名类"></a>声明匿名类</h5><p>局部类是有类声明的,匿名类是通过表达式来定义的,如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorldAnonymousClasses &#123;</span><br><span class="line">    interface HelloWorld &#123;</span><br><span class="line">        public void greet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        class EnglishGreeting implements HelloWorld &#123;</span><br><span class="line">            public void greet() &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HelloWorld englishGreeting = new EnglishGreeting();</span><br><span class="line">        HelloWorld frenchGreeting = new HelloWorld() &#123;</span><br><span class="line">            public void greet() &#123;</span><br><span class="line">                greetSomeone(&quot;tout le monde&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="匿名类的语法"><a href="#匿名类的语法" class="headerlink" title="匿名类的语法"></a>匿名类的语法</h5><p>匿名类是一个表达式,匿名类表达式的语法和构造函数的调用类似,只是在代码块中进行类定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HelloWorld frenchGreeting = new HelloWorld() &#123;</span><br><span class="line">    public void greet() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>匿名类表达式包含如下几部分:</p><ul><li>new操作符</li><li>接口或抽象类的名称</li><li>圆括号把传递给构造函数的参数括起来,类似正常类实例的创建,接口无参数。</li><li>类声明的主体,允许定义方法,不能使用语句。</li></ul><p>因为匿名类定义是一个表达式,表达式必须是语句的一部分,所以以分号结束。</p><h5 id="声明及访问变量说明"><a href="#声明及访问变量说明" class="headerlink" title="声明及访问变量说明"></a>声明及访问变量说明</h5><p>匿名类可以访问外部域的局部变量:</p><ul><li>匿名类可以访问外部类的成员</li><li>匿名类不能访问外部范围中定义的非final或非等效final的局部变量</li><li>和嵌套类类型,匿名类中类型的声明如变量会覆盖外部范围中有相同名称的定义</li></ul><p>匿名类中的成员定义和局部类一样也有约束:</p><ul><li>匿名类中不能声明静态的成员(非final)、静态方法</li><li>匿名类可以声明是常量变量的静态成员。</li></ul><p>匿名类中可以声明以下部分:</p><ul><li>字段</li><li>额外的方法(未实现父类抽象方法或接口方法)</li><li>局部/本地类</li><li>实例初始化</li></ul><p>匿名类中不能定义构造函数</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  静态内部类&amp;amp;非静态内部类&amp;amp;局部类&amp;amp;匿名类学习笔记&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://zhangxiangnan.com/categories/java/"/>
    
    
      <category term="generics" scheme="http://zhangxiangnan.com/tags/generics/"/>
    
      <category term="java" scheme="http://zhangxiangnan.com/tags/java/"/>
    
      <category term="javadoc" scheme="http://zhangxiangnan.com/tags/javadoc/"/>
    
  </entry>
  
  <entry>
    <title>java注解详解</title>
    <link href="http://zhangxiangnan.com/2018/01/05/java/java%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/"/>
    <id>http://zhangxiangnan.com/2018/01/05/java/java注解详解/</id>
    <published>2018-01-05T11:16:57.000Z</published>
    <updated>2019-03-01T16:41:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>java注解学习</p><a id="more"></a><p>注解是元数据的一种形式,提供程序相关的数据,但不是程序本身的一部分,注解不会直接操作他们所标注的代码。</p><p>注解有很多用途:</p><ul><li>编译器所需的信息,如编译器可以用注解来检测错误或禁止警告</li><li>编译时或发布时处理,如软件工具可以处理注解信息来生成代码、xml文件等</li><li>运行时处理,某些注解在运行时也可以检测到</li></ul><h4 id="注解基本点"><a href="#注解基本点" class="headerlink" title="注解基本点"></a>注解基本点</h4><h5 id="注解的形式"><a href="#注解的形式" class="headerlink" title="注解的形式"></a>注解的形式</h5><p>最简单的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br></pre></td></tr></table></figure></p><p>@符号后的信息对编译器表明这是一个注解。</p><p>以下注解的名称是Override:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">void mySuperMethod() &#123;  &#125;</span><br></pre></td></tr></table></figure></p><p>注解也可以包含元素,元素可以有名称,也可以没有名称,他们也有对应的值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Author(</span><br><span class="line">   name = &quot;Benjamin Franklin&quot;,</span><br><span class="line">   date = &quot;3/27/2003&quot;</span><br><span class="line">)</span><br><span class="line">class MyClass() &#123; &#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(value = &quot;unchecked&quot;)</span><br><span class="line">void myMethod() &#123; &#125;</span><br></pre></td></tr></table></figure></p><p>如果只有一个命为value的元素,那么名称可以省略,如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">void myMethod() &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>如果注解没有元素,那么圆括号可以省略,如@Override注解的例子。</p><p>在相同声明的位置可以使用多个注解:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Author(name = &quot;Jane Doe&quot;)</span><br><span class="line">@EBook</span><br><span class="line">class MyClass &#123; &#125;</span><br></pre></td></tr></table></figure></p><p>如果注解有相同的类型,称为可重复注解(&gt;=Jdk8):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Author(name = &quot;Jane Doe&quot;)</span><br><span class="line">@Author(name = &quot;John Smith&quot;)</span><br><span class="line">class MyClass &#123; &#125;</span><br></pre></td></tr></table></figure></p><p>注解可以使用java.lang或java.lang.annotation包下定义的注解,也可以使用自定义注解。</p><h5 id="注解可以用在哪儿"><a href="#注解可以用在哪儿" class="headerlink" title="注解可以用在哪儿"></a>注解可以用在哪儿</h5><p>注解可以用在声明的地方:</p><ul><li>类/接口(含注解类型)/枚举声明</li><li>方法声明</li><li>字段(含枚举常量)声明</li><li>形参声明</li><li>构造函数声明</li><li>本地变量声明</li><li>注解类型声明</li><li>包声明</li><li>类型参数声明</li><li>类型的使用</li></ul><p>使用时注解约定占一行。</p><h5 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h5><p>Java8中支持类型使用的注解,称为类型注解,如:<br>实例化对象的表达式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new @Interned MyObject();</span><br></pre></td></tr></table></figure></p><p>类型强转:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myString = (@NonNull String) str;</span><br></pre></td></tr></table></figure></p><p>implements子句:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class UnmodifiableList&lt;T&gt; implements</span><br><span class="line">    @Readonly List&lt;@Readonly T&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure></p><p>异常声明:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void monitorTemperature() throws</span><br><span class="line">    @Critical TemperatureException &#123;  &#125;</span><br></pre></td></tr></table></figure><h4 id="定义注解类型"><a href="#定义注解类型" class="headerlink" title="定义注解类型"></a>定义注解类型</h4><p>注解可以替换注释为代码,设想:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Generation3List extends Generation2List &#123;</span><br><span class="line">   // Author: John Doe</span><br><span class="line">   // Date: 3/17/2002</span><br><span class="line">   // Current revision: 6</span><br><span class="line">   // Last modified: 4/12/2004</span><br><span class="line">   // By: Jane Doe</span><br><span class="line">   // Reviewers: Alice, Bill, Cindy</span><br><span class="line">   // class code goes here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将这些注释信息如何转化为一个注解?首先必须定一个注解类型,如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface ClassPreamble &#123;</span><br><span class="line">   String author();</span><br><span class="line">   String date();</span><br><span class="line">   int currentRevision() default 1;</span><br><span class="line">   String lastModified() default &quot;N/A&quot;;</span><br><span class="line">   String lastModifiedBy() default &quot;N/A&quot;;</span><br><span class="line">   // Note use of array</span><br><span class="line">   String[] reviewers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注解类型的定义有点像接口的声明,但是在interface关键字前加@符号。注解是接口的一种形式,其元素的声明像方法,可以指定默认值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ClassPreamble (</span><br><span class="line">   author = &quot;John Doe&quot;,</span><br><span class="line">   date = &quot;3/17/2002&quot;,</span><br><span class="line">   currentRevision = 6,</span><br><span class="line">   lastModified = &quot;4/12/2004&quot;,</span><br><span class="line">   lastModifiedBy = &quot;Jane Doe&quot;,</span><br><span class="line">   // Note array notation</span><br><span class="line">   reviewers = &#123;&quot;Alice&quot;, &quot;Bob&quot;, &quot;Cindy&quot;&#125;</span><br><span class="line">)</span><br><span class="line">public class Generation3List extends Generation2List &#123;&#125;</span><br></pre></td></tr></table></figure><p>注意:如果想在Javadoc生成的文档中包含@ClassPreamble中描述的信息,需要在其注解的定义上加@Documented注解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@interface ClassPreamble &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="已有注解类型"><a href="#已有注解类型" class="headerlink" title="已有注解类型"></a>已有注解类型</h4><p>Java预先定义了一些注解,有些被java编译器使用,有些应用到其他注解中。</p><h5 id="java语言使用的注解"><a href="#java语言使用的注解" class="headerlink" title="java语言使用的注解"></a>java语言使用的注解</h5><p>java.lang定义的注解为:@Deprecated, @Override, and @SuppressWarnings.</p><h6 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h6><p>该注解表明被标注的元素已过时,不该再被使用。使用有过时注解标注的方法、类、字段,编译器都会警告。如果元素过时,也应该使用Javadc的过时标记@deprecated来标注,两个注解一个大写,一个小写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Javadoc comment follows</span><br><span class="line"> /**</span><br><span class="line">  * @deprecated</span><br><span class="line">  * explanation of why it was deprecated</span><br><span class="line">  */</span><br><span class="line"> @Deprecated</span><br><span class="line"> static void deprecatedMethod() &#123; &#125;</span><br></pre></td></tr></table></figure></p><h6 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h6><p>@Override注解通知编译器被标注元素覆盖了父类的元素:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 重写方法约定加覆盖注解</span><br><span class="line">@Override</span><br><span class="line">int overriddenMethod() &#123; &#125;</span><br></pre></td></tr></table></figure></p><p>虽然不强制使用覆盖标记,但是使用了有助于发现错误。</p><h6 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h6><p>@SuppressWarnings注解告诉编译器忽略可能产生的某种特定的警告,如下忽略了过时方法调用警告:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line"> void useDeprecatedMethod() &#123;</span><br><span class="line">     // deprecation warning</span><br><span class="line">     // - suppressed</span><br><span class="line">     objectOne.deprecatedMethod();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>每一种编译器警告都属于一个分类,java语言规范定义了2中分类:deprecation and unchecked. 想要忽略多种分类的警告,如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;deprecation&quot;&#125;)</span><br></pre></td></tr></table></figure></p><h6 id="SafeVarargs"><a href="#SafeVarargs" class="headerlink" title="@SafeVarargs"></a>@SafeVarargs</h6><p>@SafeVarargs注解当使用在方法或构造函数上时,断言了代码不可能对可变参数执行潜在的不安全操作。当使用该注解后,跟可变参数使用相关的unchecked警告会被忽略。</p><h6 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="@FunctionalInterface"></a>@FunctionalInterface</h6><p>@FunctionalInterface在java8中引入,表明当前类型声明是一个函数接口。</p><h5 id="应用到其他注解的注解"><a href="#应用到其他注解的注解" class="headerlink" title="应用到其他注解的注解"></a>应用到其他注解的注解</h5><p>这类注解成为元注解, java.lang.annnotation中定义的几个元注解如下:</p><h6 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h6><p>@Retention注解指明了被标记注解如何存储:</p><ul><li>RetentionPolicy.SOURCE, 被标记注解仅仅在源文件级别保留,编译时被忽略</li><li>RetentionPolicy.CLASS ,被标记注解在编译时被编译器保留,但是在JVM运行时被忽略</li><li>RetentionPolicy.RUNTIME ,被标记注解被jvm保留,在运行时环境中可以使用</li></ul><h6 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h6><p>@Documented注解表示被标注的注解在使用Javadoc工具生成文档时会被记录到文档中,默认注解是不被记录的。</p><h6 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h6><p>@Target注解标记其他注解来限制注解可以应用的java元素,如:</p><ul><li>ElementType.CONSTRUCTOR 可应用到构造函数上</li><li>ElementType.FIELD 可应用到字段或属性上</li><li>ElementType.LOCAL_VARIABLE 可应用到本地变量上</li><li>ElementType.METHOD 可应用到方法级别的注解上</li><li>ElementType.PACKAGE 可应用到包声明上</li><li>ElementType.PARAMETER 可应用到方法的参数上</li><li>ElementType.TYPE 可应用到类的任何元素上<h6 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h6>@Inherited表示注解可以从父类继承,默认不可以。 当用户查询注解类型时,若当前类没有该类型的注解,会接着查询父类的该注解。该注解只可用于类声明上。</li></ul><h6 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h6><p>@Repeatable在java8引入,表示被标记注解可以多次应用到相同声明或类型使用</p><h4 id="类型注解-amp-可插拔类型系统"><a href="#类型注解-amp-可插拔类型系统" class="headerlink" title="类型注解&amp;可插拔类型系统"></a>类型注解&amp;可插拔类型系统</h4><p>Jdk8以前,注解只能应用在声明上,jdk8里注解可以应用到任何类型使用上,这意味着可以在你使用一个类型的任何地方使用。<br>类型注解引入是为了提升java程序的分析来提供更强的类型检查,java8不提供类型检查框架,但是它允许我们来使用多个可插拔类型检查框架来配合java编译器进行更强大的类型检查。</p><p>如,想要确保某一个特定的变量不能被赋值为null,来避免NPE异常的话,可以编写一个自定义插件来检查这一点,类似如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@NonNull String str;</span><br></pre></td></tr></table></figure></p><p>可以加载多种插件来加强类型检查,减少错误。</p><h4 id="可重复注解"><a href="#可重复注解" class="headerlink" title="可重复注解"></a>可重复注解</h4><p>有些情形可能想要使用相同的注解多次,java8引入类型注解。<br>如想要定义多个时间点执行方法,如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Schedule(dayOfMonth=&quot;last&quot;)</span><br><span class="line">@Schedule(dayOfWeek=&quot;Fri&quot;, hour=&quot;23&quot;)</span><br><span class="line">public void doPeriodicCleanup() &#123; &#125;</span><br></pre></td></tr></table></figure></p><p>可重复注解可以在任何使用标准注解的地方使用,如也可在类声明上使用,如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Alert(role=&quot;Manager&quot;)</span><br><span class="line">@Alert(role=&quot;Administrator&quot;)</span><br><span class="line">public class UnauthorizedAccessException extends SecurityException &#123; &#125;</span><br></pre></td></tr></table></figure></p><p>为了兼容,可重复注解保存在java编译器自动生成的注解容器里,需要以下两步声明:</p><ul><li><p>一是定义可重复注解:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.Repeatable;</span><br><span class="line">@Repeatable(Schedules.class)</span><br><span class="line">public @interface Schedule &#123;</span><br><span class="line">  String dayOfMonth() default &quot;first&quot;;</span><br><span class="line">  String dayOfWeek() default &quot;Mon&quot;;</span><br><span class="line">  int hour() default 12;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  @Repeatable元注解圆括号里定义的是注解容器的类型,java编译器用来存储可重复注解。</p><p>  这个例子里,注解容器是Scheudles,所以可重复注解@Schedule存储在@Schedules注解里。</p></li><li><p>二是声明容器枚举类型</p><p>  容器枚举类型必须有一个数组类型的元素,数组的数据类型必须是可重复注解的类型,如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public @interface Schedules &#123;</span><br><span class="line">    Schedule[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="重新获取注解"><a href="#重新获取注解" class="headerlink" title="重新获取注解"></a>重新获取注解</h5><p>反射API中有几个方法可用来获取注解信息,返回一个单独注解的方法,如AnnotatedElement.getAnnotation(Class<t>)的行为不变,因为仅仅返回请求类型的一个注解(如果存在),如果请求类型存在多个注解,可以先得到其容器注解。</t></p><p>java8也引入其他方法来遍历容器注解来一次获取多个注解,如AnnotatedElement.getAnnotationsByType(Class<t>)。</t></p><h5 id="设计考虑"><a href="#设计考虑" class="headerlink" title="设计考虑"></a>设计考虑</h5><p>当设计注解类型时,必须考虑注解类型的使用次数,因为有了可重复注解,可使用多次;也可以通过@Target元注解来限制注解的使用元素范围。</p><p>总之,要让使用者使用起来尽可能灵活、强大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java注解学习&lt;/p&gt;
    
    </summary>
    
      <category term="注解" scheme="http://zhangxiangnan.com/categories/%E6%B3%A8%E8%A7%A3/"/>
    
    
      <category term="注解" scheme="http://zhangxiangnan.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>JAVA泛型</title>
    <link href="http://zhangxiangnan.com/2017/12/18/java/java%E6%B3%9B%E5%9E%8B/"/>
    <id>http://zhangxiangnan.com/2017/12/18/java/java泛型/</id>
    <published>2017-12-18T12:46:15.000Z</published>
    <updated>2019-03-01T16:44:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java中的泛型详解！<br><a id="more"></a></p><h4 id="为什么用泛型"><a href="#为什么用泛型" class="headerlink" title="为什么用泛型"></a>为什么用泛型</h4><p>泛型支持在定义类、接口、方法时将类型当作参数，称作类型参数/类型变量，和形参类似，形参是输入值不同，类型参数是输入类型不同。</p><ul><li>编译时更强的类型检测，避免更多运行时异常，减少bug</li><li>消除强转</li><li>实现支持不同类型集合的泛型算法，更安全、易懂</li></ul><h4 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h4><p>泛型是类型参数化的泛型类或接口。<br>不用泛型时(可放各种类型，所以运行时强转时容易异常)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Box &#123;</span><br><span class="line">  private Object object;</span><br><span class="line">  public void set(Object object) &#123; this.object = object; &#125;</span><br><span class="line">  public Object get() &#123; return object; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>泛型类的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class name&lt;T1, T2, ..., Tn&gt; &#123; &#125;</span><br></pre></td></tr></table></figure></p><p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Box&lt;T&gt; &#123;</span><br><span class="line">    // T stands for &quot;Type&quot;</span><br><span class="line">    private T t;</span><br><span class="line"></span><br><span class="line">    public void set(T t) &#123; this.t = t; &#125;</span><br><span class="line">    public T get() &#123; return t; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类型变量T可以在类中任何地方使用，类型变量可以是任何非基本类型的类型：任意类类型、接口类型、以至另一个类型变量。</p><h5 id="类型参数命名规范"><a href="#类型参数命名规范" class="headerlink" title="类型参数命名规范"></a>类型参数命名规范</h5><p>约定俗成，类型参数单字母、大写，常用的如下：</p><ul><li>E 元素 (java集合框架常用）</li><li>K Key</li><li>N Number</li><li>T Type</li><li>V Value</li><li>S,U,V等</li></ul><h5 id="泛型调用及实例化"><a href="#泛型调用及实例化" class="headerlink" title="泛型调用及实例化"></a>泛型调用及实例化</h5><p>泛型类型的调用(也称参数化类型)：Box<integer> integerBox;<br>实例化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;();</span><br><span class="line">Box&lt;Integer&gt; integerBox = new Box&lt;&gt;();//&gt;=jdk7</span><br></pre></td></tr></table></figure></integer></p><h5 id="参数化类型"><a href="#参数化类型" class="headerlink" title="参数化类型"></a>参数化类型</h5><p>类型参数也可以是参数化类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OrderedPair&lt;String, Box&lt;Integer&gt;&gt; p = new OrderedPair&lt;&gt;(&quot;primes&quot;, new Box&lt;Integer&gt;(...));</span><br></pre></td></tr></table></figure></p><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>泛型方法指引入类型参数的方法，在方法的返回类型之前声明，使用&lt;&gt;，可以有多个类型参数，适用于静态、非静态、构造方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  public class Util &#123;</span><br><span class="line">      public static &lt;K, V&gt; boolean compare(Pair&lt;K, V&gt; p1, Pair&lt;K, V&gt; p2) &#123;</span><br><span class="line">          return p1.getKey().equals(p2.getKey()) &amp;&amp;</span><br><span class="line">                 p1.getValue().equals(p2.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public class Pair&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">  private K key;</span><br><span class="line">  private V value;</span><br><span class="line"></span><br><span class="line">  public Pair(K key, V value) &#123;</span><br><span class="line">      this.key = key;</span><br><span class="line">      this.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setKey(K key) &#123; this.key = key; &#125;</span><br><span class="line">  public void setValue(V value) &#123; this.value = value; &#125;</span><br><span class="line">  public K getKey()   &#123; return key; &#125;</span><br><span class="line">  public V getValue() &#123; return value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  Pair&lt;Integer, String&gt; p1 = new Pair&lt;&gt;(1, &quot;apple&quot;);</span><br><span class="line">  Pair&lt;Integer, String&gt; p2 = new Pair&lt;&gt;(2, &quot;pear&quot;);</span><br><span class="line">  boolean same = Util.&lt;Integer, String&gt;compare(p1, p2);</span><br><span class="line">  boolean same = Util.compare(p1, p2);//类型推导</span><br></pre></td></tr></table></figure></p><h4 id="有界（受限）类型参数"><a href="#有界（受限）类型参数" class="headerlink" title="有界（受限）类型参数"></a>有界（受限）类型参数</h4><p>  有些情况想限制类型参数的参数类型为某个类型或及其子类型，用extends表示.<br>  extends此处表示类的继承和接口的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public &lt;U extends Number&gt; void inspect(U u)&#123;</span><br><span class="line">      System.out.println(&quot;T: &quot; + t.getClass().getName());</span><br><span class="line">      System.out.println(&quot;U: &quot; + u.getClass().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有界类型参数可以调用界限类型里定义的方法，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class NaturalNumber&lt;T extends Integer&gt; &#123;</span><br><span class="line">  private T n;</span><br><span class="line">  public NaturalNumber(T n)  &#123; this.n = n; &#125;</span><br><span class="line">  public boolean isEven() &#123;</span><br><span class="line">      return n.intValue() % 2 == 0;</span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>界限可以有多个，用&amp;连接，多个界限中最多只能有一个类；如果有一个类，多个接口，则该类必须在最左，如<t extends b1 & b2 b3> （B1为类）</t></p><p>有界类型参数是泛型算法实现的关键，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparable&lt;T&gt; &#123;</span><br><span class="line">  public int compareTo(T o);</span><br><span class="line">&#125;</span><br><span class="line">public static &lt;T extends Comparable&lt;T&gt;&gt; int countGreaterThan(T[] anArray, T elem) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    for (T e : anArray)</span><br><span class="line">        if (e.compareTo(elem) &gt; 0)</span><br><span class="line">            ++count;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="泛型-amp-继承-amp-子类型"><a href="#泛型-amp-继承-amp-子类型" class="headerlink" title="泛型&amp;继承&amp;子类型"></a>泛型&amp;继承&amp;子类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;Number&gt; box = new Box&lt;Number&gt;();</span><br><span class="line">box.add(new Integer(10));   // OK</span><br><span class="line">box.add(new Double(10.1));  // OK</span><br><span class="line"></span><br><span class="line">public void boxTest(Box&lt;Number&gt; n) &#123; &#125;</span><br><span class="line">boxTest(new Box(10))</span><br><span class="line">//error,Box&lt;Integer&gt;、Box&lt;Double&gt;都不是Box&lt;Number&gt;的子类型。</span><br></pre></td></tr></table></figure><p>A继承于B，但是不代表Class<a>继承于Class<b></b></a></p><p>泛型的继承可以通过extends或implements来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; -&gt; List&lt;String&gt; -&gt; Collection&lt;String&gt;</span><br></pre></td></tr></table></figure></p><h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><p>Java编译器从方法调用传入的类型以及对应的方法声明的参数类型来推断出使方法调用最合理的参数类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; T pick(T a1, T a2) &#123; return a2; &#125;</span><br><span class="line">Serializable s = pick(&quot;d&quot;, new ArrayList&lt;String&gt;())</span><br></pre></td></tr></table></figure></p><p>有了类型推导，在泛型方法调用、实例化泛型类、泛型类/非泛型类的泛型构造方法调用都可以省略。<br>类型推导只通过调用参数、目标类型、返回值类型来推导，而不是用程序后续的结果类型。</p><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>泛型中，问号标记“？”叫通配符，表示一种未知类型，通配符可以用在以下情形：参数的类型、字段、本地变量、返回值；不用于泛型方法调用的类型参数、泛型类的创建、父类型。</p><h5 id="上限通配符"><a href="#上限通配符" class="headerlink" title="上限通配符"></a>上限通配符</h5><p>上限通配符用来放宽变量的限制，比如想定义一个方法，适用于 List<integer>, List<double>, and List<number>类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void process(List&lt;? extends Number&gt;) &#123;&#125;</span><br></pre></td></tr></table></figure></number></double></integer></p><p>List<number>限制所有类型只能为Number，但List&lt;? extends Number&gt;可匹配Number及Number子类型，并且每个元素都可以调用Number类里的方法。</number></p><h5 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h5><p>使用?定义，如List&lt;?&gt;，称作未知类型的list，适用场合：</p><ul><li>如果在写一个可以使用Object类中的功能实现的方法</li><li>当代码在泛型中使用不依赖类型参数的方法，如List.size List.clear，实际上Class&lt;?&gt;最常用，因为Class<t>里的多数方法不依俩T。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 不适用于List&lt;Integer&gt;、List&lt;String&gt;等</span><br><span class="line">public static void printList(List&lt;Object&gt; list) &#123;</span><br><span class="line">  for (Object elem : list)</span><br><span class="line">      System.out.println(elem + &quot; &quot;);</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印，适合任务类型</span><br><span class="line">public static void printList(List&lt;?&gt; list) &#123;</span><br><span class="line">  for (Object elem: list)</span><br><span class="line">      System.out.print(elem + &quot; &quot;);</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></li></ul><p>List&lt;?&gt;与List<object>不一样，List<object>可以往里面添加Object、及Object的任务子类型，但是List&lt;?&gt;声明的变量只能往里添加null。</object></object></p><h5 id="下界通配符"><a href="#下界通配符" class="headerlink" title="下界通配符"></a>下界通配符</h5><p>下届通配符用 ? super Foo 表示只能是Foo或Foo的父类型，不能同时声明下届和上界。</p><p>List<integer>和List&lt;? super Integer&gt;不一样，List<integer>匹配Integer的列表，但是List&lt;? super Integer&gt;匹配Integer及Integer的父类型。</integer></integer></p><h5 id="通配符和子类型"><a href="#通配符和子类型" class="headerlink" title="通配符和子类型"></a>通配符和子类型</h5><p>A extends B，但是Class<a>和Class<b>没有继承关系，如何让两者有关系？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Integer&gt; intList = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;? extends Number&gt;  numList = intList;  // OK. List&lt;? extends Integer&gt;是List&lt;? extends Number&gt;的子类型</span><br></pre></td></tr></table></figure></b></a></p><p>List&lt;?&gt;是List<integer>和List<number>的父类型。</number></integer></p><p>List<integer> -&gt; List&lt;? extends Integer&gt; -&gt; List&lt;? extends Number&gt; -&gt; List&lt;?&gt;</integer></p><p>List<number> -&gt; List&lt;? super Number&gt; -&gt; List&lt;? super Integer&gt; -&gt; List&lt;?&gt;</number></p><p>List<number> -&gt; List&lt;? extends Number&gt;</number></p><p>List<integer> -&gt; List&lt;? super Integer&gt;</integer></p><h5 id="通配符捕获和辅助方法"><a href="#通配符捕获和辅助方法" class="headerlink" title="通配符捕获和辅助方法"></a>通配符捕获和辅助方法</h5><p>有些情况下，编译器可以捕获到通配符的类型，这种叫通配符捕捉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class WildcardError &#123;</span><br><span class="line"></span><br><span class="line">  void foo(List&lt;?&gt; i) &#123;</span><br><span class="line">      i.set(0, i.get(0));//报包含capture of ?的错误</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>添加辅助方法来解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class WildcardFixed &#123;</span><br><span class="line">  void foo(List&lt;?&gt; i) &#123;</span><br><span class="line">      fooHelper(i);</span><br><span class="line">  &#125;</span><br><span class="line">  // 创建辅助方法以便可以通过类型推导来进行通配符类型捕获</span><br><span class="line">  private &lt;T&gt; void fooHelper(List&lt;T&gt; l) &#123;</span><br><span class="line">      l.set(0, l.get(0));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="通配符的使用场合"><a href="#通配符的使用场合" class="headerlink" title="通配符的使用场合"></a>通配符的使用场合</h5><p>何时使用上界通配符、何时使用下界通配符？首先通配符主要用在方法的形式参数声明上，应避免使用在方法返回类型上（调用者需要处理通配符）</p><ul><li>输入变量(In)就是一个提供数据给代码使用的变量，如拷贝方法copy(src, dst)，src就是输入变量，因为src提供了用来拷贝的数据（producer）；</li><li>输出变量(Out)就是一个保存数据以便在其他地方使用的变量，如copy方法的dst变量，数据拷贝到了dst接受了拷贝的数据(consumer)</li><li>又用于输入且用于输出的变量</li></ul><p>使用指南（方法的参数声明）：</p><ul><li>输入变量使用上界通配符，extends，此时变量只读</li><li>输出变量使用下界通配符，super，此时变量只可写</li><li>针对输入变量可以使用Object类里定义的方法访问时，使用无界通配符</li><li>当代码同时需要将变量当作输入、输出变量时，不使用通配符</li></ul><p>以上描述总结出PECS－Producer extends, consumer super.</p><p>List&lt;? extends …&gt;定义的变量可以认为只读，但是不是严格意义的只读，只是说不能修改已有元素、不能新增元素，但是仍可以执行如下：</p><ul><li>clear</li><li>插入null</li><li>迭代与删除</li><li>通过通配符捕捉来写入元素</li></ul><h4 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h4><p>Java引入泛型来加强编译器类型检查以及支持泛型编程，java使用类型擦除来实现泛型：</p><ul><li>替换泛型类型中所有的类型参数为他们的边界类型或者为Object（类型参数无界时）,因为生成的字节码都是普通的类、接口、方法</li><li>如果需要保持类型安全，插入类型转换指令</li><li>生成桥接方法来保持泛型类型继承中的多态性</li></ul><p>java针对参数化类型不会生成新的类，所以泛型不会产生运行时开销。</p><h5 id="泛型类型擦除"><a href="#泛型类型擦除" class="headerlink" title="泛型类型擦除"></a>泛型类型擦除</h5><p>类型擦除时，编译器擦除所有的类型参数，并每个都使用最左边界类型或者Object(无界类型)来替换 ，Node<t>中T是无界通配符。</t></p><h5 id="泛型方法擦除"><a href="#泛型方法擦除" class="headerlink" title="泛型方法擦除"></a>泛型方法擦除</h5><p>泛型方法擦除时，和类型擦除一样。</p><h5 id="桥接方法"><a href="#桥接方法" class="headerlink" title="桥接方法"></a>桥接方法</h5><p>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Node&lt;T&gt; &#123;</span><br><span class="line">public T data;</span><br><span class="line">public Node(T data) &#123; this.data = data; &#125;</span><br><span class="line">  public void setData(T data) &#123;</span><br><span class="line">      System.out.println(&quot;Node.setData&quot;);</span><br><span class="line">      this.data = data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class MyNode extends Node&lt;Integer&gt; &#123;</span><br><span class="line">public MyNode(Integer data) &#123; super(data); &#125;</span><br><span class="line">  public void setData(Integer data) &#123;</span><br><span class="line">      System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">      super.setData(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类型擦除后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Node &#123;</span><br><span class="line">  public Object data;</span><br><span class="line">  public Node(Object data) &#123; this.data = data; &#125;</span><br><span class="line">  public void setData(Object data) &#123;</span><br><span class="line">      System.out.println(&quot;Node.setData&quot;);</span><br><span class="line">      this.data = data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyNode extends Node &#123;</span><br><span class="line">  public MyNode(Integer data) &#123; super(data); &#125;</span><br><span class="line">  public void setData(Integer data) &#123;</span><br><span class="line">      System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">      super.setData(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>擦除后setData方法不能覆盖父类的setData方法，为了保持泛型类型在擦除后的多态特性，java编译器自动生成桥接方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class MyNode extends Node &#123;</span><br><span class="line">  //桥接方法</span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        setData((Integer) data);</span><br><span class="line">    &#125;</span><br><span class="line">    public void setData(Integer data) &#123;</span><br><span class="line">        System.out.println(&quot;MyNode.setData&quot;);</span><br><span class="line">        super.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="泛型的限制"><a href="#泛型的限制" class="headerlink" title="泛型的限制"></a>泛型的限制</h4><h5 id="不能使用基本类型实例化泛型类型"><a href="#不能使用基本类型实例化泛型类型" class="headerlink" title="不能使用基本类型实例化泛型类型"></a>不能使用基本类型实例化泛型类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;int, char&gt; p = new Pair&lt;&gt;(8, &apos;a&apos;);//error</span><br><span class="line">Pair&lt;Integer, Character&gt; p = new Pair&lt;&gt;(8, &apos;a&apos;);// 8，&apos;a&apos;会自动装箱</span><br></pre></td></tr></table></figure><h5 id="不能创建类型参数的实例"><a href="#不能创建类型参数的实例" class="headerlink" title="不能创建类型参数的实例"></a>不能创建类型参数的实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void append(List&lt;E&gt; list) &#123;</span><br><span class="line">  E elem = new E();  // compile-time error</span><br><span class="line">  list.add(elem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static &lt;E&gt; void append(List&lt;E&gt; list, Class&lt;E&gt; cls) throws Exception &#123;</span><br><span class="line">  E elem = cls.newInstance();   // 反射可以实现</span><br><span class="line">  list.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="不能声明类型为类型参数的静态字段"><a href="#不能声明类型为类型参数的静态字段" class="headerlink" title="不能声明类型为类型参数的静态字段"></a>不能声明类型为类型参数的静态字段</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class MobileDevice&lt;T&gt; &#123;</span><br><span class="line">  private static T os;//编译错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为静态字段是所有类的实例共享，多个实例实例化时传入不同的T类型，则无法确定os字段属于哪一个类型。</p><h5 id="针对参数化类型不能使用cast或instanceof"><a href="#针对参数化类型不能使用cast或instanceof" class="headerlink" title="针对参数化类型不能使用cast或instanceof"></a>针对参数化类型不能使用cast或instanceof</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;E&gt; void rtti(List&lt;E&gt; list) &#123;</span><br><span class="line">  if (list instanceof ArrayList&lt;Integer&gt;) &#123; //编译错误</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void rtti(List&lt;?&gt; list) &#123;</span><br><span class="line">  if (list instanceof ArrayList&lt;?&gt;) &#123;  // 无界通配符OK; instanceof需要一个具体化的类型</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; li = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Number&gt;  ln = (List&lt;Number&gt;) li;  //编译错误</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; l1 = ...;</span><br><span class="line">ArrayList&lt;String&gt; l2 = (ArrayList&lt;String&gt;)l1;  // OK</span><br></pre></td></tr></table></figure><h5 id="不能创建参数化的数组类型"><a href="#不能创建参数化的数组类型" class="headerlink" title="不能创建参数化的数组类型"></a>不能创建参数化的数组类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt;[] arrayOfLists = new List&lt;Integer&gt;[2];  //编译错误，数组声明时需要具体化的类型</span><br></pre></td></tr></table></figure><h5 id="不能创建、捕获、抛出序列化类型的对象"><a href="#不能创建、捕获、抛出序列化类型的对象" class="headerlink" title="不能创建、捕获、抛出序列化类型的对象"></a>不能创建、捕获、抛出序列化类型的对象</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 不能隐式地继承Throwable</span><br><span class="line">class MathException&lt;T&gt; extends Exception &#123;  &#125;    // compile-time error</span><br><span class="line"></span><br><span class="line">// 不能显式地继承Throwable</span><br><span class="line">class QueueFullException&lt;T&gt; extends Throwable &#123; &#125; // compile-time error</span><br><span class="line"></span><br><span class="line">// 不能创建类型参数的实例</span><br><span class="line">public static &lt;T extends Exception, J&gt; void execute(List&lt;J&gt; jobs) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">      for (J job : jobs)</span><br><span class="line">          // ...</span><br><span class="line">  &#125; catch (T e) &#123;   // compile-time error</span><br><span class="line">      // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">可以在throws子句中使用类型参数</span><br><span class="line">class Parser&lt;T extends Exception&gt; &#123;</span><br><span class="line">  public void parse(File file) throws T &#123;     // OK</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="形式类型参数擦除后类型一样的不能重载"><a href="#形式类型参数擦除后类型一样的不能重载" class="headerlink" title="形式类型参数擦除后类型一样的不能重载"></a>形式类型参数擦除后类型一样的不能重载</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">  public void print(Set&lt;String&gt; strSet) &#123; &#125;</span><br><span class="line">  public void print(Set&lt;Integer&gt; intSet) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非具体化类型"><a href="#非具体化类型" class="headerlink" title="非具体化类型"></a>非具体化类型</h4><p> 具体化类型是指运行时完全可以获取到其类型信息的类型，如基本类型、非泛型类型、裸（原始）类型、或者无界通配符的调用。<br> 非具体化类型是指编译时类型信息被擦除,如泛型类型的调用（无界通配符除外），非具化类型运行时没有足够的类型信息。如JVM运行时无法区分List<string>、List<integer>。非具化类型不能用于：instaceof表达式、或者作为数组的元素。</integer></string></p><h5 id="堆污染"><a href="#堆污染" class="headerlink" title="堆污染"></a>堆污染</h5><p>当参数化类型的变量引用非参数化类型的对象时，就会发生堆污染。在编译或运行时如果无法验证包含参数话类型当操作如转换、调用的正确性，就会报未经检查的警告，需要引起注意。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java中的泛型详解！&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://zhangxiangnan.com/categories/java/"/>
    
    
      <category term="generics" scheme="http://zhangxiangnan.com/tags/generics/"/>
    
      <category term="java" scheme="http://zhangxiangnan.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA反射之字段&amp;方法&amp;构造函数</title>
    <link href="http://zhangxiangnan.com/2017/04/12/java/JAVA%E5%8F%8D%E5%B0%84%E4%B9%8B%E5%AD%97%E6%AE%B5&amp;%E6%96%B9%E6%B3%95&amp;%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
    <id>http://zhangxiangnan.com/2017/04/12/java/JAVA反射之字段&amp;方法&amp;构造函数详解/</id>
    <published>2017-04-12T12:32:02.000Z</published>
    <updated>2019-03-01T16:48:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="反射中字段、方法、构造函数的学习"><a href="#反射中字段、方法、构造函数的学习" class="headerlink" title="反射中字段、方法、构造函数的学习"></a>反射中字段、方法、构造函数的学习</h3><a id="more"></a><p>反射定义了一个接口java.lang.reflect.Member，java.lang.reflect.Field、java.lang.reflect.Method、java.lang.reflect.Constructor都实现了该接口。</p><p>注意:根据java7的语言规范，类的成员是类体可继承的组件，包括fields、methods、nested classes、interfaces及枚举类型。由于构造函数不能被继承，他们不是成员。这和java.lang.reflect.Member的实现类不同。</p><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><p>字段有一个类型和值，java.lang.reflect.Field类提供了访问类型信息和设置、获取某个对象的某字段值的方法。</p><h4 id="获取字段类型"><a href="#获取字段类型" class="headerlink" title="获取字段类型"></a>获取字段类型</h4><p>一个字段要么是基本类型，要么是引用类型。有8中基本类型：boolean, byte, short, int, long, char, float, and double. 引用类型是直接或间接继承java.lang.Object类的子类，包括接口、数组及枚举类型。</p><p>如下是一个输出不同类型字段的类型及泛华类型的展示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class FieldSpy&lt;T&gt; &#123;</span><br><span class="line">    public boolean[][] b = &#123;&#123; false, false &#125;, &#123; true, true &#125; &#125;;</span><br><span class="line">    public String name  = &quot;Alice&quot;;</span><br><span class="line">    public List&lt;Integer&gt; list;</span><br><span class="line">    public T val;</span><br><span class="line"></span><br><span class="line">    public static void main(String... args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Class&lt;?&gt; c = Class.forName(args[0]);</span><br><span class="line">        Field f = c.getField(args[1]);</span><br><span class="line">        System.out.format(&quot;Type: %s%n&quot;, f.getType());</span><br><span class="line">        System.out.format(&quot;GenericType: %s%n&quot;, f.getGenericType());</span><br><span class="line">    &#125; catch (ClassNotFoundException x) &#123;</span><br><span class="line">        x.printStackTrace();</span><br><span class="line">    &#125; catch (NoSuchFieldException x) &#123;</span><br><span class="line">        x.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ java FieldSpy FieldSpy b</span><br><span class="line">Type: class [[Z</span><br><span class="line">GenericType: class [[Z</span><br><span class="line"></span><br><span class="line">$ java FieldSpy FieldSpy name</span><br><span class="line">Type: class java.lang.String</span><br><span class="line">GenericType: class java.lang.String</span><br><span class="line"></span><br><span class="line">$ java FieldSpy FieldSpy list</span><br><span class="line">Type: interface java.util.List</span><br><span class="line">GenericType: java.util.List&lt;java.lang.Integer&gt;</span><br><span class="line"></span><br><span class="line">$ java FieldSpy FieldSpy val</span><br><span class="line">Type: class java.lang.Object</span><br><span class="line">GenericType: T</span><br></pre></td></tr></table></figure><p>说明:字段b的类型时boolean类型的二维数组，类型名称的语法规则根据Class.getName()。<br>字段val的类型时java.lang.Object，因为泛型的信息会在编译期间擦除泛型的相关信息。T被类型变量的上层限制替代，这里是java.lang.Object.<br>Field.getGenericType()方法会在类文件中查找签名属性（如果存在）。如果签名属性不存在，会返回Field.getType()的值（没有因为引入泛型发生改变）。反射的其他名称为getGenericFoo的方法实现思路类似。</p><h4 id="获取-amp-解析字段的修饰符"><a href="#获取-amp-解析字段的修饰符" class="headerlink" title="获取&amp;解析字段的修饰符"></a>获取&amp;解析字段的修饰符</h4><p>字段声明时允许的几个修饰符：</p><ul><li>访问修饰符: public, protected, and private</li><li>管理运行时行为的修饰符： transient and volatile</li><li>限制到一个实例的修饰符: static</li><li>禁止修改值的修饰符：final</li><li>注解<br>Field.getModifiers()方法用来一个整数值，代表该字段声明的修饰符集（一个或多个修饰符），该整数值中位表示的修饰符在java.lang.reflect.Modifier定义。<br>下例展示了如何根据给定的修饰符查找字段，以及判断字段是否是合成（编译器生成的）及是否是枚举常量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.Modifier;</span><br><span class="line">import static java.lang.System.out;</span><br><span class="line"></span><br><span class="line">enum Spy &#123; BLACK , WHITE &#125;</span><br><span class="line"></span><br><span class="line">public class FieldModifierSpy &#123;</span><br><span class="line">    volatile int share;</span><br><span class="line">    int instance;</span><br><span class="line">    class Inner &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String... args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Class&lt;?&gt; c = Class.forName(args[0]);</span><br><span class="line">        int searchMods = 0x0;</span><br><span class="line">        for (int i = 1; i &lt; args.length; i++) &#123;</span><br><span class="line">          searchMods |= modifierFromString(args[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Field[] flds = c.getDeclaredFields();</span><br><span class="line">        out.format(&quot;Fields in Class &apos;%s&apos; containing modifiers:  %s%n&quot;,</span><br><span class="line">           c.getName(),</span><br><span class="line">           Modifier.toString(searchMods));</span><br><span class="line">        boolean found = false;</span><br><span class="line">        for (Field f : flds) &#123;</span><br><span class="line">        int foundMods = f.getModifiers();</span><br><span class="line">        // Require all of the requested modifiers to be present</span><br><span class="line">        if ((foundMods &amp; searchMods) == searchMods) &#123;</span><br><span class="line">            out.format(&quot;%-8s [ synthetic=%-5b enum_constant=%-5b ]%n&quot;,</span><br><span class="line">               f.getName(), f.isSynthetic(),</span><br><span class="line">               f.isEnumConstant());</span><br><span class="line">            found = true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!found) &#123;</span><br><span class="line">          out.format(&quot;No matching fields%n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">            // production code should handle this exception more gracefully</span><br><span class="line">    &#125; catch (ClassNotFoundException x) &#123;</span><br><span class="line">        x.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int modifierFromString(String s) &#123;</span><br><span class="line">    int m = 0x0;</span><br><span class="line">    if (&quot;public&quot;.equals(s))           m |= Modifier.PUBLIC;</span><br><span class="line">    else if (&quot;protected&quot;.equals(s))   m |= Modifier.PROTECTED;</span><br><span class="line">    else if (&quot;private&quot;.equals(s))     m |= Modifier.PRIVATE;</span><br><span class="line">    else if (&quot;static&quot;.equals(s))      m |= Modifier.STATIC;</span><br><span class="line">    else if (&quot;final&quot;.equals(s))       m |= Modifier.FINAL;</span><br><span class="line">    else if (&quot;transient&quot;.equals(s))   m |= Modifier.TRANSIENT;</span><br><span class="line">    else if (&quot;volatile&quot;.equals(s))    m |= Modifier.VOLATILE;</span><br><span class="line">    return m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ java FieldModifierSpy FieldModifierSpy volatile</span><br><span class="line">Fields in Class &apos;FieldModifierSpy&apos; containing modifiers:  volatile</span><br><span class="line">share    [ synthetic=false enum_constant=false ]</span><br><span class="line"></span><br><span class="line">$ java FieldModifierSpy Spy public</span><br><span class="line">Fields in Class &apos;Spy&apos; containing modifiers:  public</span><br><span class="line">BLACK    [ synthetic=false enum_constant=true  ]</span><br><span class="line">WHITE    [ synthetic=false enum_constant=true  ]</span><br><span class="line"></span><br><span class="line">$ java FieldModifierSpy FieldModifierSpy\$Inner final</span><br><span class="line">Fields in Class &apos;FieldModifierSpy$Inner&apos; containing modifiers:  final</span><br><span class="line">this$0   [ synthetic=true  enum_constant=false ]</span><br><span class="line"></span><br><span class="line">$ java FieldModifierSpy Spy private static final</span><br><span class="line">Fields in Class &apos;Spy&apos; containing modifiers:  private static final</span><br><span class="line">$VALUES  [ synthetic=true  enum_constant=false ]// 枚举类有private static final类型的合成字段$VALUES</span><br></pre></td></tr></table></figure></li></ul><p>注意编译器会生成一些合成的运行时需要的字段，可使用Field.isSynthetic()来判断是否合成字段，合成的字段根据编译器不同不同。然而内部类引入this$0字段 (即嵌套类为非静态成员类）来持有最外层类的引用；枚举类引入$VALUES字段实现隐式地定义静态方法values().合成的类成员的名字未被指定，不同的编译器实现或不同版本中可能不同。Class.getDeclaredFields()方法会返回包含合成字段的数组，但是Class.getField()方法不会返回，因为合成字段通常不是public的。<br>因为Field字段实现了接口java.lang.reflect.AnnotatedElement，因此运行时能够获取到保留策略为java.lang.annotation.RetentionPolicy.RUNTIME的注解信息。</p><h4 id="设置-amp-获取字段值"><a href="#设置-amp-获取字段值" class="headerlink" title="设置&amp;获取字段值"></a>设置&amp;获取字段值</h4><p>给定某个类的一个实例，是能够用反射来设置类的字段的值。这通常仅在特殊情况下不能够以常规方式设置值。因为这么做破坏了类的设计意图，应该慎用。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">  import java.lang.reflect.Field;</span><br><span class="line">  import java.util.Arrays;</span><br><span class="line">  import static java.lang.System.out;</span><br><span class="line"></span><br><span class="line">  enum Tweedle &#123; DEE, DUM &#125;</span><br><span class="line"></span><br><span class="line">  public class Book &#123;</span><br><span class="line">      public long chapters = 0;</span><br><span class="line">      public String[] characters = &#123; &quot;Alice&quot;, &quot;White Rabbit&quot; &#125;;</span><br><span class="line">      public Tweedle twin = Tweedle.DEE;</span><br><span class="line"></span><br><span class="line">      public static void main(String... args) &#123;</span><br><span class="line">      Book book = new Book();</span><br><span class="line">      String fmt = &quot;%6S:  %-12s = %s%n&quot;;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">          Class&lt;?&gt; c = book.getClass();</span><br><span class="line"></span><br><span class="line">          Field chap = c.getDeclaredField(&quot;chapters&quot;);</span><br><span class="line">          out.format(fmt, &quot;before&quot;, &quot;chapters&quot;, book.chapters);</span><br><span class="line">            chap.setLong(book, 12);</span><br><span class="line">          out.format(fmt, &quot;after&quot;, &quot;chapters&quot;, chap.getLong(book));</span><br><span class="line"></span><br><span class="line">          Field chars = c.getDeclaredField(&quot;characters&quot;);</span><br><span class="line">          out.format(fmt, &quot;before&quot;, &quot;characters&quot;,</span><br><span class="line">             Arrays.asList(book.characters));</span><br><span class="line">          String[] newChars = &#123; &quot;Queen&quot;, &quot;King&quot; &#125;;</span><br><span class="line">          chars.set(book, newChars);</span><br><span class="line">          out.format(fmt, &quot;after&quot;, &quot;characters&quot;,</span><br><span class="line">             Arrays.asList(book.characters));</span><br><span class="line"></span><br><span class="line">          Field t = c.getDeclaredField(&quot;twin&quot;);</span><br><span class="line">          out.format(fmt, &quot;before&quot;, &quot;twin&quot;, book.twin);</span><br><span class="line">          t.set(book, Tweedle.DUM);</span><br><span class="line">          out.format(fmt, &quot;after&quot;, &quot;twin&quot;, t.get(book));</span><br><span class="line"></span><br><span class="line">              // production code should handle these exceptions more gracefully</span><br><span class="line">      &#125; catch (NoSuchFieldException x) &#123;</span><br><span class="line">          x.printStackTrace();</span><br><span class="line">      &#125; catch (IllegalAccessException x) &#123;</span><br><span class="line">          x.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ java Book</span><br><span class="line">BEFORE:  chapters     = 0</span><br><span class="line"> AFTER:  chapters     = 12</span><br><span class="line">BEFORE:  characters   = [Alice, White Rabbit]</span><br><span class="line"> AFTER:  characters   = [Queen, King]</span><br><span class="line">BEFORE:  twin         = DEE</span><br><span class="line"> AFTER:  twin         = DUM</span><br></pre></td></tr></table></figure></p><p>注意：通过反射设置字段的值有一定的性能开销，因为必须进行各种操作，比如访问权限验证。从运行时角度看，效果一样，并且操作就像在代码中直接改变值一样是原子性的。<br>反射的使用会导致丢失一些运行时优化，如下代码很可能被虚拟机优化，但是使用Field.set*()就不会进行优化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x = 1;</span><br><span class="line">x = 2;</span><br><span class="line">x = 3;</span><br></pre></td></tr></table></figure></p><h4 id="常见代码错误"><a href="#常见代码错误" class="headerlink" title="常见代码错误"></a>常见代码错误</h4><h5 id="IllegalArgumentException由于不可转换类型（due-to-Inconvertible-Types）"><a href="#IllegalArgumentException由于不可转换类型（due-to-Inconvertible-Types）" class="headerlink" title="IllegalArgumentException由于不可转换类型（due to Inconvertible Types）"></a>IllegalArgumentException由于不可转换类型（due to Inconvertible Types）</h5><p>当使用反射给引用类型的整数赋值基本类型的数值时，就会报该错误。不是用反射的话，编译器会执行自动装箱操作，将基本类型装箱为引用类型，这样类型检查就没问题，但是用反射的话，类型检查只发生在运行时，没有机会去执行装箱操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">public class FieldTrouble &#123;</span><br><span class="line">    public Integer val;</span><br><span class="line"></span><br><span class="line">    public static void main(String... args) &#123;</span><br><span class="line">FieldTrouble ft = new FieldTrouble();</span><br><span class="line">try &#123;</span><br><span class="line">    Class&lt;?&gt; c = ft.getClass();</span><br><span class="line">    Field f = c.getDeclaredField(&quot;val&quot;);</span><br><span class="line">      f.setInt(ft, 42);               // IllegalArgumentException</span><br><span class="line"></span><br><span class="line">        // production code should handle these exceptions more gracefully</span><br><span class="line">&#125; catch (NoSuchFieldException x) &#123;</span><br><span class="line">    x.printStackTrace();</span><br><span class="line"> &#125; catch (IllegalAccessException x) &#123;</span><br><span class="line">     x.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$ java FieldTrouble</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Can not set</span><br><span class="line">  java.lang.Object field FieldTrouble.val to (long)42</span><br><span class="line">        at sun.reflect.UnsafeFieldAccessorImpl.throwSetIllegalArgumentException</span><br><span class="line">          (UnsafeFieldAccessorImpl.java:146)</span><br><span class="line">        at sun.reflect.UnsafeFieldAccessorImpl.throwSetIllegalArgumentException</span><br><span class="line">          (UnsafeFieldAccessorImpl.java:174)</span><br><span class="line">        at sun.reflect.UnsafeObjectFieldAccessorImpl.setLong</span><br><span class="line">          (UnsafeObjectFieldAccessorImpl.java:102)</span><br><span class="line">        at java.lang.reflect.Field.setLong(Field.java:831)</span><br><span class="line">        at FieldTrouble.main(FieldTrouble.java:11)</span><br></pre></td></tr></table></figure></p><p>解决办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.set(ft, new Integer(43));</span><br></pre></td></tr></table></figure></p><p>提示：当时使用反射设&amp;获取一个字段的值的时候，编译器没机会来执行装箱操作。编译器只能转换Class.isAssignableFrom()方法的规范描述的相关转换。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer.class.isAssignableFrom(int.class) == false// 反射时引用类型到基本类型不成功</span><br><span class="line">int.class.isAssignableFrom(Integer.class) == false// 反射时基本类型到引用类型不成功</span><br></pre></td></tr></table></figure></p><h5 id="NoSuchFieldException-for-Non-Public-Fields"><a href="#NoSuchFieldException-for-Non-Public-Fields" class="headerlink" title="NoSuchFieldException for Non-Public Fields"></a>NoSuchFieldException for Non-Public Fields</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ java FieldSpy java.lang.String count</span><br><span class="line">java.lang.NoSuchFieldException: count</span><br><span class="line">        at java.lang.Class.getField(Class.java:1519)</span><br><span class="line">        at FieldSpy.main(FieldSpy.java:12)</span><br></pre></td></tr></table></figure><p>提示：Class.getField()及Class.getFields()方法返回class对象代表的类、枚举、接口的公共成员方法。想获取类声明的所有方法（不是继承），使用Class.getDeclaredFields()方法。</p><h5 id="IllegalAccessException-when-Modifying-Final-Fields"><a href="#IllegalAccessException-when-Modifying-Final-Fields" class="headerlink" title="IllegalAccessException when Modifying Final Fields"></a>IllegalAccessException when Modifying Final Fields</h5><p>如果尝试获取&amp;设置私有或其他无法访问的字段的值，或设置final字段的值（不论修饰符是什么）可能会抛出IllegalAccessException异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">  public class FieldTroubleToo &#123;</span><br><span class="line">      public final boolean b = true;</span><br><span class="line"></span><br><span class="line">      public static void main(String... args) &#123;</span><br><span class="line">  FieldTroubleToo ft = new FieldTroubleToo();</span><br><span class="line">  try &#123;</span><br><span class="line">      Class&lt;?&gt; c = ft.getClass();</span><br><span class="line">      Field f = c.getDeclaredField(&quot;b&quot;);</span><br><span class="line">  //     f.setAccessible(true);  // solution</span><br><span class="line">      f.setBoolean(ft, Boolean.FALSE);   // IllegalAccessException</span><br><span class="line"></span><br><span class="line">          // production code should handle these exceptions more gracefully</span><br><span class="line">  &#125; catch (NoSuchFieldException x) &#123;</span><br><span class="line">      x.printStackTrace();</span><br><span class="line">  &#125; catch (IllegalArgumentException x) &#123;</span><br><span class="line">      x.printStackTrace();</span><br><span class="line">  &#125; catch (IllegalAccessException x) &#123;</span><br><span class="line">      x.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">$ java FieldTroubleToo</span><br><span class="line">java.lang.IllegalAccessException: Can not set final boolean field</span><br><span class="line">  FieldTroubleToo.b to (boolean)false</span><br><span class="line">        at sun.reflect.UnsafeFieldAccessorImpl.</span><br><span class="line">          throwFinalFieldIllegalAccessException(UnsafeFieldAccessorImpl.java:55)</span><br><span class="line">        at sun.reflect.UnsafeFieldAccessorImpl.</span><br><span class="line">          throwFinalFieldIllegalAccessException(UnsafeFieldAccessorImpl.java:63)</span><br><span class="line">        at sun.reflect.UnsafeQualifiedBooleanFieldAccessorImpl.setBoolean</span><br><span class="line">          (UnsafeQualifiedBooleanFieldAccessorImpl.java:78)</span><br><span class="line">        at java.lang.reflect.Field.setBoolean(Field.java:686)</span><br><span class="line">        at FieldTroubleToo.main(FieldTroubleToo.java:12)</span><br></pre></td></tr></table></figure><p>提示：class初始化后，存在一个访问限制组织修改final字段值。Field声明为继承自AccessibleObject，提供了方法来抑制此检查。但这会产生副作用；如有时即使值已经被修改，但是程序的其他部分仍可能使用旧值。AccessibleObject.setAccessible()仅在安全上下文允许的情况下才能成功。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法拥有返回值、参数、及可能抛出异常。java.lang.reflect.Method类提供了获取参数和返回值的类型信息的方法，也经常用来执行指定对象的方法。</p><h4 id="获取方法类型信息"><a href="#获取方法类型信息" class="headerlink" title="获取方法类型信息"></a>获取方法类型信息</h4><p>一个字段要么是基本类型要么是引用类型，有8中基本类型：boolean、byte、short、int、long、char、float、double。一个引用类型指直接或间接继承java.lang.Object类包括接口、数组、枚举类型的任意对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  import java.lang.reflect.Field;</span><br><span class="line">  import java.util.List;</span><br><span class="line"></span><br><span class="line">  public class FieldSpy&lt;T&gt; &#123;</span><br><span class="line">      public boolean[][] b = &#123;&#123; false, false &#125;, &#123; true, true &#125; &#125;;</span><br><span class="line">      public String name  = &quot;Alice&quot;;</span><br><span class="line">      public List&lt;Integer&gt; list;</span><br><span class="line">      public T val;// 参数化类型</span><br><span class="line"></span><br><span class="line">      public static void main(String... args) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          Class&lt;?&gt; c = Class.forName(args[0]);</span><br><span class="line">          Field f = c.getField(args[1]);</span><br><span class="line">          System.out.format(&quot;Type: %s%n&quot;, f.getType());</span><br><span class="line">          System.out.format(&quot;GenericType: %s%n&quot;, f.getGenericType());</span><br><span class="line"></span><br><span class="line">              // production code should handle these exceptions more gracefully</span><br><span class="line">      &#125; catch (ClassNotFoundException x) &#123;</span><br><span class="line">          x.printStackTrace();</span><br><span class="line">      &#125; catch (NoSuchFieldException x) &#123;</span><br><span class="line">          x.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">$ java FieldSpy FieldSpy b</span><br><span class="line">Type: class [[Z</span><br><span class="line">GenericType: class [[Z</span><br><span class="line">$ java FieldSpy FieldSpy name</span><br><span class="line">Type: class java.lang.String</span><br><span class="line">GenericType: class java.lang.String</span><br><span class="line">$ java FieldSpy FieldSpy list</span><br><span class="line">Type: interface java.util.List</span><br><span class="line">GenericType: java.util.List&lt;java.lang.Integer&gt;</span><br><span class="line">$ java FieldSpy FieldSpy val</span><br><span class="line">Type: class java.lang.Object</span><br><span class="line">GenericType: T</span><br></pre></td></tr></table></figure></p><p>字段b是二维boolean数组，其类型名称的语法在Class.getName()描述。<br>字段val的类型结果是继承自java.lang.Object，因为通过类型擦除实现泛型，在编译期间删除删除有关泛型的信息。所以T被类型变量的上界替换，该例是java.lang.Object.</p><p>Field.getGenericType()在类文件中查找签名属性（如果存在），如果不存在，会降级为Field.getType()（没有因为泛型导致被改变）。反射中其他有类似getGenericFoo方法来获取Foo的某个值的实现都类似。</p><h4 id="获取方法或构造函数参数的名称和其他信息"><a href="#获取方法或构造函数参数的名称和其他信息" class="headerlink" title="获取方法或构造函数参数的名称和其他信息"></a>获取方法或构造函数参数的名称和其他信息</h4><p>可以使用java.lang.reflect.Executable.getParameters方法来获取任何方法或构造函数的形式参数(Method和Constructor类继承了Executable，因此继承了Executable.getParameters方法)然而，.class文件不保存默认不保存形参名称。这是因为许多生成和使用类的工具不希望更大的静态或动态的包含参数名称的类文件占位。尤其，这些工具不得不处理更大的.class类文件，JVM也会使用更多的内存。另外，某些参数名称，如secret、password可能暴露安全敏感的方法信息。</p><p>为了在制定类文件中保存形参名称，这样就能够在反射时拿到这些形参的名称，可以使用-parameters配置javac编译器来编译源文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line">    import java.lang.reflect.`*`;</span><br><span class="line">    import java.util.function.`*`;</span><br><span class="line">    import static java.lang.System.out;</span><br><span class="line"></span><br><span class="line">    public class MethodParameterSpy &#123;</span><br><span class="line"></span><br><span class="line">      private static final String  fmt = &quot;%24s: %s%n&quot;;</span><br><span class="line"></span><br><span class="line">      &lt;E extends RuntimeException&gt; void genericThrow() throws E &#123;&#125;</span><br><span class="line"></span><br><span class="line">      public static void printClassConstructors(Class c) &#123;</span><br><span class="line">        Constructor[] allConstructors = c.getConstructors();</span><br><span class="line">        out.format(fmt, &quot;Number of constructors&quot;, allConstructors.length);</span><br><span class="line">        for (Constructor currentConstructor : allConstructors) &#123;</span><br><span class="line">            printConstructor(currentConstructor);</span><br><span class="line">        &#125;  </span><br><span class="line">        Constructor[] allDeclConst = c.getDeclaredConstructors();</span><br><span class="line">        out.format(fmt, &quot;Number of declared constructors&quot;,</span><br><span class="line">            allDeclConst.length);</span><br><span class="line">        for (Constructor currentDeclConst : allDeclConst) &#123;</span><br><span class="line">            printConstructor(currentDeclConst);</span><br><span class="line">        &#125;          </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public static void printClassMethods(Class c) &#123;</span><br><span class="line">       Method[] allMethods = c.getDeclaredMethods();</span><br><span class="line">        out.format(fmt, &quot;Number of methods&quot;, allMethods.length);</span><br><span class="line">        for (Method m : allMethods) &#123;</span><br><span class="line">            printMethod(m);</span><br><span class="line">        &#125;        </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public static void printConstructor(Constructor c) &#123;</span><br><span class="line">        out.format(&quot;%s%n&quot;, c.toGenericString());</span><br><span class="line">        Parameter[] params = c.getParameters();</span><br><span class="line">        out.format(fmt, &quot;Number of parameters&quot;, params.length);</span><br><span class="line">        for (int i = 0; i &lt; params.length; i++) &#123;</span><br><span class="line">            printParameter(params[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public static void printMethod(Method m) &#123;</span><br><span class="line">        out.format(&quot;%s%n&quot;, m.toGenericString());</span><br><span class="line">        out.format(fmt, &quot;Return type&quot;, m.getReturnType());</span><br><span class="line">        out.format(fmt, &quot;Generic return type&quot;, m.getGenericReturnType());</span><br><span class="line"></span><br><span class="line">        Parameter[] params = m.getParameters();</span><br><span class="line">        for (int i = 0; i &lt; params.length; i++) &#123;</span><br><span class="line">            printParameter(params[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public static void printParameter(Parameter p) &#123;</span><br><span class="line">        out.format(fmt, &quot;Parameter class&quot;, p.getType());</span><br><span class="line">        out.format(fmt, &quot;Parameter name&quot;, p.getName());</span><br><span class="line">        out.format(fmt, &quot;Modifiers&quot;, p.getModifiers());</span><br><span class="line">        out.format(fmt, &quot;Is implicit?&quot;, p.isImplicit());//</span><br><span class="line">        out.format(fmt, &quot;Is name present?&quot;, p.isNamePresent());//参数名字是否存在</span><br><span class="line">        out.format(fmt, &quot;Is synthetic?&quot;, p.isSynthetic());//是否自动生成</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public static void main(String... args) &#123;        </span><br><span class="line">          try &#123;</span><br><span class="line">              printClassConstructors(Class.forName(args[0]));</span><br><span class="line">              printClassMethods(Class.forName(args[0]));</span><br><span class="line">          &#125; catch (ClassNotFoundException x) &#123;</span><br><span class="line">              x.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    import java.util.`*`;</span><br><span class="line"></span><br><span class="line">    public class ExampleMethods&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">        public boolean simpleMethod(String stringParam, int intParam) &#123;</span><br><span class="line">            System.out.println(&quot;String: &quot; + stringParam + &quot;, integer: &quot; + intParam);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int varArgsMethod(String... manyStrings) &#123;</span><br><span class="line">            return manyStrings.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean methodWithList(List&lt;String&gt; listParam) &#123;</span><br><span class="line">            return listParam.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public &lt;T&gt; void genericMethod(T[] a, Collection&lt;T&gt; c) &#123;</span><br><span class="line">            System.out.println(&quot;Length of array: &quot; + a.length);</span><br><span class="line">            System.out.println(&quot;Size of collection: &quot; + c.size());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    执行命令：</span><br><span class="line">    java MethodParameterSpy ExampleMethods</span><br><span class="line"></span><br><span class="line">    输出：</span><br><span class="line"></span><br><span class="line">    Number of constructors: 1</span><br><span class="line"></span><br><span class="line">    Constructor #1</span><br><span class="line">    public ExampleMethods()</span><br><span class="line"></span><br><span class="line">    Number of declared constructors: 1</span><br><span class="line"></span><br><span class="line">    Declared constructor #1</span><br><span class="line">    public ExampleMethods()</span><br><span class="line"></span><br><span class="line">    Number of methods: 4</span><br><span class="line"></span><br><span class="line">    Method #1</span><br><span class="line">    public boolean ExampleMethods.simpleMethod(java.lang.String,int)</span><br><span class="line">               Return type: boolean</span><br><span class="line">       Generic return type: boolean</span><br><span class="line">           Parameter class: class java.lang.String</span><br><span class="line">            Parameter name: stringParam</span><br><span class="line">                 Modifiers: 0</span><br><span class="line">              Is implicit?: false</span><br><span class="line">          Is name present?: true</span><br><span class="line">             Is synthetic?: false</span><br><span class="line">           Parameter class: int</span><br><span class="line">            Parameter name: intParam</span><br><span class="line">                 Modifiers: 0</span><br><span class="line">              Is implicit?: false</span><br><span class="line">          Is name present?: true</span><br><span class="line">             Is synthetic?: false</span><br><span class="line"></span><br><span class="line">    Method #2</span><br><span class="line">    public int ExampleMethods.varArgsMethod(java.lang.String...)</span><br><span class="line">               Return type: int</span><br><span class="line">       Generic return type: int</span><br><span class="line">           Parameter class: class [Ljava.lang.String;</span><br><span class="line">            Parameter name: manyStrings</span><br><span class="line">                 Modifiers: 0</span><br><span class="line">              Is implicit?: false</span><br><span class="line">          Is name present?: true</span><br><span class="line">             Is synthetic?: false</span><br><span class="line"></span><br><span class="line">    Method #3</span><br><span class="line">    public boolean ExampleMethods.methodWithList(java.util.List&lt;java.lang.String&gt;)</span><br><span class="line">               Return type: boolean</span><br><span class="line">       Generic return type: boolean</span><br><span class="line">           Parameter class: interface java.util.List</span><br><span class="line">            Parameter name: listParam</span><br><span class="line">                 Modifiers: 0</span><br><span class="line">              Is implicit?: false</span><br><span class="line">          Is name present?: true</span><br><span class="line">             Is synthetic?: false</span><br><span class="line"></span><br><span class="line">    Method #4</span><br><span class="line">    public &lt;T&gt; void ExampleMethods.genericMethod(T[],java.util.Collection&lt;T&gt;)</span><br><span class="line">               Return type: void</span><br><span class="line">       Generic return type: void</span><br><span class="line">           Parameter class: class [Ljava.lang.Object;</span><br><span class="line">            Parameter name: a</span><br><span class="line">                 Modifiers: 0</span><br><span class="line">              Is implicit?: false</span><br><span class="line">          Is name present?: true</span><br><span class="line">             Is synthetic?: false</span><br><span class="line">           Parameter class: interface java.util.Collection</span><br><span class="line">            Parameter name: c</span><br><span class="line">                 Modifiers: 0</span><br><span class="line">              Is implicit?: false</span><br><span class="line">          Is name present?: true</span><br><span class="line">             Is synthetic?: false</span><br><span class="line"></span><br><span class="line">- getType: 返回参数的声明类型的Class类</span><br><span class="line">- getName: 返回参数的名字。如果名字存在，则返回.class类文件返回的名称，否则该方法返回自动生成的名称，形式如argN，N是定义该参数的方法的参数的索引。</span><br><span class="line">    例如，假如没有指定-parameters编译配置来编译类文件，则如下输出：</span><br><span class="line"></span><br><span class="line">      public boolean ExampleMethods.simpleMethod(java.lang.String,int)</span><br><span class="line">               Return type: boolean</span><br><span class="line">       Generic return type: boolean</span><br><span class="line">           Parameter class: class java.lang.String</span><br><span class="line">            Parameter name: arg0</span><br><span class="line">                 Modifiers: 0</span><br><span class="line">              Is implicit?: false</span><br><span class="line">          Is name present?: false</span><br><span class="line">             Is synthetic?: false</span><br><span class="line">           Parameter class: int</span><br><span class="line">            Parameter name: arg1</span><br><span class="line">                 Modifiers: 0</span><br><span class="line">              Is implicit?: false</span><br><span class="line">          Is name present?: false</span><br><span class="line">             Is synthetic?: false</span><br></pre></td></tr></table></figure></p><ul><li>getModifiers :返回形参具有的各种特征表示的整数，该数值是下列值的和，如果应用于形式参数：</li></ul><table><thead><tr><th>Value (in decimal)</th><th>Value (in hexadecimal)</th><th>Description</th></tr></thead><tbody><tr><td>16</td><td>0x0010</td><td>形参定义为final</td></tr><tr><td>4096</td><td>0x1000</td><td>形参是synthetic合成的. 或者可以调用方法isSynthetic.</td></tr><tr><td>32768</td><td>0x8000</td><td>形参在源码中声明为隐式的，或者可以调用isImplicit方法。</td></tr></tbody></table><ul><li><p>isImplicit: 返回源码中声明的参数是否是隐性的</p></li><li><p>isNamePresent: 根据.class类文件来决定形参是否有一个名字，有返回true。</p></li><li>isSynthetic: 如果源码中声明的参数既不是隐性的也不是明确在源码定义的则返回true。</li></ul><h5 id="隐性和合成参数"><a href="#隐性和合成参数" class="headerlink" title="隐性和合成参数"></a>隐性和合成参数</h5><p>  某些构造函数是如果没有被显示声明则会在源码中隐性声明。如ExampleMethods例子无构造函数，一个默认构造函数就会隐性声明。MethodParameterSpy例子打印的隐性声明构造函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number of declared constructors: 1</span><br><span class="line">public ExampleMethods()</span><br></pre></td></tr></table></figure></p><p>考虑如下片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class MethodParameterExamples &#123;</span><br><span class="line">  public class InnerClass &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>InnerClass是一个非京台嵌套类或内部类。内部类的有个构造函数也是隐性声明的。然而，该隐性构造包含一个参数，当java编译器编译内部类时，会生成一个类似下面的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MethodParameterExamples &#123;</span><br><span class="line">  public class InnerClass &#123;</span><br><span class="line">      final MethodParameterExamples parent;</span><br><span class="line">      InnerClass(final MethodParameterExamples this$0) &#123;</span><br><span class="line">          parent = this$0;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>InnerClass构造包含一个参数，参数类型是包含内部类InnerClass的类，即MethodParameterExamples。参照如下输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public MethodParameterExamples$InnerClass(MethodParameterExamples)</span><br><span class="line">       Parameter class: class MethodParameterExamples</span><br><span class="line">        Parameter name: this$0</span><br><span class="line">             Modifiers: 32784</span><br><span class="line">          Is implicit?: true</span><br><span class="line">      Is name present?: true</span><br><span class="line">         Is synthetic?: false</span><br></pre></td></tr></table></figure></p><p>因为InnerClass类的构造函数是隐性指定的，所以参数也是隐性的。<br>注意：<br>Java编译器为内部类的构造函数创建一个形式参数，以使编译器能够将创建表达式中的引用（表示直接包含的实例）传递给成员类的构造函数。值32784表示InnerClass构造函数的参数同时是finla（16）和隐性的（32768）。Java语言允许变量名称含有$符号，但是约定来说，在变量名称中不用$符号。Java编译器提供的构造函数如果他们不能对应到源码里明确地或隐含的构造函数，则就是是synthetic合成的，除非他们是类初始化方法。合成的构造函数根据不同的编译器实现而不同。考虑如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class MethodParameterExamples &#123;</span><br><span class="line">  enum Colors &#123;</span><br><span class="line">      RED, WHITE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Java编译器针对该类会生成几个方法，兼容.class类文件结构，并提供enum构造预期的功能。如，Java编译器会创建一个类文件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">final class Colors extends java.lang.Enum&lt;Colors&gt; &#123;</span><br><span class="line">  public final static Colors RED = new Colors(&quot;RED&quot;, 0);</span><br><span class="line">  public final static Colors BLUE = new Colors(&quot;WHITE&quot;, 1);</span><br><span class="line"></span><br><span class="line">  private final static values = new Colors[]&#123; RED, BLUE &#125;;</span><br><span class="line"></span><br><span class="line">  private Colors(String name, int ordinal) &#123;</span><br><span class="line">      super(name, ordinal);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static Colors[] values()&#123;</span><br><span class="line">      return values;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static Colors valueOf(String name)&#123;</span><br><span class="line">      return (Colors)java.lang.Enum.valueOf(Colors.class, name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>java编译器创建了三个构造和方法，为该枚举构造： Colors(String name, int ordinal), Colors[] values(), and Colors valueOf(String name). 方法values和valueOf是隐性声明的. 因此他们的形参名称也是隐性的。</p><p>枚举的Colors(String name, int ordinal)构造函数是一个默认构造函数，隐性声明。然而，该构造的形参（name和ordinal）则是非隐性声明的，因为这些形参既不是明确的，也不是隐性的，是合成的。 (一个枚举构造的默认构造的形参不是隐性声明的，因为不同的编译器构造的形式要求不一样；另一个java编译器可能指定不同的形参。当编译器编译使用了枚举常量的表达式时，他们仅仅依赖枚举构造的公共静态字段，不依赖构造函数及常量初始化的过程。）<br>因此：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">enum Colors:</span><br><span class="line"></span><br><span class="line">Number of constructors: 0</span><br><span class="line"></span><br><span class="line">Number of declared constructors: 1</span><br><span class="line"></span><br><span class="line">Declared constructor #1</span><br><span class="line">private MethodParameterExamples$Colors()</span><br><span class="line">       Parameter class: class java.lang.String</span><br><span class="line">        Parameter name: $enum$name</span><br><span class="line">             Modifiers: 4096</span><br><span class="line">          Is implicit?: false</span><br><span class="line">      Is name present?: true</span><br><span class="line">         Is synthetic?: true</span><br><span class="line">       Parameter class: int</span><br><span class="line">        Parameter name: $enum$ordinal</span><br><span class="line">             Modifiers: 4096</span><br><span class="line">          Is implicit?: false</span><br><span class="line">      Is name present?: true</span><br><span class="line">         Is synthetic?: true</span><br><span class="line"></span><br><span class="line">Number of methods: 2</span><br><span class="line"></span><br><span class="line">Method #1</span><br><span class="line">public static MethodParameterExamples$Colors[]</span><br><span class="line">  MethodParameterExamples$Colors.values()</span><br><span class="line">           Return type: class [LMethodParameterExamples$Colors;</span><br><span class="line">   Generic return type: class [LMethodParameterExamples$Colors;</span><br><span class="line"></span><br><span class="line">Method #2</span><br><span class="line">public static MethodParameterExamples$Colors</span><br><span class="line">  MethodParameterExamples$Colors.valueOf(java.lang.String)</span><br><span class="line">           Return type: class MethodParameterExamples$Colors</span><br><span class="line">   Generic return type: class MethodParameterExamples$Colors</span><br><span class="line">       Parameter class: class java.lang.String</span><br><span class="line">        Parameter name: name</span><br><span class="line">             Modifiers: 32768</span><br><span class="line">          Is implicit?: true</span><br><span class="line">      Is name present?: true</span><br><span class="line">         Is synthetic?: false</span><br></pre></td></tr></table></figure></p><h4 id="获取-amp-解析方法修饰符"><a href="#获取-amp-解析方法修饰符" class="headerlink" title="获取&amp;解析方法修饰符"></a>获取&amp;解析方法修饰符</h4><p>有几个可能成为方法声明的几个修饰符：</p><ul><li>访问修饰符: public, protected, and private</li><li>限制到一个实例的修饰符： static</li><li>禁止改变值的修饰符：final</li><li>需要覆盖的修饰符： abstract</li><li>组织可重入的修饰符：synchronized</li><li>表示用另一种语言实现的修饰符: native</li><li>强制执行严格的浮点行为: strictfp</li><li>注解：Annotations</li></ul><p>MethodModifierSpy例子展示的指定方法的修饰符，及方法是否是编译器生成（synthetic），是否包含可变参数，是否是桥接方法（编译器生成来支持通用接口).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">  import java.lang.reflect.Method;</span><br><span class="line">  import java.lang.reflect.Modifier;</span><br><span class="line">  import static java.lang.System.out;</span><br><span class="line"></span><br><span class="line">  public class MethodModifierSpy &#123;</span><br><span class="line"></span><br><span class="line">      private static int count;</span><br><span class="line">      private static synchronized void inc() &#123; count++; &#125;</span><br><span class="line">      private static synchronized int cnt() &#123; return count; &#125;</span><br><span class="line"></span><br><span class="line">      public static void main(String... args) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          Class&lt;?&gt; c = Class.forName(args[0]);</span><br><span class="line">          Method[] allMethods = c.getDeclaredMethods();</span><br><span class="line">          for (Method m : allMethods) &#123;</span><br><span class="line">      if (!m.getName().equals(args[1])) &#123;</span><br><span class="line">          continue;</span><br><span class="line">      &#125;</span><br><span class="line">      out.format(&quot;%s%n&quot;, m.toGenericString());</span><br><span class="line">      out.format(&quot;  Modifiers:  %s%n&quot;,</span><br><span class="line">         Modifier.toString(m.getModifiers()));</span><br><span class="line">      out.format(&quot;  [ synthetic=%-5b var_args=%-5b bridge=%-5b ]%n&quot;,</span><br><span class="line">         m.isSynthetic(), m.isVarArgs(), m.isBridge());</span><br><span class="line">      inc();</span><br><span class="line">          &#125;</span><br><span class="line">          out.format(&quot;%d matching overload%s found%n&quot;, cnt(),</span><br><span class="line">             (cnt() == 1 ? &quot;&quot; : &quot;s&quot;));</span><br><span class="line"></span><br><span class="line">              // production code should handle this exception more gracefully</span><br><span class="line">      &#125; catch (ClassNotFoundException x) &#123;</span><br><span class="line">          x.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">$ java MethodModifierSpy java.lang.Object wait</span><br><span class="line">public final void java.lang.Object.wait() throws java.lang.InterruptedException</span><br><span class="line">  Modifiers:  public final</span><br><span class="line">  [ synthetic=false var_args=false bridge=false ]</span><br><span class="line">public final void java.lang.Object.wait(long,int)</span><br><span class="line">  throws java.lang.InterruptedException</span><br><span class="line">  Modifiers:  public final</span><br><span class="line">  [ synthetic=false var_args=false bridge=false ]</span><br><span class="line">public final native void java.lang.Object.wait(long)</span><br><span class="line">  throws java.lang.InterruptedException</span><br><span class="line">  Modifiers:  public final native</span><br><span class="line">  [ synthetic=false var_args=false bridge=false ]</span><br><span class="line">3 matching overloads found</span><br><span class="line"></span><br><span class="line">$ java MethodModifierSpy java.lang.StrictMath toRadians</span><br><span class="line">public static double java.lang.StrictMath.toRadians(double)</span><br><span class="line">  Modifiers:  public static strictfp</span><br><span class="line">  [ synthetic=false var_args=false bridge=false ]</span><br><span class="line">1 matching overload found</span><br><span class="line">$ java MethodModifierSpy MethodModifierSpy inc</span><br><span class="line">private synchronized void MethodModifierSpy.inc()</span><br><span class="line">  Modifiers: private synchronized</span><br><span class="line">  [ synthetic=false var_args=false bridge=false ]</span><br><span class="line">1 matching overload found</span><br><span class="line"></span><br><span class="line">$ java MethodModifierSpy java.lang.Class getConstructor</span><br><span class="line">public java.lang.reflect.Constructor&lt;T&gt; java.lang.Class.getConstructor</span><br><span class="line">  (java.lang.Class&lt;T&gt;[]) throws java.lang.NoSuchMethodException,</span><br><span class="line">  java.lang.SecurityException</span><br><span class="line">  Modifiers: public transient</span><br><span class="line">  [ synthetic=false var_args=true bridge=false ]</span><br><span class="line">1 matching overload found</span><br><span class="line"></span><br><span class="line">$ java MethodModifierSpy java.lang.String compareTo</span><br><span class="line">public int java.lang.String.compareTo(java.lang.String)</span><br><span class="line">  Modifiers: public</span><br><span class="line">  [ synthetic=false var_args=false bridge=false ]</span><br><span class="line">public int java.lang.String.compareTo(java.lang.Object)</span><br><span class="line">  Modifiers: public volatile</span><br><span class="line">  [ synthetic=true  var_args=false bridge=true  ]</span><br><span class="line"></span><br><span class="line">  2 matching overloads found</span><br></pre></td></tr></table></figure></p><p>注意对Class.getConstructor()执行Method.isVarArgs()返回true，这因为该方法声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</span><br></pre></td></tr></table></figure></p><p>而非：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt; [] parameterTypes)</span><br></pre></td></tr></table></figure></p><p>注意String.compareTo()方法的输出有2个方法，一个是String.java声明的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      public int compareTo(String anotherString);</span><br><span class="line">```      </span><br><span class="line">另一个是编译器生成的桥接方法或合成方法。这种情况是因为String事先了参数化泛型接口Comparable。在类型擦除时，继承的方法Comparable.compareTo()的参数类型从java.lang.Object变为java.lang.String。由于Comparable接口中的compareTo方法的参数化类型和String的方法在类型擦除后，不在匹配，不存在覆盖overriding。在所有的情形中，这会产生一个编译错误，因为接口没有被实现。桥接方法的作用就是避免这种问题。</span><br><span class="line"></span><br><span class="line">Method实现了java.lang.reflect.AnnotatedElement，所以保留策略为运行时的注解java.lang.annotation.RetentionPolicy.RUNTIME都能够获取到.</span><br><span class="line">#### 调用方法</span><br><span class="line">反射提供了执行类的方法的手段。通常，反射调用方法仅仅当在非反射代码里不可能转化类的实例到指定类型时才是必须的。通过java.lang.reflect.Method.invoke()可以执行方法的调用，第一个参数表示执行哪一个实例的指定方法（如果方法是静态的，第一个参数应该是null），第二个参数表示方法执行所需的参数。如果底层方法抛出异常，会被java.lang.reflect.InvocationTargetException包装。方法的原始异常可以通过异常链机制的InvocationTargetException.getCause()方法获取。</span><br><span class="line"></span><br><span class="line">##### 找到&amp;执行指定声明的方法</span><br></pre></td></tr></table></figure></p><pre><code>import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Type;import java.util.Locale;import static java.lang.System.out;import static java.lang.System.err;public class Deet&lt;T&gt; {  private boolean testDeet(Locale l) {      // getISO3Language() may throw a MissingResourceException      out.format(&quot;Locale = %s, ISO Language Code = %s%n&quot;, l.getDisplayName(), l.getISO3Language());      return true;  }  private int testFoo(Locale l) { return 0; }  private boolean testBar() { return true; }  public static void main(String... args) {    if (args.length != 4) {        err.format(&quot;Usage: java Deet &lt;classname&gt; &lt;langauge&gt; &lt;country&gt; &lt;variant&gt;%n&quot;);        return;    }    try {        Class&lt;?&gt; c = Class.forName(args[0]);        Object t = c.newInstance();        Method[] allMethods = c.getDeclaredMethods();        for (Method m : allMethods) {        String mname = m.getName();        if (!mname.startsWith(&quot;test&quot;)            || (m.getGenericReturnType() != boolean.class)) {            continue;        }         Type[] pType = m.getGenericParameterTypes();         if ((pType.length != 1)            || Locale.class.isAssignableFrom(pType[0].getClass())) {             continue;         }        out.format(&quot;invoking %s()%n&quot;, mname);        try {            m.setAccessible(true);            Object o = m.invoke(t, new Locale(args[1], args[2], args[3]));            out.format(&quot;%s() returned %b%n&quot;, mname, (Boolean) o);        // Handle any exceptions thrown by method to be invoked.        } catch (InvocationTargetException x) {            Throwable cause = x.getCause();            err.format(&quot;invocation of %s failed: %s%n&quot;,                   mname, cause.getMessage());        }        }        // production code should handle these exceptions more gracefully    } catch (ClassNotFoundException x) {        x.printStackTrace();    } catch (InstantiationException x) {        x.printStackTrace();    } catch (IllegalAccessException x) {        x.printStackTrace();    }  }}</code></pre><p><code>`</code></p><p>Deet invokes getDeclaredMethods() which will return all methods explicitly declared in the class. Also, Class.isAssignableFrom() is used to determine whether the parameters of the located method are compatible with the desired invocation. Technically the code could have tested whether the following statement is true since Locale is final:</p><p>Locale.class == pType[0].getClass()<br>However, Class.isAssignableFrom() is more general.</p><p>$ java Deet Deet ja JP JP<br>invoking testDeet()<br>Locale = Japanese (Japan,JP),<br>ISO Language Code = jpn<br>testDeet() returned true<br>$ java Deet Deet xx XX XX<br>invoking testDeet()<br>invocation of testDeet failed:<br>Couldn’t find 3-letter language code for xx<br>First, note that only testDeet() meets the declaration restrictions enforced by the code. Next, when testDeet() is passed an invalid argument it throws an unchecked java.util.MissingResourceException. In reflection, there is no distinction in the handling of checked versus unchecked exceptions. They are all wrapped in an InvocationTargetException</p><p>Invoking Methods with a Variable Number of Arguments</p><p>Method.invoke() may be used to pass a variable number of arguments to a method. The key concept to understand is that methods of variable arity are implemented as if the variable arguments are packed in an array.</p><p>The InvokeMain example illustrates how to invoke the main() entry point in any class and pass a set of arguments determined at runtime.</p><p>import java.lang.reflect.InvocationTargetException;<br>import java.lang.reflect.Method;<br>import java.util.Arrays;</p><p>public class InvokeMain {<br>    public static void main(String… args) {<br>    try {<br>        Class&lt;?&gt; c = Class.forName(args[0]);<br>        Class[] argTypes = new Class[] { String[].class };<br>        Method main = c.getDeclaredMethod(“main”, argTypes);<br>          String[] mainArgs = Arrays.copyOfRange(args, 1, args.length);<br>        System.out.format(“invoking %s.main()%n”, c.getName());<br>        main.invoke(null, (Object)mainArgs);</p><pre><code>    // production code should handle these exceptions more gracefully} catch (ClassNotFoundException x) {    x.printStackTrace();} catch (NoSuchMethodException x) {    x.printStackTrace();} catch (IllegalAccessException x) {    x.printStackTrace();} catch (InvocationTargetException x) {    x.printStackTrace();}}</code></pre><p>}<br>First, to find the main() method the code searches for a class with the name “main” with a single parameter that is an array of String Since main() is static, null is the first argument to Method.invoke(). The second argument is the array of arguments to be passed.</p><p>$ java InvokeMain Deet Deet ja JP JP<br>invoking Deet.main()<br>invoking testDeet()<br>Locale = Japanese (Japan,JP),<br>ISO Language Code = jpn<br>testDeet() returned true</p><h4 id="Troubleshooting-covers-common-errors-encountered-when-finding-or-invoking-methods"><a href="#Troubleshooting-covers-common-errors-encountered-when-finding-or-invoking-methods" class="headerlink" title="Troubleshooting covers common errors encountered when finding or invoking methods"></a>Troubleshooting covers common errors encountered when finding or invoking methods</h4><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>The Reflection APIs for constructors are defined in java.lang.reflect.Constructor and are similar to those for methods, with two major exceptions: first, constructors have no return values; second, the invocation of a constructor creates a new instance of an object for a given class.</p><h4 id="Finding-Constructors-illustrates-how-to-retrieve-constructors-with-specific-parameters"><a href="#Finding-Constructors-illustrates-how-to-retrieve-constructors-with-specific-parameters" class="headerlink" title="Finding Constructors illustrates how to retrieve constructors with specific parameters"></a>Finding Constructors illustrates how to retrieve constructors with specific parameters</h4><h4 id="Retrieving-and-Parsing-Constructor-Modifiers-shows-how-to-obtain-the-modifiers-of-a-constructor-declaration-and-other-information-about-the-constructor"><a href="#Retrieving-and-Parsing-Constructor-Modifiers-shows-how-to-obtain-the-modifiers-of-a-constructor-declaration-and-other-information-about-the-constructor" class="headerlink" title="Retrieving and Parsing Constructor Modifiers shows how to obtain the modifiers of a constructor declaration and other information about the constructor"></a>Retrieving and Parsing Constructor Modifiers shows how to obtain the modifiers of a constructor declaration and other information about the constructor</h4><h4 id="Creating-New-Class-Instances-shows-how-to-instantiate-an-instance-of-an-object-by-invoking-its-constructor"><a href="#Creating-New-Class-Instances-shows-how-to-instantiate-an-instance-of-an-object-by-invoking-its-constructor" class="headerlink" title="Creating New Class Instances shows how to instantiate an instance of an object by invoking its constructor"></a>Creating New Class Instances shows how to instantiate an instance of an object by invoking its constructor</h4><h4 id="Troubleshooting-describes-common-errors-which-may-be-encountered-while-finding-or-invoking-constructors"><a href="#Troubleshooting-describes-common-errors-which-may-be-encountered-while-finding-or-invoking-constructors" class="headerlink" title="Troubleshooting describes common errors which may be encountered while finding or invoking constructors"></a>Troubleshooting describes common errors which may be encountered while finding or invoking constructors</h4>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;反射中字段、方法、构造函数的学习&quot;&gt;&lt;a href=&quot;#反射中字段、方法、构造函数的学习&quot; class=&quot;headerlink&quot; title=&quot;反射中字段、方法、构造函数的学习&quot;&gt;&lt;/a&gt;反射中字段、方法、构造函数的学习&lt;/h3&gt;
    
    </summary>
    
      <category term="java" scheme="http://zhangxiangnan.com/categories/java/"/>
    
    
      <category term="java" scheme="http://zhangxiangnan.com/tags/java/"/>
    
      <category term="reflect" scheme="http://zhangxiangnan.com/tags/reflect/"/>
    
  </entry>
  
  <entry>
    <title>JAVA反射介绍及Class详解</title>
    <link href="http://zhangxiangnan.com/2017/04/12/java/JAVA%E5%8F%8D%E5%B0%84%E4%BB%8B%E7%BB%8D%E5%8F%8AClass%E8%AF%A6%E8%A7%A3/"/>
    <id>http://zhangxiangnan.com/2017/04/12/java/JAVA反射介绍及Class详解/</id>
    <published>2017-04-12T12:14:01.000Z</published>
    <updated>2019-03-01T16:53:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="反射的用途"><a href="#反射的用途" class="headerlink" title="反射的用途"></a>反射的用途</h3><p>  反射对于想要在运行时去检查或修改运行在Java虚拟机中的程序的运行时行为的场合，经常用到。<br>  <a id="more"></a></p><ul><li>可扩展的特征<br>应用程序可以通过使用可扩展对象的全名称创建实例来使用外部用户定义的类</li><li>类浏览器和可视化开发环境<br>一个类浏览器需要能够枚举出类的成员。可视化开发环境可以借助于使用反射提供的类型信息来帮助开发者写正确的代码。</li><li>调试器和测试工具<br>调试器能够检查类的基本成员.测试工具可以利用反射来得到类中定义的API，来确保测试用例的高度覆盖（检查单元测试覆盖率）。</li></ul><h3 id="反射的缺点"><a href="#反射的缺点" class="headerlink" title="反射的缺点"></a>反射的缺点</h3><p>反射很强大，但不能滥用。能不用反射就不用，不得不用反射时需要考虑以下几点：</p><ul><li>性能开销<br>因为反射设计动态解析的类型，所以不能执行某些Java虚拟机优化。因此反射操作的性能比非反射对象的性能更慢，应该在对性能敏感的程序中频繁调用的地方尽量避免使用反射。</li><li>安全限制<br>反射需要一个运行时权限，但运行在安全管理器下该权限可能不存在。对于必须在安全受限的上下文来说，很重要，如Applet</li><li>内部暴露<br>由于反射允许代码执行非反射代码中认为非法的操作，如访问私有字段和方法，此时使用反射能导致意外地副作用，导致代码功能失调、破坏可移植性。同时，反射代码破坏了抽象性，因此可能通过更新平台来改变行为（不懂）</li></ul><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>每一个对象要么是引用类型要么是基本类型。引用类型全部继承自java.lang.Object。Classes、enums、arrays及interfaces都是引用类型。基本类型只包括8种：boolean、byte、short、long、char、int、float、double。引用类型例如java.lang.String，所有基本类型的包装类型如java.lang.Double，接口java.io.Serializable，及枚举javax.swing.SortOrder。</p><p>针对每一种对象类型，Java虚拟机实例化java.lang.Class的一份不可变实例。Class提供了方法来检查对象的运行时属性，包括成员和类型信息，同时Class也提供了创建新的classes及对象的功能。更重要的是，Class是所有反射API的入口。</p><h4 id="重新获取Class对象"><a href="#重新获取Class对象" class="headerlink" title="重新获取Class对象"></a>重新获取Class对象</h4><p>  所有反射操作的入口是java.lang.Class。除了java.lang.reflect.ReflectPermission类，java.lang.reflect包下的其他类都没有公共构造函数。要获得这些类，有必要调取Class的相应地方法。有几种方法来来获取Class，根据是代码否有权限访问一个对象，类的名称，类型或一个已存在的Class。</p><h5 id="Object-getClass"><a href="#Object-getClass" class="headerlink" title="Object.getClass()"></a>Object.getClass()</h5><p>  如果能取到类的某个实例对象，最简单的获取其Class对象的方式是调用Object.getClass()方法。当然，这种方式只适合于全部继承自Object类的引用类型。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c = &quot;foo&quot;.getClass();</span><br></pre></td></tr></table></figure></p><p>  返回String类的Class对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c = System.console().getClass();</span><br></pre></td></tr></table></figure></p><p>  和虚拟机关联的有一个唯一的console对象，通过System.console()对象返回，getClass()返回的是java.io.Console类的Class对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum E &#123; A, B &#125;</span><br><span class="line">Class c = A.getClass();</span><br></pre></td></tr></table></figure></p><p>  A是枚举类型E的一个实例，getClass()方法返回枚举类型E对应的Class对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte[] bytes = new byte[1024];</span><br><span class="line">Class c = bytes.getClass();</span><br></pre></td></tr></table></figure><p>  由于数组是Object对象，所以也能对数组的实例调用getClass()方法。返回的Class对应组件类型为byte的数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; s = new HashSet&lt;String&gt;();</span><br><span class="line">Class c = s.getClass();</span><br></pre></td></tr></table></figure><p>  该例中，java.util.Set是java.util.HashSet类型的实例对象实现的一个接口。getClass()返回的Class对应于java.util.HashSet。</p><h5 id="class语法"><a href="#class语法" class="headerlink" title=".class语法"></a>.class语法</h5><p>如果有类型但是没有实例对象，通过追加”.class”到类型的名称后面也可以获取到Class。这也是基本类型最简单的方式获取Class。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">boolean b;</span><br><span class="line">Class c = b.getClass();   // 编译报错</span><br><span class="line"></span><br><span class="line">Class c = boolean.class;  // 正确</span><br></pre></td></tr></table></figure></p><p>注意boolean.getClass()会产生编译错误，因为boolean类型时基本类型，不能被引用。.class语法返回类型boolean对应的Class。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  Class c = java.io.PrintStream.class;</span><br><span class="line">返回java.io.PrintStream类型对应的Class对象</span><br><span class="line"></span><br><span class="line">  Class c = int[][][].class;</span><br><span class="line">The .class也用来获取多维数组类型对应的Class</span><br></pre></td></tr></table></figure></p><h5 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName()"></a>Class.forName()</h5><p>如果有一个类的全限定名称，使用静态方法Class.forName()能获取到对应的Class对象。该方式不能用来加载基本类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c = Class.forName(&quot;com.duke.MyLocaleServiceProvider&quot;);</span><br></pre></td></tr></table></figure></p><p>该语句根据传入的全限定名来创建一个class对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class cDoubleArray = Class.forName(&quot;[D&quot;);</span><br><span class="line">Class cStringArray = Class.forName(&quot;[[Ljava.lang.String;&quot;);</span><br></pre></td></tr></table></figure></p><p>如果是数组类型传入的名称，则按下面Class.getName的描述；变量cDoubleArray表示基本类型double数组对应的Class（和double[].class一样），变量cStringArray表示String的二维数组对应的Class（和String[][].class一样）。</p><h5 id="Class-getName-："><a href="#Class-getName-：" class="headerlink" title="Class.getName()："></a>Class.getName()：</h5><p>  返回Class对象代表的实体的字符串名称（类、接口、数组、基本类型或void）</p><ul><li>如果该class对象表示一个引用类型（非数组类型）就依据java语言规范，返回类的二进制名称。</li><li>如果该class对象表示一个基本类型或者void类型，返回对应基本类型或者void的java语言关键字对应的字符串</li><li>如果该class对象表示一个数组类，则名称由元素类型的名称前面追加字符”[“表示数组嵌套的深度，元素类型名称的编码如下：    </li></ul><p>元素类型|编码   </p><table><thead><tr><th>boolean</th><th>Z    </th></tr></thead><tbody><tr><td>byte</td><td>B</td></tr><tr><td>char</td><td>C</td></tr><tr><td>类或接口</td><td>类全限定名称</td></tr><tr><td>double</td><td>D</td></tr><tr><td>float</td><td>F</td></tr><tr><td>int</td><td>I</td></tr><tr><td>long</td><td>J</td></tr><tr><td>short</td><td>S</td></tr></tbody></table><p>类或接口名称就如上述说明的类的二进制名称</p><p>  示例:   </p><table><thead><tr><th>方法调用</th><th>结果    </th></tr></thead><tbody><tr><td>String.class.getName()</td><td>“java.lang.String”</td></tr><tr><td>byte.class.getName()</td><td>“byte”</td></tr><tr><td>(new Object[3]).getClass().getName()</td><td>“[Ljava.lang.Object;”</td></tr><tr><td>(new int[3][4][5][6][7][8][9]).getClass().getName()</td><td>“[[[[[[[I”</td></tr></tbody></table><h5 id="基本类型包装类的TYPE字段"><a href="#基本类型包装类的TYPE字段" class="headerlink" title="基本类型包装类的TYPE字段"></a>基本类型包装类的TYPE字段</h5><p>对于基本类型来说.Class语法获取其Class对象非常方便，也是首选方式；还有另一种方式来获取Class。每一个基本类型和void类型都有一个包装类在java.lang中，将基本类型装箱为包装类型。每一个包装类型有一个TYPE字段，即是基本类型对应的Class对象</p><p>Class c = Double.TYPE;// 相等于double.class<br>Class c = Void.TYPE;//相等于void.class.</p><h5 id="返回Classes的方法"><a href="#返回Classes的方法" class="headerlink" title="返回Classes的方法"></a>返回Classes的方法</h5><p>有几个反射API可以返回classes，但是只有当某个Class已经直接或间接得到才能访问那几个API。    </p><p><strong>Class.getSuperclass()</strong><br>  返回指定class的超类class<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c = javax.swing.JButton.class.getSuperclass();// 返回javax.swing.AbstractButton.</span><br></pre></td></tr></table></figure></p><p><strong>Class.getClasses()</strong><br>返回指定class的所有的公共classes、接口及枚举成员，包含继承的成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt;[] c = Character.class.getClasses();//返回内部多个公共class成员</span><br></pre></td></tr></table></figure></p><p><strong>Class.getDeclaredClasses()</strong><br>返回class里所有显示声明的类、接口、枚举（公共、私有等都包含）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt;[] c = Character.class.getDeclaredClasses();//返回显示声明的几个类</span><br></pre></td></tr></table></figure></p><p><strong>Class.getDeclaringClass()</strong><br>如果Class对象表示的接口或类是另一个类的成员，则返回声明该成员的类对应的Class对象；否则如果不是任何其他类的成员则返回null。如果该Class对象表示一个数组类型、基本类型、或void，则返回null。<br>匿名类的声明没有声明类但有一个封闭类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    static Object o = new Object() &#123;</span><br><span class="line">        public void m() &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    static Class&lt;c&gt; = o.getClass().getDeclaringClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>o定义的匿名类的声明类为null</p><p><strong>Class.getEnclosingClass()</strong><br>返回class的直接封闭类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class c = Thread.State.class().getEnclosingClass();//枚举类Thread.State的封闭类是Thread</span><br><span class="line"></span><br><span class="line">public class MyClass &#123;</span><br><span class="line">    static Object o = new Object() &#123;</span><br><span class="line">        public void m() &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    static Class&lt;c&gt; = o.getClass().getEnclosingClass();</span><br><span class="line">&#125;</span><br><span class="line">o定义的匿名内部类的封闭类是Mycalss</span><br></pre></td></tr></table></figure></p><p><strong>java.lang.reflect.Field.getDeclaringClass()</strong><br>返回这些成员被声明的Class。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Field;</span><br><span class="line">Field f = System.class.getField(&quot;out&quot;);</span><br><span class="line">Class c = f.getDeclaringClass();//返回System,out字段在System类里定义</span><br></pre></td></tr></table></figure></p><p><strong>java.lang.reflect.Method.getDeclaringClass()</strong><br>返回这些成员被声明的Class。</p><p><strong>java.lang.reflect.Constructor.getDeclaringClass()</strong><br>返回这些成员被声明的Class。    </p><p><strong>Class.getGenericInterfaces()</strong></p><p>返回该对象表示的类或接口直接实现的接口的类型(Type类型)</p><ul><li>如果某个实现的接口是参数化类型，则返回的Type对象必须准确反映出源码中使用的实际类型参数，如果以前没有创建表示每个实现接口的参数化类型，则创建该类型。</li><li>如果该对象是一个类，则返回该类实现的所有的接口数组，顺序按照该对象表示的类实现接口时的顺序对应；对于数组来说，按照Cloneable、Serializable的顺序返回。</li><li>如果该对象是一个接口，返回该接口直接继承的所有接口，顺序按照和接口继承时声明的接口顺序一致。</li><li>如果该对象是类或接口，但是没有实现任何接口，返回空数组。</li><li>如果该对象是基本类型或void，返回空数组。</li></ul><p><strong>Class.getInterfaces()</strong></p><p>返回类型时Class类型</p><ul><li>如果该对象是一个类，则返回该类实现的所有的接口数组，顺序按照该对象表示的类实现接口时的顺序对应；对于数组来说，按照Cloneable、Serializable的顺序返回。</li><li>如果该对象是一个接口，返回该接口直接继承的所有接口，顺序按照和接口继承时声明的接口顺序一致。</li><li>如果该对象是类或接口，但是没有实现任何接口，返回空数组。</li><li>如果该对象是基本类型或void，返回空数组。</li></ul><p><strong>Class.getModifiers()</strong></p><p>返回类或接口的java语言修饰符，加密成一个整数。修饰符包含Java虚拟机为public、protected、private、final、static、abstract、interface的常量，需要使用Modifier的方法来解码</p><ul><li>如果是数组类型，public、private、protected修饰符是和数组的组件类型一致</li><li>如果是基本类型或者void，总是有public修饰符，总无protected及private修饰符。</li><li>如果是数组类型、基本类型或void，总有final修饰符，总是无interface修饰符。其他修饰符不能由此规则决定。</li><li>如果是数组类型，总有abstract修饰符</li></ul><h4 id="检查类的修饰符和类型"><a href="#检查类的修饰符和类型" class="headerlink" title="检查类的修饰符和类型"></a>检查类的修饰符和类型</h4><p>class可以定义一个或多个修饰符来决定运行时行为：</p><ul><li>访问修饰符：public, protected, and private</li><li>需要重写的修饰符：abstract</li><li>限制为某个实例的修饰符：: static</li><li>禁止值被修改的修饰符： final</li><li>强制执行严格的浮点行为的修饰符：strictfp</li><li>注解<br>并不是所有的修饰符可以用在所有类上，如接口不能用final修饰，enum不能用abstract修饰。java.lang.reflect.Modifier包含了所有可能的修饰符的声明，也包含了对Class.getModifiers()方法返回的修饰符标记的解码方法。</li></ul><p>如下例展示了如何获取类的声明的组件类型包括修饰符、泛型参数、实现的接口及继承的父类的路径。如果累实现了java.lang.reflect.AnnotatedElement接口，也能拿到运行时的注解信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.Annotation;</span><br><span class="line">import java.lang.reflect.Modifier;</span><br><span class="line">import java.lang.reflect.Type;</span><br><span class="line">import java.lang.reflect.TypeVariable;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import static java.lang.System.out;</span><br><span class="line"></span><br><span class="line">public class ClassDeclarationSpy &#123;</span><br><span class="line">    public static void main(String... args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Class&lt;?&gt; c = Class.forName(args[0]);//根据类名称得到class对象</span><br><span class="line">        out.format(&quot;Class:%n  %s%n%n&quot;, c.getCanonicalName());// 类的规范名称</span><br><span class="line">        out.format(&quot;Modifiers:%n  %s%n%n&quot;,</span><br><span class="line">           Modifier.toString(c.getModifiers()));// 输出类的修饰符</span><br><span class="line"></span><br><span class="line">        out.format(&quot;Type Parameters:%n&quot;);</span><br><span class="line">        TypeVariable[] tv = c.getTypeParameters();// 获取类型参数</span><br><span class="line">        if (tv.length != 0) &#123;</span><br><span class="line">        out.format(&quot;  &quot;);</span><br><span class="line">        for (TypeVariable t : tv)</span><br><span class="line">            out.format(&quot;%s &quot;, t.getName());</span><br><span class="line">        out.format(&quot;%n%n&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          out.format(&quot;  -- No Type Parameters --%n%n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.format(&quot;Implemented Interfaces:%n&quot;);</span><br><span class="line">        Type[] intfs = c.getGenericInterfaces();// 实现接口</span><br><span class="line">        if (intfs.length != 0) &#123;</span><br><span class="line">        for (Type intf : intfs)</span><br><span class="line">            out.format(&quot;  %s%n&quot;, intf.toString());</span><br><span class="line">        out.format(&quot;%n&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          out.format(&quot;  -- No Implemented Interfaces --%n%n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.format(&quot;Inheritance Path:%n&quot;);// 继承路径</span><br><span class="line">        List&lt;Class&gt; l = new ArrayList&lt;Class&gt;();</span><br><span class="line">        printAncestor(c, l);</span><br><span class="line">        if (l.size() != 0) &#123;</span><br><span class="line">        for (Class&lt;?&gt; cl : l)</span><br><span class="line">            out.format(&quot;  %s%n&quot;, cl.getCanonicalName());</span><br><span class="line">        out.format(&quot;%n&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          out.format(&quot;  -- No Super Classes --%n%n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.format(&quot;Annotations:%n&quot;);</span><br><span class="line">        Annotation[] ann = c.getAnnotations();// 注解</span><br><span class="line">        if (ann.length != 0) &#123;</span><br><span class="line">        for (Annotation a : ann)</span><br><span class="line">            out.format(&quot;  %s%n&quot;, a.toString());</span><br><span class="line">        out.format(&quot;%n&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          out.format(&quot;  -- No Annotations --%n%n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            // production code should handle this exception more gracefully</span><br><span class="line">    &#125; catch (ClassNotFoundException x) &#123;</span><br><span class="line">        x.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void printAncestor(Class&lt;?&gt; c, List&lt;Class&gt; l) &#123;</span><br><span class="line">    Class&lt;?&gt; ancestor = c.getSuperclass();// 实现的父类</span><br><span class="line">     if (ancestor != null) &#123;</span><br><span class="line">        l.add(ancestor);</span><br><span class="line">        printAncestor(ancestor, l);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>几个不同输入参数下的结果示例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">$ java ClassDeclarationSpy java.util.concurrent.ConcurrentNavigableMap</span><br><span class="line">Class:</span><br><span class="line">  java.util.concurrent.ConcurrentNavigableMap</span><br><span class="line"></span><br><span class="line">Modifiers:</span><br><span class="line">  public abstract interface</span><br><span class="line"></span><br><span class="line">Type Parameters:</span><br><span class="line">  K V</span><br><span class="line"></span><br><span class="line">Implemented Interfaces:</span><br><span class="line">  java.util.concurrent.ConcurrentMap&lt;K, V&gt;</span><br><span class="line">  java.util.NavigableMap&lt;K, V&gt;</span><br><span class="line"></span><br><span class="line">Inheritance Path:</span><br><span class="line">  -- No Super Classes --</span><br><span class="line"></span><br><span class="line">Annotations:</span><br><span class="line">  -- No Annotations --</span><br><span class="line">This is the actual declaration for java.util.concurrent.ConcurrentNavigableMap in the source code:</span><br><span class="line"></span><br><span class="line">public interface ConcurrentNavigableMap&lt;K,V&gt;</span><br><span class="line">    extends ConcurrentMap&lt;K,V&gt;, NavigableMap&lt;K,V&gt;</span><br><span class="line">注意由于上述例子参数是接口，隐含abstract修饰符。编译器为每个接口添加该修饰符。同样，该接口有2个泛型参数，K、V。K、V具体的额外信息可通过TypeVariable的方法得到。上述说明接口也可以实现接口。</span><br><span class="line"></span><br><span class="line">$ java ClassDeclarationSpy &quot;[Ljava.lang.String;&quot;</span><br><span class="line">Class:</span><br><span class="line">  java.lang.String[]</span><br><span class="line"></span><br><span class="line">Modifiers:</span><br><span class="line">  public abstract final</span><br><span class="line"></span><br><span class="line">Type Parameters:</span><br><span class="line">  -- No Type Parameters --</span><br><span class="line"></span><br><span class="line">Implemented Interfaces:</span><br><span class="line">  interface java.lang.Cloneable</span><br><span class="line">  interface java.io.Serializable</span><br><span class="line"></span><br><span class="line">Inheritance Path:</span><br><span class="line">  java.lang.Object</span><br><span class="line"></span><br><span class="line">Annotations:</span><br><span class="line">  -- No Annotations --</span><br><span class="line">由于数组是运行时对象，所有的类型信息都由java虚拟机提供。特别的，数组实现了Cloneable、java.io.Serializable接口，并且数组的直接父类总是Object类。</span><br><span class="line"></span><br><span class="line">$ java ClassDeclarationSpy java.io.InterruptedIOException</span><br><span class="line">Class:</span><br><span class="line">  java.io.InterruptedIOException</span><br><span class="line"></span><br><span class="line">Modifiers:</span><br><span class="line">  public</span><br><span class="line"></span><br><span class="line">Type Parameters:</span><br><span class="line">  -- No Type Parameters --</span><br><span class="line"></span><br><span class="line">Implemented Interfaces:</span><br><span class="line">  -- No Implemented Interfaces --</span><br><span class="line"></span><br><span class="line">Inheritance Path:</span><br><span class="line">  java.io.IOException</span><br><span class="line">  java.lang.Exception</span><br><span class="line">  java.lang.Throwable</span><br><span class="line">  java.lang.Object</span><br><span class="line"></span><br><span class="line">Annotations:</span><br><span class="line">  -- No Annotations --</span><br><span class="line"></span><br><span class="line">$ java ClassDeclarationSpy java.security.Identity</span><br><span class="line">Class:</span><br><span class="line">  java.security.Identity</span><br><span class="line"></span><br><span class="line">Modifiers:</span><br><span class="line">  public abstract</span><br><span class="line"></span><br><span class="line">Type Parameters:</span><br><span class="line">  -- No Type Parameters --</span><br><span class="line"></span><br><span class="line">Implemented Interfaces:</span><br><span class="line">  interface java.security.Principal</span><br><span class="line">  interface java.io.Serializable</span><br><span class="line"></span><br><span class="line">Inheritance Path:</span><br><span class="line">  java.lang.Object</span><br><span class="line"></span><br><span class="line">Annotations:</span><br><span class="line">  @java.lang.Deprecated()</span><br></pre></td></tr></table></figure></p><p>  java.security.Identity被注解标记为过时的api，可以用来通过反射代码来监测过时API<br>  注意：并不是所有的注解都能通过反射拿到，需要注解的保留策略的类型为Runtime类型（ java.lang.annotation.RetentionPolicy of RUNTIME）的注解才能在运行时拿到。</p><h4 id="获取Class的成员"><a href="#获取Class的成员" class="headerlink" title="获取Class的成员"></a>获取Class的成员</h4><p>Class里提供了2类方法来访问字段、方法、构造函数：枚举所有成员的方法及查找某个指定成员的方法。还有不同的方法来访问类本身直接声明的成员及查找实现的接口或实现类继承下来的成员。</p><p>定义字段的Class方法  </p><table><thead><tr><th>API</th><th>是否枚举成员</th><th>是否包括继承的成员</th><th>是否返回私有成员</th></tr></thead><tbody><tr><td>getDeclaredField()</td><td>no</td><td>no</td><td>yes</td></tr><tr><td>getField()</td><td>no</td><td>yes</td><td>no</td></tr><tr><td>getDeclaredFields()</td><td>yes</td><td>no</td><td>yes</td></tr><tr><td>getFields()</td><td>yes</td><td>yes</td><td>no</td></tr></tbody></table><p>定位方法的Class方法</p><table><thead><tr><th>API</th><th>是否枚举成员</th><th>是否包括继承的成员</th><th>是否返回私有成员</th></tr></thead><tbody><tr><td>getDeclaredMethod()</td><td>no</td><td>no</td><td>yes</td></tr><tr><td>getMethod()</td><td>no</td><td>yes</td><td>no</td></tr><tr><td>getDeclaredMethods()</td><td>yes</td><td>no</td><td>yes</td></tr><tr><td>getMethods()</td><td>yes</td><td>yes</td><td>no</td></tr></tbody></table><p>定位构造函数的方法</p><table><thead><tr><th>API</th><th>是否枚举成员</th><th>是否包括继承的成员</th><th>是否返回私有成员</th></tr></thead><tbody><tr><td>getDeclaredConstructor()</td><td>no</td><td>N/A1</td><td>yes</td></tr><tr><td>getConstructor()</td><td>no</td><td>N/A1</td><td>no</td></tr><tr><td>getDeclaredConstructors()</td><td>yes</td><td>N/A1</td><td>yes</td></tr><tr><td>getConstructors()</td><td>yes</td><td>N/A1</td><td>no</td></tr></tbody></table><p>构造函数不能被继承<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Member;</span><br><span class="line">import static java.lang.System.out;</span><br><span class="line"></span><br><span class="line">enum ClassMember &#123; CONSTRUCTOR, FIELD, METHOD, CLASS, ALL &#125;</span><br><span class="line"></span><br><span class="line">public class ClassSpy &#123;</span><br><span class="line">    public static void main(String... args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Class&lt;?&gt; c = Class.forName(args[0]);</span><br><span class="line">        out.format(&quot;Class:%n  %s%n%n&quot;, c.getCanonicalName());</span><br><span class="line"></span><br><span class="line">        Package p = c.getPackage();</span><br><span class="line">        out.format(&quot;Package:%n  %s%n%n&quot;,</span><br><span class="line">           (p != null ? p.getName() : &quot;-- No Package --&quot;));</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; args.length; i++) &#123;</span><br><span class="line">        switch (ClassMember.valueOf(args[i])) &#123;</span><br><span class="line">          case CONSTRUCTOR:</span><br><span class="line">              printMembers(c.getConstructors(), &quot;Constructor&quot;);</span><br><span class="line">              break;</span><br><span class="line">          case FIELD:</span><br><span class="line">              printMembers(c.getFields(), &quot;Fields&quot;);</span><br><span class="line">              break;</span><br><span class="line">          case METHOD:</span><br><span class="line">              printMembers(c.getMethods(), &quot;Methods&quot;);</span><br><span class="line">              break;</span><br><span class="line">          case CLASS:</span><br><span class="line">              printClasses(c);</span><br><span class="line">              break;</span><br><span class="line">          case ALL:</span><br><span class="line">              printMembers(c.getConstructors(), &quot;Constuctors&quot;);</span><br><span class="line">              printMembers(c.getFields(), &quot;Fields&quot;);</span><br><span class="line">              printMembers(c.getMethods(), &quot;Methods&quot;);</span><br><span class="line">              printClasses(c);</span><br><span class="line">              break;</span><br><span class="line">          default:</span><br><span class="line">              assert false;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (ClassNotFoundException x) &#123;</span><br><span class="line">        x.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void printMembers(Member[] mbrs, String s) &#123;</span><br><span class="line">    out.format(&quot;%s:%n&quot;, s);</span><br><span class="line">    for (Member mbr : mbrs) &#123;</span><br><span class="line">        if (mbr instanceof Field)</span><br><span class="line">        out.format(&quot;  %s%n&quot;, ((Field)mbr).toGenericString());</span><br><span class="line">        else if (mbr instanceof Constructor)</span><br><span class="line">        out.format(&quot;  %s%n&quot;, ((Constructor)mbr).toGenericString());// 返回泛型化String</span><br><span class="line">        else if (mbr instanceof Method)</span><br><span class="line">        out.format(&quot;  %s%n&quot;, ((Method)mbr).toGenericString());</span><br><span class="line">     &#125;</span><br><span class="line">    if (mbrs.length == 0)</span><br><span class="line">        out.format(&quot;  -- No %s --%n&quot;, s);</span><br><span class="line">    out.format(&quot;%n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void printClasses(Class&lt;?&gt; c) &#123;</span><br><span class="line">    out.format(&quot;Classes:%n&quot;);</span><br><span class="line">    Class&lt;?&gt;[] clss = c.getClasses();</span><br><span class="line">    for (Class&lt;?&gt; cls : clss)</span><br><span class="line">        out.format(&quot;  %s%n&quot;, cls.getCanonicalName());</span><br><span class="line">    if (clss.length == 0)</span><br><span class="line">        out.format(&quot;  -- No member interfaces, classes, or enums --%n&quot;);</span><br><span class="line">    out.format(&quot;%n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以下是几个示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">$ java ClassSpy java.lang.ClassCastException CONSTRUCTOR</span><br><span class="line">Class:</span><br><span class="line">  java.lang.ClassCastException</span><br><span class="line"></span><br><span class="line">Package:</span><br><span class="line">  java.lang</span><br><span class="line"></span><br><span class="line">Constructor:</span><br><span class="line">  public java.lang.ClassCastException()</span><br><span class="line">  public java.lang.ClassCastException(java.lang.String)// 构造函数不能被继承</span><br><span class="line"></span><br><span class="line">$ java ClassSpy java.nio.channels.ReadableByteChannel METHOD</span><br><span class="line">Class:</span><br><span class="line">  java.nio.channels.ReadableByteChannel</span><br><span class="line"></span><br><span class="line">Package:</span><br><span class="line">  java.nio.channels</span><br><span class="line"></span><br><span class="line">Methods:</span><br><span class="line">  public abstract int java.nio.channels.ReadableByteChannel.read</span><br><span class="line">    (java.nio.ByteBuffer) throws java.io.IOException</span><br><span class="line">  // 从实现接口继承的方法</span><br><span class="line">  public abstract void java.nio.channels.Channel.close() throws</span><br><span class="line">    java.io.IOException</span><br><span class="line">  public abstract boolean java.nio.channels.Channel.isOpen()</span><br><span class="line"></span><br><span class="line">$ java ClassSpy ClassMember FIELD METHOD</span><br><span class="line">Class:</span><br><span class="line">  ClassMember</span><br><span class="line"></span><br><span class="line">Package:</span><br><span class="line">  -- No Package --</span><br><span class="line"></span><br><span class="line">Fields:</span><br><span class="line">  // 可以根据 java.lang.reflect.Field.isEnumConstant()来区分枚举字段</span><br><span class="line">  public static final ClassMember ClassMember.CONSTRUCTOR</span><br><span class="line">  public static final ClassMember ClassMember.FIELD</span><br><span class="line">  public static final ClassMember ClassMember.METHOD</span><br><span class="line">  public static final ClassMember ClassMember.CLASS</span><br><span class="line">  public static final ClassMember ClassMember.ALL</span><br><span class="line"></span><br><span class="line">Methods:</span><br><span class="line">  // 方法名都带有类名，这样可以区分如toString()方法是Enum类的，而不是继承自Object的</span><br><span class="line">  public static ClassMember ClassMember.valueOf(java.lang.String)</span><br><span class="line">  public static ClassMember[] ClassMember.values()</span><br><span class="line">  public final int java.lang.Enum.hashCode()</span><br><span class="line">  public final int java.lang.Enum.compareTo(E)</span><br><span class="line">  public int java.lang.Enum.compareTo(java.lang.Object)</span><br><span class="line">  public final java.lang.String java.lang.Enum.name()</span><br><span class="line">  public final boolean java.lang.Enum.equals(java.lang.Object)</span><br><span class="line">  public java.lang.String java.lang.Enum.toString()</span><br><span class="line">  public static &lt;T&gt; T java.lang.Enum.valueOf</span><br><span class="line">    (java.lang.Class&lt;T&gt;,java.lang.String)</span><br><span class="line">  public final java.lang.Class&lt;E&gt; java.lang.Enum.getDeclaringClass()</span><br><span class="line">  public final int java.lang.Enum.ordinal()</span><br><span class="line">  public final native java.lang.Class&lt;?&gt; java.lang.Object.getClass()</span><br><span class="line">  public final native void java.lang.Object.wait(long) throws</span><br><span class="line">    java.lang.InterruptedException</span><br><span class="line">  public final void java.lang.Object.wait(long,int) throws</span><br><span class="line">    java.lang.InterruptedException</span><br><span class="line">  public final void java.lang.Object.wait() hrows java.lang.InterruptedException</span><br><span class="line">  public final native void java.lang.Object.notify()</span><br><span class="line">  public final native void java.lang.Object.notifyAll()</span><br><span class="line"></span><br><span class="line">// 获取字段的声明类</span><br><span class="line">if (mbr instanceof Field) &#123;</span><br><span class="line">    Field f = (Field)mbr;</span><br><span class="line">    out.format(&quot;  %s%n&quot;, f.toGenericString());</span><br><span class="line">    out.format(&quot;  -- declared in: %s%n&quot;, f.getDeclaringClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><h5 id="编译警告"><a href="#编译警告" class="headerlink" title="编译警告"></a>编译警告</h5><p>可能发生的警告为：”Note: … uses unchecked or unsafe operations”<br>当调用一个方法时，参数值的类型经过校验，很可能经过转化。如下例getMethod()方法引起常见的未收校验的转换警告：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class ClassWarning &#123;</span><br><span class="line">    void m() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">    Class c = ClassWarning.class;</span><br><span class="line">    Method m = c.getMethod(&quot;m&quot;);  // warning</span><br><span class="line"></span><br><span class="line">        // production code should handle this exception more gracefully</span><br><span class="line">&#125; catch (NoSuchMethodException x) &#123;</span><br><span class="line">        x.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ javac ClassWarning.java</span><br><span class="line">Note: ClassWarning.java uses unchecked or unsafe operations.</span><br><span class="line">Note: Recompile with -Xlint:unchecked for details.</span><br><span class="line"></span><br><span class="line">$ javac -Xlint:unchecked ClassWarning.java</span><br><span class="line">ClassWarning.java:6: warning: [unchecked] unchecked call to getMethod</span><br><span class="line">  (String,Class&lt;?&gt;...) as a member of the raw type Class</span><br><span class="line">Method m = c.getMethod(&quot;m&quot;);  // warning</span><br><span class="line">                      ^</span><br></pre></td></tr></table></figure></p><p>因为c被声明为原始类型（不带有类型参数），但是getMethod()方法是一个参数化类型，所以发生未经转换的警告<br>有2中解决方法，更倾向于修改c的声明，使其带有合适的泛型类型，该例的声明应该为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = warn.getClass();</span><br></pre></td></tr></table></figure></p><p>或者可以使用@SuppressWarnings来抑制警告<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class c = ClassWarning.class;</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">Method m = c.getMethod(&quot;m&quot;);</span><br></pre></td></tr></table></figure></p><p>建议：通常的原则是,警告不应该被忽略， 因为警告可能表明一个bug。参数化声明应该合理使用。如果参数化声明不可能（如和厂商的类库代码交互），则可以使用@SuppressWarnings.</p><h5 id="构造函数不可访问时构造异常"><a href="#构造函数不可访问时构造异常" class="headerlink" title="构造函数不可访问时构造异常"></a>构造函数不可访问时构造异常</h5><p>如果在类的无参构造函数不可访问时，调用Class.newInstance()方法会抛出InstantiationException异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Cls &#123;</span><br><span class="line">    private Cls() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ClassTrouble &#123;</span><br><span class="line">    public static void main(String... args) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">    Class&lt;?&gt; c = Class.forName(&quot;Cls&quot;);</span><br><span class="line">    c.newInstance();  // InstantiationException</span><br><span class="line">&#125; catch (InstantiationException x) &#123;</span><br><span class="line">    x.printStackTrace();</span><br><span class="line">&#125; catch (IllegalAccessException x) &#123;</span><br><span class="line">    x.printStackTrace();</span><br><span class="line">&#125; catch (ClassNotFoundException x) &#123;</span><br><span class="line">    x.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ java ClassTrouble</span><br><span class="line">java.lang.IllegalAccessException: Class ClassTrouble can not access a member of</span><br><span class="line">  class Cls with modifiers &quot;private&quot;</span><br><span class="line">        at sun.reflect.Reflection.ensureMemberAccess(Reflection.java:65)</span><br><span class="line">        at java.lang.Class.newInstance0(Class.java:349)</span><br><span class="line">        at java.lang.Class.newInstance(Class.java:308)</span><br><span class="line">        at ClassTrouble.main(ClassTrouble.java:9)</span><br></pre></td></tr></table></figure></p><p>Class.newInstance()的行为和new关键字很类似，会因为new关键失败的相同原因失败。反射里通用的解决方案是利用java.lang.reflect.AccessibleObject类提供的抑制访问控制校验的功能；然而由于java.lang.Class没继承AccessibleObject，所以不会有效。唯一的方案是使使用Constructor.newInstance()方法的类继承AccessibleObject。<br>建议：通常，更倾向于使用Constructor.newInstance()</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;反射的用途&quot;&gt;&lt;a href=&quot;#反射的用途&quot; class=&quot;headerlink&quot; title=&quot;反射的用途&quot;&gt;&lt;/a&gt;反射的用途&lt;/h3&gt;&lt;p&gt;  反射对于想要在运行时去检查或修改运行在Java虚拟机中的程序的运行时行为的场合，经常用到。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://zhangxiangnan.com/categories/java/"/>
    
    
      <category term="java" scheme="http://zhangxiangnan.com/tags/java/"/>
    
      <category term="reflect" scheme="http://zhangxiangnan.com/tags/reflect/"/>
    
  </entry>
  
  <entry>
    <title>排查CPU使用率始终100%问题</title>
    <link href="http://zhangxiangnan.com/2017/02/24/problems/%E6%8E%92%E6%9F%A5CPU%20load%E8%BF%87%E9%AB%98%E7%9A%84%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    <id>http://zhangxiangnan.com/2017/02/24/problems/排查CPU load过高的线上问题/</id>
    <published>2017-02-24T10:21:08.000Z</published>
    <updated>2019-03-01T10:14:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>排查CPU使用率始终100%的线上问题，现象，排查过程，解决方案。<br><a id="more"></a></p><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>  收到线上机器单个CPU平均load过高的报警，登陆到机器，命令行执行top命令显示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[zhangxia@xxxx ~]$ top</span><br><span class="line"></span><br><span class="line">top - 17:38:39 up 58 days,  6:38,  2 users,  load average: 0.66, 0.20, 0.19</span><br><span class="line">Tasks: 119 total,   2 running, 117 sleeping,   0 stopped,   0 zombie</span><br><span class="line">Cpu0  : 38.3%us, 59.0%sy,  0.0%ni,  0.3%id,  0.0%wa,  0.0%hi,  2.3%si,  0.0%st</span><br><span class="line">Cpu1  : 20.7%us, 47.4%sy,  0.0%ni, 31.6%id,  0.0%wa,  0.0%hi,  0.0%si,  0.3%st</span><br><span class="line">Mem:   1922348k total,  1703128k used,   219220k free,     4300k buffers</span><br><span class="line">Swap:  2096440k total,        0k used,  2096440k free,   235564k cached</span><br><span class="line"></span><br><span class="line">PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                </span><br><span class="line">8288 zhangxia  20   0 2628m  29m  11m S 98.1  1.6   0:25.24 java</span><br></pre></td></tr></table></figure></p><p>  可以发现进程号为8288的进程CPU使用率为98%，接近100%。</p><h3 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h3><h4 id="top找到cpu占用最高的进程号"><a href="#top找到cpu占用最高的进程号" class="headerlink" title="top找到cpu占用最高的进程号"></a>top找到cpu占用最高的进程号</h4><p>  已找到进程号为8288.</p><h4 id="查看已找到的进程中哪个线程CPU使用率最高"><a href="#查看已找到的进程中哪个线程CPU使用率最高" class="headerlink" title="查看已找到的进程中哪个线程CPU使用率最高"></a>查看已找到的进程中哪个线程CPU使用率最高</h4><p>  在top执行的视图里执行shift+H快捷键，提示“Show threads On”，此时展示的PID为线程ID，可以观察到线程id为19234的线程占用CPU最高。或者使用”Top -Hp 进程号“来观察。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">top - 17:47:40 up 58 days,  6:47,  2 users,  load average: 0.71, 0.23, 0.18</span><br><span class="line">Tasks: 526 total,   2 running, 524 sleeping,   0 stopped,   0 zombie</span><br><span class="line">Cpu0  : 25.5%us, 44.4%sy,  0.0%ni,  0.0%id,  0.0%wa,  0.0%hi,  1.9%si, 28.2%st</span><br><span class="line">Cpu1  : 19.9%us, 41.4%sy,  0.0%ni, 37.5%id,  0.0%wa,  0.0%hi,  0.0%si,  1.3%st</span><br><span class="line">Mem:   1922348k total,  1707684k used,   214664k free,     5740k buffers</span><br><span class="line">Swap:  2096440k total,        0k used,  2096440k free,   237624k cached</span><br><span class="line"></span><br><span class="line">PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                </span><br><span class="line">19234 zhangxia  20   0 2628m  29m  11m R 97.3  1.6   0:26.50 java</span><br></pre></td></tr></table></figure></p><h5 id="jstack-进程号导出线程堆栈"><a href="#jstack-进程号导出线程堆栈" class="headerlink" title="jstack+进程号导出线程堆栈"></a>jstack+进程号导出线程堆栈</h5><p>  执行导出某个进程内的所有线程堆栈信息到文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 8288 &gt; stack.8288</span><br></pre></td></tr></table></figure></p><p>  堆栈信息导出到了当前文件夹，为stack.8288。<br>  内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">  2017-02-24 18:12:51</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.45-b02 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;Attach Listener&quot; #9 daemon prio=9 os_prio=0 tid=0x00007f8abc001000 nid=0x4b48 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;Finalizer&quot; #3 daemon prio=8 os_prio=0 tid=0x00007f8b0407e800 nid=0x4b2a in Object.wait() [0x00007f8af12f9000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">- waiting on &lt;0x00000006c6c06e80&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)</span><br><span class="line">- locked &lt;0x00000006c6c06e80&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)</span><br><span class="line">at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)</span><br><span class="line"></span><br><span class="line">&quot;Reference Handler&quot; #2 daemon prio=10 os_prio=0 tid=0x00007f8b0407c000 nid=0x4b29 in Object.wait() [0x00007f8af13fa000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">- waiting on &lt;0x00000006c6c08370&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">at java.lang.Object.wait(Object.java:502)</span><br><span class="line">at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:157)</span><br><span class="line">- locked &lt;0x00000006c6c08370&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line"></span><br><span class="line">&quot;main&quot; #1 prio=5 os_prio=0 tid=0x00007f8b04009800 nid=0x4b22 runnable [0x00007f8b0a8ae000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">at java.io.FileOutputStream.writeBytes(Native Method)</span><br><span class="line">at java.io.FileOutputStream.write(FileOutputStream.java:326)</span><br><span class="line">at java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:82)</span><br><span class="line">at java.io.BufferedOutputStream.flush(BufferedOutputStream.java:140)</span><br><span class="line">- locked &lt;0x00000006c6c17678&gt; (a java.io.BufferedOutputStream)</span><br><span class="line">at java.io.PrintStream.write(PrintStream.java:482)</span><br><span class="line">- locked &lt;0x00000006c6c06f30&gt; (a java.io.PrintStream)</span><br><span class="line">at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:221)</span><br><span class="line">at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:291)</span><br><span class="line">at sun.nio.cs.StreamEncoder.flushBuffer(StreamEncoder.java:104)</span><br><span class="line">- locked &lt;0x00000006c6c06ee8&gt; (a java.io.OutputStreamWriter)</span><br><span class="line">at java.io.OutputStreamWriter.flushBuffer(OutputStreamWriter.java:185)</span><br><span class="line">at java.io.PrintStream.write(PrintStream.java:527)</span><br><span class="line">- eliminated &lt;0x00000006c6c06f30&gt; (a java.io.PrintStream)</span><br><span class="line">at java.io.PrintStream.print(PrintStream.java:669)</span><br><span class="line">at java.io.PrintStream.println(PrintStream.java:806)</span><br><span class="line">- locked &lt;0x00000006c6c06f30&gt; (a java.io.PrintStream)</span><br><span class="line">at CpuLoadHighTest.main(CpuLoadHighTest.java:4)</span><br><span class="line"></span><br><span class="line">  &quot;VM Thread&quot; os_prio=0 tid=0x00007f8b04077000 nid=0x4b28 runnable</span><br><span class="line"></span><br><span class="line">  &quot;GC task thread#0 (ParallelGC)&quot; os_prio=0 tid=0x00007f8b0401e800 nid=0x4b24 runnable</span><br><span class="line"></span><br><span class="line">  &quot;GC task thread#1 (ParallelGC)&quot; os_prio=0 tid=0x00007f8b04020000 nid=0x4b25 runnable</span><br><span class="line"></span><br><span class="line">  &quot;GC task thread#2 (ParallelGC)&quot; os_prio=0 tid=0x00007f8b04022000 nid=0x4b26 runnable</span><br><span class="line"></span><br><span class="line">  &quot;GC task thread#3 (ParallelGC)&quot; os_prio=0 tid=0x00007f8b04023800 nid=0x4b27 runnable</span><br><span class="line"></span><br><span class="line">  &quot;VM Periodic Task Thread&quot; os_prio=0 tid=0x00007f8b040cc800 nid=0x4b30 waiting on condition</span><br><span class="line"></span><br><span class="line">  JNI global references: 9</span><br></pre></td></tr></table></figure></p><h4 id="得到线程号8566的十六进制表示"><a href="#得到线程号8566的十六进制表示" class="headerlink" title="得到线程号8566的十六进制表示"></a>得到线程号8566的十六进制表示</h4><p>  命令行执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf &apos;%x\n&apos; 19234</span><br></pre></td></tr></table></figure></p><p>  得到十六进制表示为4b22</p><h4 id="在堆栈日志中查找线程号十六进制表示为4b22的线程堆栈信息"><a href="#在堆栈日志中查找线程号十六进制表示为4b22的线程堆栈信息" class="headerlink" title="在堆栈日志中查找线程号十六进制表示为4b22的线程堆栈信息"></a>在堆栈日志中查找线程号十六进制表示为4b22的线程堆栈信息</h4><pre><code>在堆栈文件中查找4b22，得到如下线程堆栈信息：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   &quot;main&quot; #1 prio=5 os_prio=0 tid=0x00007f8b04009800 nid=0x4b22 runnable [0x00007f8b0a8ae000]</span><br><span class="line">  java.lang.Thread.State: RUNNABLE</span><br><span class="line">at java.io.FileOutputStream.writeBytes(Native Method)</span><br><span class="line">at java.io.FileOutputStream.write(FileOutputStream.java:326)</span><br><span class="line">at java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:82)</span><br><span class="line">at java.io.BufferedOutputStream.flush(BufferedOutputStream.java:140)</span><br><span class="line">- locked &lt;0x00000006c6c17678&gt; (a java.io.BufferedOutputStream)</span><br><span class="line">at java.io.PrintStream.write(PrintStream.java:482)</span><br><span class="line">- locked &lt;0x00000006c6c06f30&gt; (a java.io.PrintStream)</span><br><span class="line">at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:221)</span><br><span class="line">at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:291)</span><br><span class="line">at sun.nio.cs.StreamEncoder.flushBuffer(StreamEncoder.java:104)</span><br><span class="line">- locked &lt;0x00000006c6c06ee8&gt; (a java.io.OutputStreamWriter)</span><br><span class="line">at java.io.OutputStreamWriter.flushBuffer(OutputStreamWriter.java:185)</span><br><span class="line">at java.io.PrintStream.write(PrintStream.java:527)</span><br><span class="line">- eliminated &lt;0x00000006c6c06f30&gt; (a java.io.PrintStream)</span><br><span class="line">at java.io.PrintStream.print(PrintStream.java:669)</span><br><span class="line">at java.io.PrintStream.println(PrintStream.java:806)</span><br><span class="line">- locked &lt;0x00000006c6c06f30&gt; (a java.io.PrintStream)</span><br><span class="line">at CpuLoadHighTest.main(CpuLoadHighTest.java:4)</span><br></pre></td></tr></table></figure><p>根绝CpuLoadHighTest.main(CpuLoadHighTest.java:4)可得到问题出现的具体位置，然后分析是否死循环死锁等问题即可解决。   </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排查CPU使用率始终100%的线上问题，现象，排查过程，解决方案。&lt;br&gt;
    
    </summary>
    
      <category term="problems" scheme="http://zhangxiangnan.com/categories/problems/"/>
    
    
      <category term="problems" scheme="http://zhangxiangnan.com/tags/problems/"/>
    
  </entry>
  
  <entry>
    <title>kafka的设计原理解析</title>
    <link href="http://zhangxiangnan.com/2017/02/16/kafka/kafka%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://zhangxiangnan.com/2017/02/16/kafka/kafka的设计原理解析/</id>
    <published>2017-02-16T08:03:01.000Z</published>
    <updated>2019-03-01T16:53:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>kafka的设计原理解析，其设计目标，及其为了这个目标作出的设计方案<br><a id="more"></a></p><h3 id="kafka的设计目标"><a href="#kafka的设计目标" class="headerlink" title="kafka的设计目标"></a>kafka的设计目标</h3><p>Kafka 的定位是作为一个统一的处理实时数据流的平台，其必须能够处理一个「大公司」每天可能产生的消息量级。因此，在设计之初 Kafka 就考虑要满足多样的应用场景：</p><ul><li>高吞吐量：必须具有高吞吐量以便支持大容量事件流，如实时日志聚合服务</li><li>加载离线数据：必须能够支持优雅地处理大数据量的backlog积压，以便能够支持来自离线系统的定期数据加载</li><li>低延迟：必须能够处理低延迟的消息传递应用以便支持更多的传统的消息系统的使用场景</li><li>最好能够支持对订阅源的分区、分布式、及实时处理，并产生新的派生订阅源，这促使产生了kafka的分区和消费者模型</li><li>高可用性：在流数据被馈送到其他数据系统用于服务的场景中，需要在机器故障时支持容错</li></ul><p>为了支持上述的场景，设计了一些独特的元素，类似于数据库日志，而非传统的消息系统。</p><h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><h4 id="文件系统性能并不差"><a href="#文件系统性能并不差" class="headerlink" title="文件系统性能并不差"></a>文件系统性能并不差</h4><p>kafka在存储和缓存消息上很大程度上依赖了文件系统。有个普遍的观念认为硬盘很慢，这让人觉着基于硬盘的持久性结构设计是不是能提供高性能。实际上恰当设计的硬盘结构通常可以和网络一样快。<br>影响硬盘性能的关键事实是随着过去十年的磁盘寻道耗费的延迟的大幅缩小，硬盘驱动器的吞吐量大幅提升，在具有六个7200rpm SATA RAID-5阵列的JBOD配置上线性写入的性能约为600MB/s，但随机写入性能仅为100k/s，相差超过6000倍。这些现行读取和写入是左右使用模式中最可预测的，操作系统也对此进行了大量优化。现代操作系统提供预读和后写技术，以大块多次预取数据并将较小的逻辑写入分组为大型物理写入。有些情况下的硬盘顺序访问可能比内存的随机访问更快。</p><p><img src="http://deliveryimages.acm.org/10.1145/1570000/1563874/jacobs3.jpg" alt="jacobs3"></p><h4 id="常量级别时间"><a href="#常量级别时间" class="headerlink" title="常量级别时间"></a>常量级别时间</h4><p>消息系统中使用的持久化数据结构通常是跟BTree或者其他通用用途的随机访问数据结构每个消费者一个队列来维护消息的元数据信息。Btrees是可用的最通用的数据结构，并且使得可以在消息队列中支持各种各样的事务和非事务的语义。同时也带来了相当高的成本，Btree操作时间复杂度为O(log N)。通常O(log N)被认为基本上等同于恒定时间，但是这不适用于磁盘操作。磁盘一次寻道需要10ms，并且一次只能寻一个，因此并行化受限。因此即使少量的磁盘也导致很高的开销。</p><p>Kafka 采用 log append 的方式写磁盘，可以为消息的读写操作提供 O(1)的复杂度，并且读写互相不会 block 其他操作。由于读写操作的复杂度和数据量无关，使得 Kafka 可以运行在普通机器组成的集群中，每台 server 所能存储的消息量也非常大。<br>这同时带来了另外一些便利，与其他消息系统在消息被消费后即删除的方式不同，kafka 可以将消息保存较长的一段时间，为 Consumer 带来很大的灵活性。</p><h3 id="IO优化提升效率"><a href="#IO优化提升效率" class="headerlink" title="IO优化提升效率"></a>IO优化提升效率</h3><p>我们已经付出了很大努力来提高效率。 我们的主要用例之一是处理网络活动数据，这是非常高的量：每个页面视图可能会生成几十个写入。 此外，我们假设每个发布的消息由至少一个消费者（通常很多）阅读，因此我们努力使消费尽可能廉价。</p><p>从以往构建和运行类似多个系统的经验看来，我们发现，对于有效地多租户操作效率是关键。如果下游基础设施服务在应用程序使用中由于小的突变很容易成为瓶颈，那么这样的变化总会产生问题。如果性能很快，便有助于确保应用程序不会由于基础设施的小问题而产生故障。这对于在中央集群上运行支持几十或上百的应用程序的集中式服务时特别重要，因为使用方式的变化几乎每天都发生。</p><p>上述讨论消除了不良的磁盘访问模式，对于这类系统仍有两个常见的效率低下的原因：太多的小I/O操作，太多的字节复制操作。<br>小的I/O问题在客户端和服务端以及服务端自身的持久化操作都有发生。<br>为了避免这个问题，Kafka使用的协议构建于一种自然地将消息分组到一起的“消息集”的抽象。这允许网络请求将消息分组到一起，而不是一次发送一条消息，缓冲了网络往返的开销。服务器则一次性将消息块追加到log文件中，客户端也一次性抓取大的连续消息块。</p><p>这个简单的优化产生数量级的速度。 批处理导致更大的网络包，更大的顺序磁盘操作，连续的内存块等等，所有这些都允许Kafka将随机消息写入的突发流转换为流向消费者的线性写入</p><p>另一个效率低下的地方是字节复制。消息比较少时不是问题，但是一旦负载升高，影响就很大。为了避免这个问题，Kafka采取生产者、代理broker服务器、消费者共享的标准二进制格式（这样数据块无需更改便可在三者间传递）。<br>代理服务器维护的消息日志本身就是一个文件组成的目录，每个文件由生产者和消费者共同使用的格式已经写入到磁盘的一系列消息集组成。维护这种通用格式有助于优化最重要的操作：持久日志块的网络传输。现代Unix操作系统提供了高度优化的代码用来将数据从页高速缓冲存储器传输到socket；Linux里则通过sendfile系统调用完成。</p><p>为了理解sendfile的影响，有必要理解数据从文件传递到socket几个常见步骤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 操作系统将数据从磁盘读入到内核空间的页高速缓存存储器</span><br><span class="line">- 应用程序将数据从内核空间读入到用户空间缓存区</span><br><span class="line">- 应用程序将数据写会到内核空间中的sokcet缓冲区</span><br><span class="line">- 操作系统从socket缓冲区复制数据到NIC缓冲区，并通过网络发送</span><br></pre></td></tr></table></figure></p><p>  <img src="https://www.ibm.com/developerworks/linux/library/j-zerocopy/figure1.gif" alt="copy"><br>  DMA copy:direct memory copy；直接内存访问</p><p>很显然，这种方式效率低下，有四次复制操作，两次系统调用。使用sendfile后，通过允许操作系统直接发送页缓存的数据到网络而避免重复拷贝的操作，仅仅只需要最后拷贝到NIC缓冲区的操作。</p><p>对于一个主题多个消费者的常见使用情形，使用上述的零拷贝优化，数据只有一次被拷贝到页缓存，每次消费都重复使用，而不是加载到内存里当每次读取的时候被复制到内核空间。这使得消息被消费的速率取决于网络连接的限制。<br>页缓存和sendfile的结合意味着消费者大多出现的集群上，你可能观察不到任何磁盘活动，因为都是从缓存提供数据。</p><p>更多Java对零拷贝的支持和sendfile的背景，看<a href="http://www.ibm.com/developerworks/linux/library/j-zerocopy" target="_blank" rel="noopener">http://www.ibm.com/developerworks/linux/library/j-zerocopy</a></p><h3 id="端到端的批量消息压缩End-to-end-Batch-Compression"><a href="#端到端的批量消息压缩End-to-end-Batch-Compression" class="headerlink" title="端到端的批量消息压缩End-to-end Batch Compression"></a>端到端的批量消息压缩End-to-end Batch Compression</h3><p>I在其他场景下，CPU、硬盘其实不是瓶颈，而是网络带宽。很常见的就是需要通过广域网在各个数据中心之间发送消息的数据流水线。当然，用户也总是可以一次压缩信息，而不需要Kafka的帮助，但这样的压缩比通常很低，因为大多数的冗余来自于相同类型的消息间的重复而不是单条消息本身(如，JSON中的字段名称，web日志中的用户代理，公共的字符串值. 高效的压缩需要一次压缩多条消息而不是每次只压缩一条消息。</p><p>Kafka允许通过遍历消息集来实现消息批量压缩。多条信息可以放到一起压缩，然后发送压缩后的内容到服务器。这些消息也会按着压缩的格式来写入，并在日志文件中保持压缩格式，并且只会由消费者解压缩。Kafka支持GZIP、Snappy、LZ4压缩协议，更多压缩细节见<a href="https://cwiki.apache.org/confluence/display/KAFKA/Compression" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/KAFKA/Compression</a></p><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>生产者直接发送数据到某分区的leader消息代理服务器，而不经过任何中间路由层。为了协助生产者实现这个功能，Kafka各个节点都能随时应答对于那些服务器存活、对于某个主题的所有分区leaders服务器地址的请求，协助生产者发送请求到恰当的服务器。</p><p>客户端控制着发布消息到哪一个分区，这可以通过随机、实现某种负载均衡的随机、某些语义层面的分区函数来实现。Kafka提供了语法上的分区接口，通过允许用户指定一个关键字分区，然后使用该接口hash到一个分区（如果有必要也可以选择重写分区函数）。例如，如果选择用户id作为关键字，这样对于指定用户的所有消息都被发送到相同分区中。 这反过来将允许消费者对他们的消费进行局部性假设。 这种分区风格被明确地设计为允许消费者进行对局部敏感的处理。</p><h4 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h4><p>批处理是效率的主要驱动因素之一，为了启用批处理，Kafka生产者将尝试在内存中累积数据，并在单个请求中发送更大的批次。 批处理可以配置为累积不超过固定数量的消息，并且等待不超过一定的固定等待时间（例如64k或10ms）。 这允许累积更多的字节发送，并且在服务器上几乎没有更大的I / O操作。 这种缓冲是可配置的，并且提供了一种机制来折衷少量的额外延迟以获得更好的吞吐量。</p><p>生产者配置见：<a href="https://kafka.apache.org/documentation/#producerconfigs" target="_blank" rel="noopener">https://kafka.apache.org/documentation/#producerconfigs</a><br>api细节：<a href="http://kafka.apache.org/082/javadoc/index.html?org/apache/kafka/clients/producer/KafkaProducer.html" target="_blank" rel="noopener">http://kafka.apache.org/082/javadoc/index.html?org/apache/kafka/clients/producer/KafkaProducer.html</a></p><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>Kafka通过向Kafka服务器发送提取请求，来获取它想要消费的消息所在分区的leader地址。消费者在每次请求中指定日志中消息的偏移量，然后获取到一个从那个位置开始的日志块。这样消费者拥有对消费消息位置的控制权，如果有需要还能够重设其值来重复消费数据。</p><h4 id="推或者拉"><a href="#推或者拉" class="headerlink" title="推或者拉"></a>推或者拉</h4><p>kafka考虑的一个问题：是否消费者应该从服务器拉取数据还是服务器应该推送数据到消费者。在这个角度，Kafka遵循了一个更加传统的设计，也是大多数消息系统使用的 ，生产者发送数据到服务器，消费者从服务器拉取数据。一些集中式日志系统，如Scribe、Apache Flume，遵循的是一种非常不同的基于推的数据推送到下游的思路。两种设计各有利弊，基于推的系统不好应对多样化的消费者，因为服务器控制数据传输的速率。而通常的目标则是让消费者以自己最大的消费速率来消费数据；不幸的是，在推送的系统中，当消费速率跟不上生产速率时，消费者往往被压制（类似于消费者被攻击）。一个基于拉的系统有更好的性能，消费者只是简单的落后于生产者，在可能的时候赶上.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;kafka的设计原理解析，其设计目标，及其为了这个目标作出的设计方案&lt;br&gt;
    
    </summary>
    
      <category term="kafka" scheme="http://zhangxiangnan.com/categories/kafka/"/>
    
    
      <category term="kafka" scheme="http://zhangxiangnan.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>kafka的适用场合</title>
    <link href="http://zhangxiangnan.com/2017/02/14/kafka/kafka%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E5%90%88/"/>
    <id>http://zhangxiangnan.com/2017/02/14/kafka/kafka的适用场合/</id>
    <published>2017-02-14T08:06:02.000Z</published>
    <updated>2019-02-27T05:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>kafka的适用场合<br><a id="more"></a></p><h3 id="Kafka的常见应用场合"><a href="#Kafka的常见应用场合" class="headerlink" title="Kafka的常见应用场合"></a>Kafka的常见应用场合</h3><h4 id="消息系统"><a href="#消息系统" class="headerlink" title="消息系统"></a>消息系统</h4><p>  Kafka完全可以替换传统消息服务器。使用消息系统有很多原因，解耦消息生产者和处理过程，缓存未处理的消息等。对比大多数消息系统，Kafka有更高的吞吐量，而且基于分片构建，有副本机制，有容错机制，对于构建大规模可扩展的消息处理程序是不错的选择。<br>  在我们的经验中，消息的使用往往相对低延迟，但需要很低的终端到终端的延迟，且经常依赖于Kafka提供强大的持久性保证。</p><p>  在消息系统领域，Kafka相较于传统消息系统如ActiveMq、RabbitMQ。</p><h4 id="网站活动追踪"><a href="#网站活动追踪" class="headerlink" title="网站活动追踪"></a>网站活动追踪</h4><p>  Kafka一开始是用来构建用户行为追踪流水线作为一系列实时的发布订阅模型的订阅源。这就是说网站活动（页面浏览、搜索、其他用户产生的行为动作）按着一个活动类型一个主题被发布到中央主题。这些订阅源可以用来消费用于一系列用途如实时处理、实时监控、加载数据到Hadoop或线下数据仓库系统以便于线下处理和报表。<br>  活动行为追踪常常数据量非常大，因为每一次用户浏览页面都产生许多活动信息。</p><h4 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h4><p>  Kafka经常用来分析运行时的监控数据。这涉及聚合来自分布式应用程序的统计数据来产生运行数据的几种馈送。</p><h4 id="日志聚合Log-Aggregation"><a href="#日志聚合Log-Aggregation" class="headerlink" title="日志聚合Log Aggregation"></a>日志聚合Log Aggregation</h4><p>  很多人使用Kafka进行日志聚合的方案。日志聚合通常从服务器收集物理日志文件，并将其集中起来（文件服务器或者可能HDFS）处理。Kafka抽象了文件的细节，并将日志或事件数据更清晰地抽象为消息流。这允许更低延迟地处理，更容易支持多数据源和分布式数据消费。相比于以日志为中心的系统如Scribe或者Flume，Kafka提供了同样出色的性能，更强的持久性保证及更低的端到端延迟。</p><h4 id="流处理Stream-Processing"><a href="#流处理Stream-Processing" class="headerlink" title="流处理Stream Processing"></a>流处理Stream Processing</h4><p>  很多Kafka用户在由多个阶段组成的处理流水线中处理数据，其中原始数据从Kafka主体消费，接着聚合，丰富，或转换到新主题以便于进一步消费或后续处理。如，一个推荐新闻文章的流水线可能先从RSS订阅源抓取文章内容，将其发布到名为“articles”的主题；进一步处理可能是规范化或者对内容去重，然后发布到清理后的内容到一个新主题；最后的处理阶段可能是尝试推荐内容给用户。这样的处理流水线就是基于不同的主题进行实时数据流的处理。从Kafka的0.10.0.0版本处理，一个轻量级但强大的流处理库为Kafka Streams可用来执行上述的数据处理。除了Kafka Streams，也可选择其他开源流处理工具如Apache Storm和Apache Samza。</p><h4 id="事件源Event-Sourcing"><a href="#事件源Event-Sourcing" class="headerlink" title="事件源Event Sourcing"></a>事件源Event Sourcing</h4><p>  事件源是一种应用程序设计风格，其中状态变化记录为按时间排序的记录序列。Kafka支持非常大的存储日志数据，是构建于这种风格的应用程序极好的后端。</p><h4 id="提交日志Commit-Log"><a href="#提交日志Commit-Log" class="headerlink" title="提交日志Commit Log"></a>提交日志Commit Log</h4><p>  Kafka可以作为分布式系统的一种外部提交日志。该日志有助于各节点间备份数据，以及故障节点重新恢复数据时充当重新同步机制。Kafka的日志压缩特性有助于支持该用途。在这点上，Kafka类似于Apache的Zookeeper项目的作用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;kafka的适用场合&lt;br&gt;
    
    </summary>
    
      <category term="译" scheme="http://zhangxiangnan.com/categories/%E8%AF%91/"/>
    
      <category term="kafka" scheme="http://zhangxiangnan.com/categories/%E8%AF%91/kafka/"/>
    
    
      <category term="kafka" scheme="http://zhangxiangnan.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>求2个单链表的交点</title>
    <link href="http://zhangxiangnan.com/2017/01/22/leetcode/%E6%B1%822%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BA%A4%E7%82%B9/"/>
    <id>http://zhangxiangnan.com/2017/01/22/leetcode/求2个单链表的交点/</id>
    <published>2017-01-22T07:21:01.000Z</published>
    <updated>2019-03-01T16:55:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>求2个单链表的交点（思考过程及源码）<br><a id="more"></a></p><h3 id="求2个单链表的交点"><a href="#求2个单链表的交点" class="headerlink" title="求2个单链表的交点"></a>求2个单链表的交点</h3><p>160.Intersection of Two Linked Lists   </p><p><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/?tab=Description" target="_blank" rel="noopener">https://leetcode.com/problems/intersection-of-two-linked-lists/?tab=Description</a></p><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p><p>For example, the following two linked lists:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                   ↘</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗            </span><br><span class="line">B:     b1 → b2 → b3</span><br></pre></td></tr></table></figure></p><p>begin to intersect at node c1.</p><p>Notes:</p><ul><li>If the two linked lists have no intersection at all, return null.</li><li>The linked lists must retain their original structure after the function returns.</li><li>You may assume there are no cycles anywhere in the entire linked structure.</li><li>Your code should preferably run in O(n) time and use only O(1) memory.</li></ul><h4 id="理解题意"><a href="#理解题意" class="headerlink" title="理解题意"></a>理解题意</h4><p>  写一个程序来找到两个单链表相交开始的结点。<br>  例如，如下两个链表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                   ↘</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗            </span><br><span class="line">B:     b1 → b2 → b3</span><br></pre></td></tr></table></figure></p><p>  A、B两个链表相交在c1结点。   </p><p>  注意：</p><ul><li>如果两个链表没有交点，直接返回null</li><li>原有链表必须保持原始结构，即函数无副作用</li><li>可假设整个链表结构中没有环</li><li>代码的时间和空间复杂度应该为：O(n)，O(1)</li></ul><h4 id="实现思路一"><a href="#实现思路一" class="headerlink" title="实现思路一"></a>实现思路一</h4><p>  1、首先考虑特殊情况，A为null、或B为null，或者两者都为null，则应该返回null<br>  2、一般情况下，连个链表都不为空，假设相交于c1点，借用下图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                   ↘</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗            </span><br><span class="line">B:     b1 → b2 → b3</span><br></pre></td></tr></table></figure></p><ul><li>梳理已知变量，我们只知道两个链表头结点a1、b1，不知道链表长度，对于链表的操作一般操作只有按顺序遍历，反转等；另外我们可以控制遍历时的速度，一次遍历一个结点还是2个结点，但我们对于A、B两个链表不清楚长度有倍数关系，所以两个链表都单步遍历，一次遍历一个结点（即两者速度一样，则相同时间里行驶的距离一样，即经过的结点数一样）。    </li><li>那我们就遍历，假设A、B的长度相等，因为2个链表已假设肯定相交，也即交点之前的两个链表的长度相等，两个链表同时进行遍历时判断遍历的节点是否相等就可以找到交点</li><li>那对于A、B交点之前的长度不相等的情况即A、B两个链表长度不相等的情况呢？没有思路，先假设c1之前A链表的长度为a,c1之前B链表的长度为b，两者相交后共同的部分长度为c，那么还是让两个指针pa、pb从A、B的头结点均单步遍历，看看会发生什么。pa遍历到末尾c3的时候，pb遍历到不知哪个结点，只知道pb走了pa+c距离，即pa走的长度，还有pb+c-(pa+c)=pb-pa的长度就走到末尾，此时两者行驶的距离一样。</li><li>但是我们想要的是pa、pb同时能相聚于c1点，现在pa已经到达c3点，pb还有pb-pa个点要走，想着此时pa等着pb，一直等到pb达到末尾，但貌似没啥用，又要重新开始吗难道？那就不让pa等，两个都接着走，这样pb到终点时，pa又走了pb-pa的距离（假设走的虚拟节点）。</li><li><p>此时pb到达终点c3，pa到终点c3后又多走了pb-pa距离，此时观察下子，发现pb-(pb-pa)=pa，即要是pa到终点后，从b1开始走，走了pb-pa距离，此时pb到终点，而此时pa在B链表上还差pa的距离即达到c1，pb刚好位于终点也是差了pa距离。这时，两个继续走，就能相交于c1.</p><p>以上思路是相交的，针对不相交的，同样逻辑判断，若最后没找到那个点即不想交。</p></li></ul><h4 id="实现思路二虚线延长法"><a href="#实现思路二虚线延长法" class="headerlink" title="实现思路二虚线延长法"></a>实现思路二虚线延长法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:          a1 → a2                 a1 → a2</span><br><span class="line">                   ↘              ↗</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗              ↘         </span><br><span class="line">B:     b1 → b2 → b3                b1 → b2 → b3</span><br></pre></td></tr></table></figure><ul><li>单步遍历两个链表（想不到理由会不同速率遍历，因为不知道长度差异，所以就单步试试），速率相同，时间可以自由控制，也就是我们可以决定两个遍历遍历节点数相同还是差异一定倍数。</li><li>那假设时间一样吧，因为也想不到为啥时间弄成不一样。指针pa从从a1出发经过c1到c3后，接着走b1到b3；pb从b1出发，经过c1到c3后，继续走a1到a2.<br>此时，pa、pb是同时到达b3、a2的，因为两者速率一样，时间一样，最后经过节点数肯定一样。</li><li><p>c3之后的两个分支是虚拟的，但是我们知道a1和b1两个头结点，若pa、pb上面不是走的虚拟分支，而是交换头结点后继续走，那么会同时到达b3和a2结点，也会同时到c1点，解决。</p><p>考虑两个链表没有相交，仍按照上述逻辑交换，执行到最后时，pa、pb的next结点都为null。</p></li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">`/**</span><br><span class="line">* Definition for singly-linked list.</span><br><span class="line">* public class ListNode &#123;</span><br><span class="line">*     int val;</span><br><span class="line">*     ListNode next;</span><br><span class="line">*     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line">* &#125;</span><br><span class="line">*/`</span><br><span class="line"></span><br><span class="line">public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">    if (headA == null || headB == null) return null;</span><br><span class="line">    ListNode pa = headA;</span><br><span class="line">    ListNode pb = headB;</span><br><span class="line">    boolean swapa = false;// 记录pa是否交换执行到pb</span><br><span class="line">    boolean swapb = false;// 记录pb是否交换执行到pa</span><br><span class="line">    while (pa != null &amp;&amp; pb != null) &#123;</span><br><span class="line">        if (pa == pb) &#123;</span><br><span class="line">            return pa;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pa = pa.next;</span><br><span class="line">            pb = pb.next;</span><br><span class="line">            if (pa == null &amp;&amp; !swapa) &#123;</span><br><span class="line">                pa = headB;</span><br><span class="line">                swapa = true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (pb == null &amp;&amp; !swapb) &#123;</span><br><span class="line">                pb = headA;</span><br><span class="line">                swapb = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  改进：可以省去标记变量，对于不相交的情况最后两者都会等于null，从而退出循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">        if (headA == null || headB == null) return null;</span><br><span class="line">        ListNode pa = headA;</span><br><span class="line">        ListNode pb = headB;</span><br><span class="line">        while (a != b) &#123;</span><br><span class="line">            a = a != null ? a.next : headB;</span><br><span class="line">            b = b != null ? b.next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;求2个单链表的交点（思考过程及源码）&lt;br&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://zhangxiangnan.com/categories/algorithm/"/>
    
      <category term="leetcode" scheme="http://zhangxiangnan.com/categories/algorithm/leetcode/"/>
    
      <category term="linked list" scheme="http://zhangxiangnan.com/categories/algorithm/leetcode/linked-list/"/>
    
    
      <category term="leetcode" scheme="http://zhangxiangnan.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>求2个数字之和</title>
    <link href="http://zhangxiangnan.com/2017/01/18/leetcode/%E6%B1%822%E4%B8%AA%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"/>
    <id>http://zhangxiangnan.com/2017/01/18/leetcode/求2个数字之和/</id>
    <published>2017-01-18T09:48:01.000Z</published>
    <updated>2019-03-01T16:56:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>求2个由单链表表示的数字之和<br><a id="more"></a></p><h3 id="Add-Two-Numbers-两数之和"><a href="#Add-Two-Numbers-两数之和" class="headerlink" title="Add Two Numbers-两数之和"></a>Add Two Numbers-两数之和</h3><p>链接：<a href="https://leetcode.com/problems/add-two-numbers/" target="_blank" rel="noopener">https://leetcode.com/problems/add-two-numbers/</a><br>原题：<br>You are given two non-empty linked lists representing two non-negative integers.<br>The digits are stored in reverse order and each of their nodes contain a single digit.<br>Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8</p><p>单链表定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">`/**</span><br><span class="line">* Definition for singly-linked list.</span><br><span class="line">* public class ListNode &#123;</span><br><span class="line">*     int val;</span><br><span class="line">*     ListNode next;</span><br><span class="line">*     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line">* &#125;</span><br><span class="line">*/`</span><br></pre></td></tr></table></figure></p><h4 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h4><p>给定2个非空单链表来表示2个非负整数，每个数字的每一位在链表中以倒序存储（即链表头结点表示个位数，以此类推），每一个结点包含一个单独的数字。<br>求出2数之和，并以链表形式返回（倒序存储，即链表头结点表示个位数，依次类推）。<br>示例：<br>输入： (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8</p><h4 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h4><p>1、和一般2数求和稍微不同，无非就是2个数字用链表表示，链表头结点表示个位数，依次类推。<br>2、正常数字求和无非就是2个数的个位数与个数数相加，得到数字大于9，则需要往十位进位（进位的值为个位数的和/10,整除）。<br>和的个位数值则为个数为和 % 10（对10取余），依次类推。使用链表表示的数字求和原理类似。<br>3、考虑几个特殊情况，若一个数字有2位，一个有3位，此时3位数字的百位数字仍然要和0相加，并加上来自十分位的进位值；<br>若2-&gt;9与8-&gt;1相加呢，和为三位数，其百位值为十位进位得到，需要考虑到进位值所产生的新的结点。</p><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p>  1、初始：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  2、题意里说2个非空链表，不用判断链表是否为null；<br>    接着自然想到在求和过程中需要定义一个int变量保存进位值，需要定义一个结点变量表示求和后新链表的头结点ListNode newHead；<br>    在上面分析的过程中，遍历2个链表求和时，需要一个临时变量来保存当前遍历过程中的新结点的值ListNode sumNode:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">    int carry = 0;// 存储进位值，初始化为0</span><br><span class="line">    ListNode newHead= null;//  新链表的头结点值，初始化为null</span><br><span class="line">    while(l1 != null || l2 != null)&#123;// 只要2个链表不同时为null，都需要继续遍历求和</span><br><span class="line">        ListNode sumNode = null;</span><br><span class="line">        int sum = carry;// 和，加上进位值</span><br><span class="line"></span><br><span class="line">        if(l1 != null) &#123;//</span><br><span class="line">         sum += l1.val;// sum加上l链表当前结点的值</span><br><span class="line">         l1 = l1.next;// 修改l1指向下个结点</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(l2 != null) &#123;</span><br><span class="line">         sum += l2.val;</span><br><span class="line">         l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 求进位值和当前位的值</span><br><span class="line">        carry = sum / 10;</span><br><span class="line">        sum = sum %10;</span><br><span class="line"></span><br><span class="line">        // 遍历第一次时，设置新链表头结点的值</span><br><span class="line">        sumNode = new ListNode(sum);</span><br><span class="line">        if(newHead ==null) &#123;</span><br><span class="line">            newHead = sumNode;</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 进位不等于0时</span><br><span class="line">    if(carry!=0) &#123;</span><br><span class="line">      ....</span><br><span class="line">    &#125;</span><br><span class="line">     return newHead;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  3、上述过程将sumNode在while循环里作为临时变量，每次while循环后sumNode重新初始化为null，缺少了将每次循环产生的sumNode<br>  连接起来的步骤，所以需要将sumNode移动到while循环外作为临时变量，这样就能记住上次循环的sumNode值；<br>  另外就是进位产生的新结点不在while循环中，需要单独设置循环最后一次的sumNode的next为carry所生成的node：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">    int carry = 0;// 存储进位值，初始化为0</span><br><span class="line">    ListNode newHead= null;//  新链表的头结点值，初始化为null</span><br><span class="line">    ListNode preNode= null;// 每次while循环时上次循环的和结点的值，第一次循环的上一次的和结点值可以理解为null</span><br><span class="line">    while(l1 != null || l2 != null)&#123;// 只要2个链表不同时为null，都需要继续遍历求和</span><br><span class="line">        int sum = carry;// 和，加上进位值</span><br><span class="line"></span><br><span class="line">        if(l1 != null) &#123;//</span><br><span class="line">         sum += l1.val;// sum加上l链表当前结点的值</span><br><span class="line">         l1 = l1.next;// 修改l1指向下个结点</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(l2 != null) &#123;</span><br><span class="line">         sum += l2.val;</span><br><span class="line">         l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 求进位值和当前位的值</span><br><span class="line">        carry = sum / 10;</span><br><span class="line">        sum = sum %10;</span><br><span class="line"></span><br><span class="line">        // 遍历第一次时，设置新链表头结点的值</span><br><span class="line">        ListNode sumNode = new ListNode(sum);</span><br><span class="line">        if(newHead ==null) &#123;</span><br><span class="line">            newHead = sumNode;</span><br><span class="line">            preNode = sumNode;// 更新preNode的值为新值</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            preNode.next = sumNode;// 将上次结点和本次结点连接起来</span><br><span class="line">            preNode = sumNode;//更新preNode的值为本次和产生的结点值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 进位不等于0时</span><br><span class="line">    if(carry!=0) &#123;</span><br><span class="line">        preNode.next = new ListNode(carry);// 将上次结点值指向进位产生的结点</span><br><span class="line">    &#125;</span><br><span class="line">     return newHead;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h4><p>上个步骤的代码基本可以当做答案，不过可以进一步稍微优化：</p><ul><li>求进位值和当前位值可以添加限制条件，不用每次都执行，因为只有当sum&lt;=9时执行和不执行carry和sum值一样</li><li>可以使用sum变量提取到while外，作为上一步循环的2个结点的值加上上上一次循环的产生的进位值，这样carry变量就可以省略</li><li>while里每次都要判断newHead == null，啰嗦，判断这个条件无非就是newHead初始值为null，那假如这个结点第一次不为null，而是个类似哨兵结点sentinel，<br>这样中间便不用每次判空，直接往后追加，最后直接返回sentinel.next即可。<br>最后结果：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">  public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">    ListNode sentinel= new ListNode(0);// 哨兵结点</span><br><span class="line">    ListNode preNode= sentinel;// preNode默认为哨兵结点</span><br><span class="line">    int sum = 0; //上一步循环的2个结点的值加上上上一次循环的产生的进位值</span><br><span class="line">    while(l1 != null || l2 != null)&#123;</span><br><span class="line">        sum = sum / 10;// 取上次循环sum的进位值</span><br><span class="line"></span><br><span class="line">        if(l1 != null) &#123;</span><br><span class="line">         sum += l1.val;</span><br><span class="line">         l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(l2 != null) &#123;</span><br><span class="line">         sum += l2.val;</span><br><span class="line">         l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        preNode.next = new ListNode(sum%10);;</span><br><span class="line">        preNode = preNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2个结点的进位值最多为1</span><br><span class="line">    if(sum /10 == 1) &#123;</span><br><span class="line">        preNode.next = new ListNode(1);</span><br><span class="line">    &#125;</span><br><span class="line">     return sentinel.next;// 哨兵结点的下一个即为新链表头结点</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>可以通过几个简单case，自行验证：<br>1-&gt;2 2-&gt;3;<br>1-&gt;9 9-&gt;1;<br>1-&gt;9 1;   </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;求2个由单链表表示的数字之和&lt;br&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://zhangxiangnan.com/categories/algorithm/"/>
    
      <category term="leetcode" scheme="http://zhangxiangnan.com/categories/algorithm/leetcode/"/>
    
      <category term="linked list" scheme="http://zhangxiangnan.com/categories/algorithm/leetcode/linked-list/"/>
    
      <category term="math" scheme="http://zhangxiangnan.com/categories/algorithm/leetcode/linked-list/math/"/>
    
    
      <category term="leetcode" scheme="http://zhangxiangnan.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>反转单链表的某部分</title>
    <link href="http://zhangxiangnan.com/2017/01/17/leetcode/%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9F%90%E9%83%A8%E5%88%86-reverse-part-singly-linked-list/"/>
    <id>http://zhangxiangnan.com/2017/01/17/leetcode/反转单链表的某部分-reverse-part-singly-linked-list/</id>
    <published>2017-01-17T09:07:01.000Z</published>
    <updated>2019-02-27T05:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>反转单链表的某部分（思考过程及java源码）<br><a id="more"></a></p><h3 id="反转单链表的某部分"><a href="#反转单链表的某部分" class="headerlink" title="反转单链表的某部分"></a>反转单链表的某部分</h3><p>Reverse Linked List II(reverse part)<br><a href="https://leetcode.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list-ii/</a></p><h4 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h4><pre><code>Reverse a linked list from position m to n. Do it in-place and in one-pass.For example:Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL.Note:Given m, n satisfy the following condition:1 ≤ m ≤ n ≤ length of list.Subscribe to see which companies asked this question`/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */`</code></pre><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>大概就是给我们一个单链表，然后让我们反转单链表的一部分（2个参数表示反转的第m个结点到第n个结点，m、n从1开始），反转单链表是要求反转全部，要求必须是一次遍历完成，且必须使用原地算法（使用变量是固定数量的、小的空间，不能现行增长，本地意思是不能复制链表）<br>原地算法：<a href="https://zh.wikipedia.org/wiki/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95</a></p><h4 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h4><p>不考虑特殊情况，就考虑大众情况，比方说让我反转1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL的结点2到结点4的部分（m=2，n=4），那我很容易想到就是遍历单链表，遍历的时候定义一个变量i，i==m到i==n中间结点就是我要反转的部分结点，这部分结点反转的逻辑就是反转某个单链表；接着就是这部分反转后的部分结点，需要和原链表按顺序连一块，本例就是1和4连，2和5连，那意思是我遍历的时需要记住待反转部分结点的前面一个结点和后一个结点，还需记住待反转部分反转后的首尾结点，然后返回结果是原链表的头结点，所以还需要记住原链表的头结点。<br>接着，我可以遍历一遍找到m、n对应结点，然后再从m遍历到n进行链表反转，这样子遍历不止一次，不符合题目要求，只能在一次遍历的时候同时反转</p><h4 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h4><p>  1、首先我先对head或者head.next == null的情况做下检查，head.next == null情况可能不太好想一开始，先排除：   </p><pre><code>public ListNode reverseBetween(ListNode head, int m, int n) {    if(head == null || head.next == null) return head;    ...}</code></pre><p>  2、接着我按着刚才的思路，定义几个相关变量，并初始化下值：</p><pre><code>public ListNode reverseBetween(ListNode head, int m, int n) {    if(head == null || head.next == null) return head;    int i = 1;// 因为m、n从1开始，所以统一i也从1开始    ListNode oldHead = head;// 原链表的头结点，赋值应该没啥异议    ListNode reversePreNode = null;// 反转部分链表反转前其头结点的前一个结点    ListNode reversedTail = null;// 反转部分链表反转后的尾结点，一开始不知道，为null    ListNode reverseNextNode = null;// 反转部分链表反转前尾结点的下一个结点    ListNode reversedNewHead = null;// 反转部分链表反转后的头结点，一开始不知道，为null    ...}</code></pre><p>  3、开始遍历，遍历时，我可以用while、for都行，此处用while，所以上步定义了变量i表示迭代的次数，遍历得有结束遍历的条件吧，毕竟只反转一部分，不需要遍历所有结点，所以我需要加个结束条件if(i&gt;n)break;接着就是寻找第2步中定义的几个变量的值：</p><ul><li>reversePreNode的含义是反转部分反转前头结点的前一个结点，反转部分反转前头结点其索引顺序为m，m的前一个结点索引为m－1，所以遍历时，若i=m-1，则该结点就是reversePreNode的值（反转部分反转前头结点的前一个结点）；</li><li><p>reversedTail含义为反转部门链表反转后的尾结点，那就是找反转前的头结点，头结点索引顺序为m，则若i＝＝m，则当前结点就是reversedTail的值<br>因为要在一次循环里搞定，所以朦胧感觉可能需要在while里有一段代码做反转操作：      </p><pre><code>public ListNode reverseBetween(ListNode head, int m, int n) {   if (head == null) return null;   if (head.next == null) return head;   int i = 1;   ListNode reversedNewHead = null;// 反转部分链表反转后的头结点   ListNode reversedTail = null;// 反转部分链表反转后的尾结点   ListNode oldHead = head;// 原链表的头结点   ListNode reversePreNode = null;// 反转部分链表反转前其头结点的前一个结点   ListNode reverseNextNode = null;   while (head != null) {       if (i &gt; n) {           break;       }       if (i == m - 1) {           reversePreNode = head;       }       if (i == m) {           reversedTail = head;       }       // 反转结点逻辑...       i++;// 更新i，没啥异议吧   }   return xx;// 暂定，未知}</code></pre></li></ul><p>4、接着就是反转结点部分的逻辑:</p><ul><li>首先反转结点逻辑可参考反转单链表的几句关键逻辑（临时变量next保存当前结点的next结点，修改当前结点的next指向已️反转部分链表头结点，然后更新已反转链表头结点指向，更新待反转链表的头结点指向)，几个变量对应到步骤2定义的变量即可</li><li>反转的结点是在m和n之间，所以反转逻辑应该在if(i&gt;=m &amp;&amp; i&lt;=n) 条件内执行</li><li>遍历时需要修改head指向为下一个结点，所以要在各个if else分支里都要执行head＝head.next</li></ul><pre><code>public ListNode reverseBetween(ListNode head, int m, int n) {   if (head == null) return null;   if (head.next == null) return head;   int i = 1;   ListNode reversedNewHead = null;// 反转部分链表反转后的头结点   ListNode reversedTail = null;// 反转部分链表反转后的尾结点   ListNode oldHead = head;// 原链表的头结点   ListNode reversePreNode = null;// 反转部分链表反转前其头结点的前一个结点   ListNode reverseNextNode = null;   while (head != null) {       if (i &gt; n) {           break;       }       if (i == m - 1) {           reversePreNode = head;       }       if (i &gt;= m &amp;&amp; i &lt;= n) {          if (i == m) {// 这部分移到if条件里              reversedTail = head;          }          reverseNextNode = head.next;// 反转前保存当前结点的next结点，反转结束时该值刚好是reverseNextNode代表的含义          head.next = reversedNewHead;// 修改当前结点（待反转链表部分的头结点）指向已反转链表部分的头结点          reversedNewHead = head;// 更改已反转链表的头结点的指向          head = reverseNextNode;// 更新head指向为待反转链表的头结点        } else {            head = head.next;//  更新head指向为其下一个结点        }       i++;// 更新i，没啥异议吧   }   return xx;// 暂定，未知}</code></pre><p>5、收尾与返回逻辑：</p><ul><li>在循环里执行反转后，紧接着需要在循环外执行更新reversedTail的next指向，根据几个变量含义，让其指向reverseNextNode即可。</li><li><p>返回结果就需要考虑几种情况了，因为需要返回反转后新链表的头结点，但是m有可能&gt;=2，此时reversePreNode肯定不为空，需要将reversePreNode的next指向反转部分新的头结点，然后直接返回oldHead即可；若m==1,则不能这么做，需要返回反转部分链表的新的头结点，即reversedNewHead：</p><pre><code>public ListNode reverseBetween(ListNode head, int m, int n) {    if (head == null) return null;    if (head.next == null) return head;    int i = 1;    ListNode reversedNewHead = null;// 反转部分链表反转后的头结点    ListNode reversedTail = null;// 反转部分链表反转后的尾结点    ListNode oldHead = head;// 原链表的头结点    ListNode reversePreNode = null;// 反转部分链表反转前其头结点的前一个结点    ListNode reverseNextNode = null;    while (head != null) {        if (i &gt; n) {            break;        }        if (i == m - 1) {            reversePreNode = head;        }        if (i &gt;= m &amp;&amp; i &lt;= n) {            if (i == m) {                reversedTail = head;            }            reverseNextNode = head.next;            head.next = reversedNewHead;            reversedNewHead = head;            head = reverseNextNode;        } else {            head = head.next;        }        i++;    }    reversedTail.next = reverseNextNode;    if (reversePreNode != null) {        reversePreNode.next = reversedNewHead;        return oldHead;    } else {        return reversedNewHead;    }}</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;反转单链表的某部分（思考过程及java源码）&lt;br&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://zhangxiangnan.com/categories/algorithm/"/>
    
      <category term="leetcode" scheme="http://zhangxiangnan.com/categories/algorithm/leetcode/"/>
    
      <category term="linked list" scheme="http://zhangxiangnan.com/categories/algorithm/leetcode/linked-list/"/>
    
    
      <category term="leetcode" scheme="http://zhangxiangnan.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>反转单链表</title>
    <link href="http://zhangxiangnan.com/2017/01/12/leetcode/%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8-reverse-singly-linked-list/"/>
    <id>http://zhangxiangnan.com/2017/01/12/leetcode/反转单链表-reverse-singly-linked-list/</id>
    <published>2017-01-12T09:22:08.000Z</published>
    <updated>2019-03-01T17:00:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>反转单链表（思考过程及java源码）<br><a id="more"></a></p><h3 id="反转单链表"><a href="#反转单链表" class="headerlink" title="反转单链表"></a>反转单链表</h3><p>Reverse a singly linked list.<br><a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list/</a></p><h4 id="迭代方式思路"><a href="#迭代方式思路" class="headerlink" title="迭代方式思路"></a>迭代方式思路</h4><p>  已知条件：假定给定一个正常单链表a-&gt;b-&gt;c-&gt;d，ListNode l1 = a;<br>  推导：反转无非是把已知的链表转化为d-&gt;c-&gt;b-&gt;a，即将原链表的结点指向全部反向。那么，开始思考：   </p><p>  1、首先我定义一个变量指向a，表示待反转链表的头结点ListNode oldHead=a，接着第一步很自然想到把a的next指向null，但是一旦我这么改的话，我就没法得到b结点，进而没法修改b的next指向。故我需要在修改a的指向前，提前定义一个额外的变量来临时保存a的next指向，那么我定义ListNode nextNode = oldHead.next，此时nextNode指向b结点，链表还未做任何改动，即a(oldHead)-&gt;b(nextNode)-&gt;c-&gt;d;  </p><p>  2、定义了nextNode变量，那么我修改a的指向便无后顾之忧，所以我执行oldHead.next = null,即使a的next指向null，此时原链表变为了2段，一段是a(oldHead)-&gt;null（称作已反转链表部分），另一段是b(nextNode)-&gt;c-&gt;d（称作未反转链表部分），因为oldHead的含义理解为当前需要反转的结点，因为需要将oldHead指向nextNode(b)，并将nextNode指向nextNode.next(c)，修改oldHead指向的话，需要记住已分割部分的头结点，只能再定义个结点newHead=oldHead，执行顺序为newHead=oldHead，oldHead=nextNode，nextNode=nextNode.next，此时链表的2段为a(newHead)-&gt;null, b(oldHead)-&gt;c(nextNode)-&gt;d-&gt;null。</p><p>  3、此时我接着要把未反转链表部分接着反转，把头结点b的next指向a（即把未反转链表的头结点指向已反转链表的头结点），此时链表分两段为b（oldHead）-&gt;a（newHead）-&gt;null，c(nextNode)-&gt;d，接着我需要更新几个变量的指向（使其oldHead指向c，newHead就需要指向b，nextNode指向d，2段链表分别为b(newHead)-&gt;a-&gt;null,c(oldHead)-&gt;d(nextNode)-&gt;null。</p><p>  4、继续重复过程3，修改c的next使其指向b，那么我得到c（oldHead）—&gt;b（newHead）-&gt;a-&gt;null，d（nextNode）-&gt;null，更新几个变量指向后，2段链表为c(newHead)-&gt;b-&gt;a-&gt;null，d(oldHead)-null(nextNode)</p><p>  5、再重复过程3，修改d的next=newHead,2段链表分别为d(oldHead)-&gt;c(newHead)-&gt;b-&gt;a-null，null(nextNode)，此时已经反转完成，然后迭代结束条件就是nextNode==null</p><p>  6、总的来说，需要newHead、oldHead、nextNode3个变量，在原链表还是一段的时候，我们的oldHead指向a，nextNode=a.next，newHead则等于null,三个变量的表示意思为：oldHead表示待反转链表的头结点，newHead表示已反转链表的头结点（所以一开始初始值为null），nextNode表示带反转链表的头结点的下一个结点（所以初始值为oldHead.next)。</p><h4 id="迭代（循环）实现"><a href="#迭代（循环）实现" class="headerlink" title="迭代（循环）实现"></a>迭代（循环）实现</h4>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">`/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */`</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">       if(head == null) return null;</span><br><span class="line">       ListNode newHead = null;</span><br><span class="line">       ListNode oldHead = head;</span><br><span class="line">       ListNode nextNode = head.next;// nextNode定义为待反转链表头结点的next结点，初始化为head的next结点</span><br><span class="line">       while(nextNode != null)&#123;//  待反转链表头结点的next结点不为null作为条件</span><br><span class="line">          oldHead.next = newHead;</span><br><span class="line">          newHead =oldHead;</span><br><span class="line">          oldHead = nextNode;</span><br><span class="line">          nextNode = nextNode.next;</span><br><span class="line">       &#125;</span><br><span class="line">       oldHead.next = newHead;// 需要手动更改待反转链表的最后一个头结点的指向</span><br><span class="line">       newHead = oldHead;// 该步可以省略，直接返回oldHead，为了更清晰。</span><br><span class="line">       return newHeadNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  为什么while循环要以nextNode！= null作为结束条件？考虑以下实现，只是不同的初始化方式：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">`/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */`</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        if(head == null) return null;</span><br><span class="line">        ListNode newHead = null;// 定义为已反转链表头结点</span><br><span class="line">        ListNode oldHead = head;// 定义为待反转链表头结点</span><br><span class="line">        ListNode next = null;// 定义为待反转链表的头结点的next结点，初始化为null</span><br><span class="line">        while(oldHead != null)&#123;//迭代结束条件是待反转链表的头结点不为null，为null说明反转结束</span><br><span class="line">            next = oldHead.next;// 保存next指向</span><br><span class="line">            oldHead.next = newHead;</span><br><span class="line">            newHead = oldHead;</span><br><span class="line">            oldHead = next;</span><br><span class="line">        &#125;</span><br><span class="line">        return newHead;// newHead结点即为新链表的头结点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="递归方式思路"><a href="#递归方式思路" class="headerlink" title="递归方式思路"></a>递归方式思路</h4><p>前面分析的过程可以概括为一个已反转链表（初始为null）部分，一个未反转链表部分（初始为待反转链表），每次都是从待反转链表拿出头结点，作为已反转链表部分的头结点，不断重复这个过程，直到待反转链表部分只剩下null结点。这个过程和递归很类似，递归就是在函数里调用函数本身，重复调用函数本身说明解决的问题结构很类似，刚才的分析过程中一直存在的结构或变量有2个，一个是已反转链表、一个未反转链表，那递归函数是不是可以这么定义？</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private ListNode reverse(ListNode oldHead, ListNode newHead)</span><br></pre></td></tr></table></figure><p>我在这个函数里要调用函数自身进行递归，所以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private ListNode reverse(ListNode oldHead, ListNode newHead)&#123;</span><br><span class="line">  return reverse(oldHead, newHead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  貌似需要在递归里做些处理，回想我们在每一次的从待反转链表结点里拿出头结点oldHead（拿出前需要先记住oldHead的next结点，否则修改oldHead的next指向后，便找不到原next结点了），将其next指向已反转链表的头结点，这样未反转链表和已反转链表的头结点都发生了变化，我们需要更新oldHead和newHead的指向。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private ListNode reverse(ListNode oldHead, ListNode newHead)&#123;</span><br><span class="line">  ListNode next = oldHead.next;// 记住待反转链表头结点的next结点</span><br><span class="line">  oldHead.next = newHead;// 将oldHead结点从待反转链表结点拿出，使其成为已反转链表结点的头结点</span><br><span class="line">  newHead = oldHead;// 更新newHead结点指向</span><br><span class="line">  oldHead = next;// 更新oldHead结点指向，指向此时待反转链表结点的头结点（为先前保存的next指向的结点）</span><br><span class="line">  return reverse(oldHead, newHead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  貌似递归还缺少递归出口，拿什么作为出口？回想刚才分析过程，最终是以待反转链表的头结点未null，结束，此时已反转链表的头结点就是反转后新链表的头结点。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private ListNode reverse(ListNode oldHead, ListNode newHead)&#123;</span><br><span class="line">  if(oldHead == null) return newHead;</span><br><span class="line">  ListNode next = oldHead.next;// 记住待反转链表头结点的next结点</span><br><span class="line">  oldHead.next = newHead;// 将oldHead结点从待反转链表结点拿出，使其成为已反转链表结点的头结点</span><br><span class="line">  newHead = oldHead;// 更新newHead结点指向</span><br><span class="line">  oldHead = next;// 更新oldHead结点指向，指向此时待反转链表结点的头结点（为先前保存的next指向的结点）</span><br><span class="line">  return reverse(oldHead, newHead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归方式实现"><a href="#递归方式实现" class="headerlink" title="递归方式实现"></a>递归方式实现</h4>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">    if(head == null) return null;</span><br><span class="line">    return reverse(head, null);// 一开始已反转链表为null，因此头结点未null</span><br><span class="line">&#125;</span><br><span class="line">private ListNode reverse(ListNode oldHead, ListNode newHead)&#123;</span><br><span class="line">  if(oldHead == null) return newHead;</span><br><span class="line">  ListNode next = oldHead.next;// 记住待反转链表头结点的next结点</span><br><span class="line">  oldHead.next = newHead;// 将oldHead结点从待反转链表结点拿出，使其成为已反转链表结点的头结点</span><br><span class="line"></span><br><span class="line">  // 以下2个更新可以省略，为了清晰</span><br><span class="line">  newHead = oldHead;// 更新newHead结点指向</span><br><span class="line">  oldHead = next;// 更新oldHead结点指向，指向此时待反转链表结点的头结点（为先前保存的next指向的结点）</span><br><span class="line">  return reverse(oldHead, newHead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;反转单链表（思考过程及java源码）&lt;br&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://zhangxiangnan.com/categories/algorithm/"/>
    
      <category term="leetcode" scheme="http://zhangxiangnan.com/categories/algorithm/leetcode/"/>
    
      <category term="linked list" scheme="http://zhangxiangnan.com/categories/algorithm/leetcode/linked-list/"/>
    
    
      <category term="leetcode" scheme="http://zhangxiangnan.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>kafka的入门知识</title>
    <link href="http://zhangxiangnan.com/2017/01/09/kafka/kafka%E7%9A%84%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86/"/>
    <id>http://zhangxiangnan.com/2017/01/09/kafka/kafka的入门知识/</id>
    <published>2017-01-09T09:17:02.000Z</published>
    <updated>2019-03-01T10:15:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>kafka的入门知识<br><a id="more"></a></p><h3 id="kafka的背景"><a href="#kafka的背景" class="headerlink" title="kafka的背景"></a>kafka的背景</h3><p>Kafka是LinkedIn开发的一个分布式消息系统，使用Scala编写，现成为Apache项目。它以可水平扩展和高吞吐率而被广泛使用。目前越来越多的开源分布式处理系统如Cloudera、Apache Storm、Spark都支持与Kafka集成。现在很多不同类型公司用来作为多种类型的数据管道和消息系统使用。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 日志收集：收集各种服务的log，通过kafka以统一接口方式开放给consumer，例如：Hadoop、Hbase等</span><br><span class="line">- 消息系统：解耦producer和consumer，缓存消息</span><br><span class="line">- 用户活动跟踪：记录用户各种活动，如page view、搜索、点击等，这些消息被发送到topic中，然后consumer做实时的监控分析</span><br><span class="line">- 运营指标：记录运营监控指标，服务器的性能数据，如：CPU,IO,响应时间等</span><br><span class="line">- 事件源</span><br><span class="line">- 实时流处理</span><br><span class="line">- 提交日志，用于备份还原</span><br></pre></td></tr></table></figure><h3 id="kafka的拓扑结构"><a href="#kafka的拓扑结构" class="headerlink" title="kafka的拓扑结构"></a>kafka的拓扑结构</h3><h4 id="拓扑图"><a href="#拓扑图" class="headerlink" title="拓扑图"></a>拓扑图</h4><p><img src="http://cdn.infoqstatic.com/statics_s1_20161108-0613/resource/articles/kafka-analysis-part-1/zh/resources/0310020.png" alt="tuopu"></p><h4 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h4><h5 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h5><p>Kafka集群包含一个或多个服务器，这种服务器被称为broker（代理服务器）。一台kafka服务器就是一个broker，一个集群由多个broker组成，一个broker可以容纳多个topic。</p><h5 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h5><p>每条发布到Kafka集群的消息都有一个类别或者叫做主题，这个类别被称为Topic，Kafka中Topic可以理解为一个存储消息的队列。物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存在一个或多个broker上，但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处。</p><h5 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h5><p>分区，Partition是物理上的概念，Kafka物理上把Topic分成一个或多个Partition，每个Partition在物理上对应一个文件夹，该文件夹下存储这个Partition的所有消息和索引文件。如创建topic1和topic2两个topic，且分别有13个和19个Partition分区，则整个集群上相应会生成32个文件夹。为了实现扩展性，一个非常大的topic可以分布到多个broker上，但kafka只保证按一个partition中的顺序将消息发给consumer，不保证一个topic的整体（多个partition间）的顺序。</p><h5 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h5><p>消息生产者，负责发布消息到Kafka broker</p><h5 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h5><p>消息消费者，向Kafka broker读取消息的客户端。</p><h5 id="Consumer-Group（CG）"><a href="#Consumer-Group（CG）" class="headerlink" title="Consumer Group（CG）"></a>Consumer Group（CG）</h5><p>kafka用来实现一个topic消息的广播（发给所有的consumer）和单播（发给任意一个consumer）的手段。一个topic可以属于多个CG，即多个CG可以无差别地消费一个topic的信息。topic的消息会复制（不是真的复制，是概念上的）到所有的CG，但每个CG只会把消息发给该CG中的一个consumer。如果需要实现广播，只要每个consumer有一个独立的CG就可以了。要实现单播只要所有的consumer在同一个CG。用CG还可以将consumer进行自由的分组而不需要多次发送消息到不同的topic（不懂）。每个consumer属于一个特定的Consumer Group, Kafka允许为每个consumer指定group name，若不指定group name则属于默认的group。</p><h5 id="Offset偏移量"><a href="#Offset偏移量" class="headerlink" title="Offset偏移量"></a>Offset偏移量</h5><p>kafka的存储文件都是按照offset.kafka来命名，用offset做名字的好处是方便查找。例如你想找位于2049的位置，只要找到2048.kafka的文件即可。当然the first offset就是00000000000.kafka   </p><p>一个Kafka集群中会包含若干个Producer（可能是端上的PV数据，或者服务器日志，CPU、Memory监控信息等），若干个Broker（Broker越多，集群的吞吐量越高），若干个Consumer Group，以及一个zookeeper集群。Kafka通过zookeeper管理broker和consumer的动态加入和离开。Producer通过push方式将消息发送到Broker，Consumer通过pull方式从Broker订阅消费消息。</p><h3 id="kafka是一个分布式的流式传输平台"><a href="#kafka是一个分布式的流式传输平台" class="headerlink" title="kafka是一个分布式的流式传输平台"></a>kafka是一个分布式的流式传输平台</h3><p>分布式流平台应该具有的三个特征：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 可以发布和订阅流记录流，这点类似于消息队列或者企业级消息系统</span><br><span class="line">- 可以以容错方式存储记录流</span><br><span class="line">- 可以当产生记录流时进行处理.</span><br></pre></td></tr></table></figure></p><p>kafka的优势<br>kafka用于2大类应用程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 构建可靠地在系统或应用程序之间获取数据的实时流数据流水线</span><br><span class="line">- 构建对数据流进行变换或反应的实时流应用程序</span><br></pre></td></tr></table></figure></p><p>相关概念：<br>Kafka作为集群运行在一个或者多个机器上<br>Kafka集群以称为主题的类别存储记录流。<br>每个记录由一个键，一个值和一个时间戳组成。</p><p>Kafka有四个核心API：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- Producer API允许应用程序发布记录流到一个或多个Kafka主题</span><br><span class="line">- Consumer API允许应用程序订阅一个或多个主题，并处理为其生成的记录流.</span><br><span class="line">- Steams API允许应用程序充当流处理器，从一个或多个主题消费输入流，然后产生输出流到一个或多个输出主题，高效地转换输入流到输出流。</span><br><span class="line">- Connector API允许构建和运行可重用的生产者或消费者，将Kafka主题连接到现有应用程序或数据系统。例如，关系数据库的Connector连接器可能捕获对表的每个更改。</span><br></pre></td></tr></table></figure></p><p>  <img src="http://kafka.apache.org/0101/images/kafka-apis.png" alt="kafka-apis"></p><p>Kafka中，客户端和服务端的通讯使用一个简单的，高性能的，语言无关的TCP协议。该协议有版本控制，并保持与旧版本的向后兼容性。同时，提供了很多种语言的Kafka客户端。</p><h3 id="Kafka文件存储机制"><a href="#Kafka文件存储机制" class="headerlink" title="Kafka文件存储机制"></a>Kafka文件存储机制</h3><h4 id="Topic-amp-Partition"><a href="#Topic-amp-Partition" class="headerlink" title="Topic &amp; Partition"></a>Topic &amp; Partition</h4><p>Kafka为记录流提供的核心抽象便是主题（topic）.<br>主题是发布记录的类别或者feed名称。Kafka的主题总是支持多个消费者的，即一个主题可以拥有0个、1个或者多个订阅者来订阅发送到该主题的数据。</p><p>对于每个主题，Kafka集群维护了一个分区日志如下图：<br><img src="http://kafka.apache.org/0101/images/log_anatomy.png" alt="log_anatomy"></p><p>逻辑上Topic可以看为一个Queue，每个消息必须指定它所属的Topic，可理解为每条消息必须指明放到哪个Queue里。<br>物理上把Topic分成一个或多个Partition，每个Partition对应一个文件夹，文件夹存储Partition所有消息和索引文件。每个Partition有自己的副本，每个副本分布在不同的Broker节点上。通过多个Partition可使得吞吐率能线性提升。<br>消息append到Partition中，属于顺序写磁盘，顺序写磁盘效率远大于随机写内存，因此效率高。</p><p>每一个分区是一个有序的、不可变的记录序列，不断地追加到结构化提交日志。分区中的每条记录都被赋予了一个顺序的id号，称作offset偏移量，偏移量在某个分区内唯一标示每条记录。</p><p>Kafka集群保留所有已发布的记录，无论是否已经被消费。当然保留所有数据也不现实，kafka提供两种方式来删除数据，一种通过配置来定义数据的保留时间，另一种通过配置分区文件大小限制。例如，如果设置保留策略为2天，则一条记录在被发布后的2天之内，是可以被消费的，一旦2天过后则被丢弃来达到释放空间的目的。Kafka的性能和数据的大小密切相关，和将数据存储多长时间无太大关系.</p><p><img src="http://kafka.apache.org/0101/images/log_consumer.png" alt="log_consumer"></p><p>事实上，每个消费者保留的唯一元数据是该消费者在日志中的偏移或位置。这种偏移由消费者控制，通常消费者在读取记录时线性地提前其偏移，但是实际上，由于消费者控制着位置的值，所以它可以以喜欢的任何顺序来消费数据。例如，一个消费者可以将偏移量的值减小来重复处理以前的数据，或者跳过最近的记录从“现在”开始消费数据。</p><p>这些功能的组合使kafka的消费者非常轻量级，消费者来来去去，对集群和其他消费者却没什么太多影响。如，你可以通过kafka命令行工具的tail命令来获取任何主题的记录，却无需更改任何现有用户使用的内容。</p><p>日志的分区设计有几个目的。首先分区使日志可以增加到超出单台服务器的容量。首先，它们允许日志扩展到适合单个服务器的大小。每个单独的分区必须适合托管它的服务器，但主题可能有许多分区，因此它可以处理任意数量的数据。第二，为了并行性</p><h4 id="partition存储结构"><a href="#partition存储结构" class="headerlink" title="partition存储结构"></a>partition存储结构</h4><p>Partition命名规则：Topic+有序序号(从0开始)，例如topic_name-0, topic_name-1, topic_name-2 …   </p><p>Partition和副本分配方法。例如一个Kafka集群有2个Broker，创建一个Topic包含2个Partition，1个副本，则broker-0存放partition-0、partition-1，broker-1存放partition-0，partition-1即可 。</p><p>Partition中文件存储方式：每个Partition平均分配到多个大小相等的Segment数据文件中，Segment文件生命周期由server端配置参数决定。<br>Kafka有2种策略删除旧数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 基于时间，例如：删除1周以前的数据</span><br><span class="line">- 基于partition文件大小，例如：Partition文件大于1GB时候删除旧数据</span><br></pre></td></tr></table></figure></p><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>日志的分区分布在kafka集群中的服务器上，每个服务器处理数据并请求共享分区。每个分区都使用可配置数量的服务器进行复制，以实现容错。</p><p>每个分区都有一台机器充当leader，0或者多台机器充当followers。leader处理所有的针对该分区的读和写请求，followers则被动同步leader的数据。若leader宕机，则kafka自动选取一个followers来充当leader。每个服务器都充当某个分区的leader，同时，又充当剩下分区的follower，这样实现集群的负载均衡。</p><h3 id="生产者Producers"><a href="#生产者Producers" class="headerlink" title="生产者Producers"></a>生产者Producers</h3><p>生产者发布数据到他们选择发布的主题上。生产者决定哪条记录发布到主题内的哪个分区上，实现这个功能可以通过简单轮询或者通过语法层面的分区函数（如根据记录里的某个关键字段）来实现负载均衡。</p><h3 id="消费者Consumers"><a href="#消费者Consumers" class="headerlink" title="消费者Consumers"></a>消费者Consumers</h3><p>消费者使用一个消费者组名称consumer group name来标记自己，发布到主题的每个记录针对订阅该主题的每个消费组只会发送给其中一个消费者实例（消费者实例可以是在单独的进程或者单独的机器上）。<br>如果所有的消费者实例有相同的消费组，这样数据将在这些消费者实例中很好地负载均衡。<br>如果所有的消费者实例都有着不同的消费组，这样每条数据记录都会被广播到所有的消费者实例中。    </p><p><img src="http://kafka.apache.org/0101/images/consumer-groups.png" alt="consumer-groups"></p><p>如图，两台服务器组成的kafka集群，托管有四个分区(p0~p3)，与2个消费组。消费组A有2个消费者实例，消费组B有4个消费者实例。</p><p>通常情况下，一个主题有少量的消费组，可以理解为“逻辑上的订阅者”。为了扩展和容错，每个消费组里包含多个消费者实例。这就和发布-订阅模型很像，只不过kafka的一个订阅者是一个由很多实例组成的集群而不是单个进程。</p><p>在Kafka中实现消费的方式是通过在消费者实例上划分日志中的分区，使得每个实例在任何时间点是分区的“公平共享”的独占消费者。维持消费组内的消费实例与分区关系的过程是通过kafka协议动态完成的。如果新的消费实例加入消费组，他们会从组内的其他消费实例的手中接管一些分区；如果一个消费者实例死掉，它负责的分区会被分派到其他尚存的消费者实例中。</p><p>Kafka只提供一个分区内记录的总顺序，而不是主题中的不同分区之间，即不保证一个主题内不同分区的数据间的顺序关系。每个分区的顺序性结合按键分割数据的特性已经能满足大部分的程序需要。然而，如果你需要对记录进行总排序，可以使用只有一个分区的主题来实现，这意味着每个消费组内也只能有一个消费者实例。</p><h3 id="保证"><a href="#保证" class="headerlink" title="保证"></a>保证</h3><p>Kafka提供了如下保证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 生产者发送到特定主题分区的消息将按照发送时的顺序进行追加。即，如果记录M1和M2都是被同一个生产者发送，且M1先发送，这样M1拥有比M2小的偏移量，而且在日志文件里也出现的比M2早。</span><br><span class="line">- 一个消费者实例按照记录在日志文件里存储的顺序消费数据。</span><br><span class="line">- 针对副本个数设置为N的主题，kafka可以容忍N-1个服务器故障而不丢失任何提交到日志文件的任何记录。</span><br></pre></td></tr></table></figure></p><h3 id="Kafka作为消息系统Messaging-System"><a href="#Kafka作为消息系统Messaging-System" class="headerlink" title="Kafka作为消息系统Messaging System"></a>Kafka作为消息系统Messaging System</h3><p>Kafka流的概念 VS 传统企业级消息系统：</p><p>1、传统消息系统有2个模型：队列和发布-订阅模型。针对队列，一组消费者从一个服务器读取数据，每一条记录只被其中的一个消费者消费；针对发布-订阅模型，每条记录被广播到所有消费者。这2个模型都有其优势和劣势。队列允许你分割数据的处理到多个消费者实例，让你可以扩展处理过程，但不支持多个消费者组,因为一旦一个进程消费了数据数据便不可再被消费。发布订阅允许你广播数据到多个订阅者，但是不能够扩展处理过程因为每条记录都被发送到每一个订阅者。</p><p>由此，kafka产生了消费组的概念，和队列一样，消费组让你可以分割处理过程到一系列进程去处理（消费组的成员）。和订阅发布类似，消费组让你可以广播信息到多个消费组。</p><p>Kafka模型的优势是每个主题都有着两个特性，可以扩展处理过程同时支持多订阅者，没有必要非得像传统消息系统一样非得选择队列或者订阅发布模型。</p><p>2、Kafka相比传统消息系统也有着更强的顺序保证：<br>传统队列在服务器端按顺序保留记录，如果多个消费者从队列里消费数据，服务端按照他们存储的顺序分发记录，记录被异步传递到消费者，所以记录可能到达不同的消费者时丢失了顺序。这意味着存在并行消费时，记录的顺序在被多个消费者消费时的顺序和其存储顺序则不一致。消息系统通常使用一个叫做独占消费者的概念来解决这个问题，独占消费者只允许一个进程来从队列里消费数据，但这意味着处理过程没有并行性。</p><p>Kafka做得更好。通过在主题内部具有并行性的概念（分区），kafka可以在多个消费者进程间保证顺序和负载均衡。通过将主题内的分区分派到消费组内的消费者来实现，这样每个分区仅仅被该消费组内的恰好一个消费者消费。这样，kafka确保指定消费者是指定分区的唯一消费者，并且按顺序消费数据。由于有多个分区，这样做仍然可以在多个消费者实例上负载均衡。注意一个消费组里的消费者实例不能超过主题的分区数。</p><h3 id="kafka作为存储系统"><a href="#kafka作为存储系统" class="headerlink" title="kafka作为存储系统"></a>kafka作为存储系统</h3><p>任何允许发布消息和消费消息两个过程解耦的消息队列实际上都充当正在传输的消息的存储系统。Kafka就是一个非常优秀的存储系统。<br>写到Kafka的信息被写到了磁盘，为了容错进行了复制。Kafka为生产者提供确认机制，这样直到数据被全部复制成功后，一个写操作才被认为成功，并且保证即时服务器写入失败也会持续运行。<br>Kafka使用的磁盘结构很容易扩展-无论服务器上有50KB还是50TB的持久化数据，Kafka做的事情是一样的。</p><p>由于对很好地利用存储，并且允许客户端来控制自身的读取位置，所以将Kafka当做某种特殊用途的分布式文件系统，致力于解决高性能、低延迟的提交日志存储，复制和传播特性。</p><p>###kafka作为流处理系统<br>Kafka不仅仅可以用来读、写、存储数据流、还是可以当做实时流处理系统。<br>Kafka中，流处理器是从输入主题中获取连续数据流，然后对输入数据做一些处理，接着产生连续数据流到输出主题的任何东西。<br>如，一个零售程序接收销售和货物的输入数据流，然后计算后产生排序和价格调整的输出流。</p><p>如果是直接做一些简单的处理过程可以通过producer和consumer的API，对于更复杂的转换，Kafka提供了一套完整集成的流API，允许对流进行计算聚合或者合并流数据。</p><p>这套API帮助解决了这些难题：处理无序数据，重复处理数据，执行状态有关的计算等。<br>这套API构建与Kafka提供的核心原是愈发：生产者消费者API，Kafka的有状态存储机制，在流处理器实例之间使用相同的group组机制进行容错</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Kafka包含了消息、存储、流处理这些特性看似不寻常，但是Kafka作为一个流平台这些都是必须的。<br>分布式文件系统如HDFS允许存储静态文件用来批处理。这样的系统实际上可以存储并处理过去的历史数据。</p><p>传统企业级消息系统让你可以处理在订阅之后产生的数据，而构建于分布式文件系统的系统则可以处理订阅之前的数据。<br>Kafka拥有这两种特性，这对于Kafka作为流程序平台和流数据流水线至关重要</p><p>通过结合了存储和低延迟订阅的特性，流式应用程序以同样的方式处理过去和未来的数据。这个单一的程序可以处理历史的、已存储的数据；当消费到最后一条数据时，并没有结束，可以继续处理未来产生的数据。这便是流处理的一个广义概念，包括了批处理和消息驱动程序。</p><p>同样，对于流水局流水线而言，订阅和实时事件相结合使借助Kafka作为非常低延迟的流水线成为可能；可靠存储数据的特性使其应用于传送关键数据的场合，这些场合对于数据的传递必须得到保证，或者用于和仅仅周期性加载数据或可以长时间进行维护的离线系统进行集成的场景。Kafka流处理设施使得可以在数据到达时变换数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;kafka的入门知识&lt;br&gt;
    
    </summary>
    
      <category term="kafka" scheme="http://zhangxiangnan.com/categories/kafka/"/>
    
    
      <category term="kafka" scheme="http://zhangxiangnan.com/tags/kafka/"/>
    
  </entry>
  
</feed>
