<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="一块学习">
    <meta name="keyword" content="undefined">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        guava的集合工具类详解 - 张向南的博客 | zhangxiangnan&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> progress everyday </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.png">
        </div>
        <div class="name">
            <i>zhangxiangnan</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li>
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li>
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#静态构造方式"><span class="toc-text">静态构造方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterables"><span class="toc-text">Iterables</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#常用方法"><span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Iterables类似Collection的方法"><span class="toc-text">Iterables类似Collection的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FluentIterable"><span class="toc-text">FluentIterable</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lists"><span class="toc-text">Lists</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sets"><span class="toc-text">Sets</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Set理论上的操作"><span class="toc-text">Set理论上的操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maps"><span class="toc-text">Maps</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#uniqueIndex方法"><span class="toc-text">uniqueIndex方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#difference方法"><span class="toc-text">difference方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BiMap的工具方法"><span class="toc-text">BiMap的工具方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Multisets"><span class="toc-text">Multisets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Multimaps"><span class="toc-text">Multimaps</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#index"><span class="toc-text">index</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#invertFrom"><span class="toc-text">invertFrom</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#forMap方法"><span class="toc-text">forMap方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Wrappers包装"><span class="toc-text">Wrappers包装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tables"><span class="toc-text">Tables</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#transpose变换"><span class="toc-text">transpose变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Wrappers"><span class="toc-text">Wrappers</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input">
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> progress everyday </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        guava的集合工具类详解
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2016-11-22 15:18:15</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#guava" title="guava">guava</a>
        <span>/</span>
        
        <a class="tag" href="/tags/#CollectionUtilities" title="CollectionUtilities">CollectionUtilities</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>

    </div>
    <div class="post-content ">
        <p>JDK集合框架提供了许多工具，方便实用，Guava相比提供了更多的工具，适用于所有集合，这也是guava更流行和成熟的部分。<br><a id="more"></a></p>
<p>guava针对一个特定的接口将其方法以一种相对直观的方式进行分组，如下:</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>JDK还是Guava的接口</th>
<th>对应的Guava工具类</th>
</tr>
</thead>
<tbody>
<tr>
<td>Collection</td>
<td>JDK</td>
<td>Collections2 (避免和 java.util.Collections冲突)</td>
</tr>
<tr>
<td>List</td>
<td>JDK</td>
<td>Lists</td>
</tr>
<tr>
<td>Set</td>
<td>JDK</td>
<td>Sets</td>
</tr>
<tr>
<td>SortedSet</td>
<td>JDK</td>
<td>Sets</td>
</tr>
<tr>
<td>Map</td>
<td>JDK</td>
<td>Maps</td>
</tr>
<tr>
<td>SortedMap</td>
<td>JDK</td>
<td>Maps</td>
</tr>
<tr>
<td>Queue</td>
<td>JDK</td>
<td>Queues</td>
</tr>
<tr>
<td>Multiset</td>
<td>Guava</td>
<td>Multisets</td>
</tr>
<tr>
<td>Multimap</td>
<td>Guava</td>
<td>Multimaps</td>
</tr>
<tr>
<td>BiMap</td>
<td>Guava</td>
<td>Maps</td>
</tr>
<tr>
<td>Table</td>
<td>Guava</td>
<td>Tables</td>
</tr>
</tbody>
</table>
<h3 id="静态构造方式"><a href="#静态构造方式" class="headerlink" title="静态构造方式"></a>静态构造方式</h3><p>JDK7之前，构造新的泛型集合需要讨厌的代码重复:</p>
<pre><code>List&lt;TypeThatsTooLongForItsOwnGood&gt; list = new ArrayList&lt;TypeThatsTooLongForItsOwnGood&gt;();
</code></pre><p>Guava则借助于泛型推断来决定右侧类型：</p>
<pre><code>List&lt;TypeThatsTooLongForItsOwnGood&gt; list = Lists.newArrayList();
Map&lt;KeyType, LongishValueType&gt; map = Maps.newLinkedHashMap();
</code></pre><p>JDK7的菱形操作符也去除了右侧类型：</p>
<pre><code>List&lt;TypeThatsTooLongForItsOwnGood&gt; list = new ArrayList&lt;&gt;();
</code></pre><p>但是guava优化的更好，使用工厂模式，可以很方便的初始化集合。</p>
<pre><code>Set&lt;Type&gt; copySet = Sets.newHashSet(elements);
List&lt;String&gt; theseElements = Lists.newArrayList(&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;);
</code></pre><p>此外，可以根据工厂方法的名称来提高初始化集合到指定大小的可读性：</p>
<pre><code>List&lt;Type&gt; exactly100 = Lists.newArrayListWithCapacity(100);
List&lt;Type&gt; approx100 = Lists.newArrayListWithExpectedSize(100);
Set&lt;Type&gt; approx100Set = Sets.newHashSetWithExpectedSize(100);
</code></pre><p>注意: Guava自己的新集合类型没有暴露原始构造器或初始化工具方法。相反，Guava暴露了静态工厂方法，如：</p>
<pre><code>Multiset&lt;String&gt; multiset = HashMultiset.create();
</code></pre><h3 id="Iterables"><a href="#Iterables" class="headerlink" title="Iterables"></a>Iterables</h3><p>Guava的工具方法总是接受Iterable而不是Collection，这是因为遇到一个不是存在在内存中的“集合”是很常见的，如从数据库，从数据中心；如果没有抓取到所有的元素，是不支持如size方法的。</p>
<p>因此，你希望的支持所有Collections的许多操作都可以在Iterables中找到。此外，大多数Iterables的方法在Iterables中有访问原始iterator的对应版本。</p>
<p>Iterables中的绝大多数方法都是很简便的: 只在有绝对需要的时候才增强底层迭代。返回Iterables的方法返回的是简单计算的视图，而不是内存中显示构造的新集合。</p>
<p>Guava12中，Iterables通过FlumentIterable支持，对大多数操作进行流式语法包装。</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>等同于</th>
</tr>
</thead>
<tbody>
<tr>
<td>concat(<code>Iterable&lt;Iterable&gt;</code>)</td>
<td>返回几个Iterables对象的原始级联视图</td>
<td>concat(Iterable…)</td>
</tr>
<tr>
<td>frequency(Iterable, Object)</td>
<td>返回指定object在Iterable中出现的次数</td>
<td>Collections.frequency(Collection, Object); 参考Multiset</td>
</tr>
<tr>
<td>partition(Iterable, int)</td>
<td>把Iterable分割为每块含有指定的数目，并返回不可修改的视图</td>
<td>Lists.partition(List, int), paddedPartition(Iterable, int)</td>
</tr>
<tr>
<td>getFirst(Iterable, T default)</td>
<td>返回Iterable的第一个元素，若为空返回指定默认元素.</td>
<td>Iterable.iterator().next() FluentIterable.first()</td>
</tr>
<tr>
<td>getLast(Iterable)</td>
<td>返回iterable的最后元素，或者当为空时快速失败</td>
<td>getLast(Iterable, T default) FluentIterable.last()</td>
</tr>
<tr>
<td> elementsEqual(Iterable, Iterable)</td>
<td>当Iterables相同的顺序上拥有相同的元素才返回true</td>
<td>List.equals(Object)</td>
</tr>
<tr>
<td>unmodifiableIterable(Iterable)</td>
<td>返回iterable的不可修改视图</td>
<td>Collections.unmodifiableCollection(Collection)</td>
</tr>
<tr>
<td>limit(Iterable, int)</td>
<td>返回元素个数最多为指定数字的Iterable</td>
<td>FluentIterable.limit(int)</td>
</tr>
<tr>
<td>getOnlyElement(Iterable)</td>
<td>返回Iterable中的仅有的一个元素，若Iterable为空或者含有多个元素则快速失败。</td>
<td>getOnlyElement(Iterable, T default)</td>
</tr>
</tbody>
</table>
<pre><code>Iterable&lt;Integer&gt; concatenated = Iterables.concat(
  Ints.asList(1, 2, 3),
  Ints.asList(4, 5, 6));
// concatenated has elements 1, 2, 3, 4, 5, 6

String lastAdded = Iterables.getLast(myLinkedHashSet);

String theElement = Iterables.getOnlyElement(thisSetIsDefinitelyASingleton);
  // if this set isn&apos;t a singleton, something is wrong!
</code></pre><h4 id="Iterables类似Collection的方法"><a href="#Iterables类似Collection的方法" class="headerlink" title="Iterables类似Collection的方法"></a>Iterables类似Collection的方法</h4><p>通常，Collections天然支持如下这些操作，但是Iterables不是这样。<br>这些操作当参数实际上是Collection时，每个都都代表了对应的集合接口方法。如，如果Iterables.size传入的参数实际上是一个Collection，方法内部调用Collection.size替代而不是遍历Iterator。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>类似集合方法</th>
<th>FluentIterable等价方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>addAll(Collection addTo, Iterable toAdd)</td>
<td>Collection.addAll(Collection)</td>
<td></td>
</tr>
<tr>
<td>contains(Iterable, Object)</td>
<td>Collection.contains(Object)</td>
<td>FluentIterable.contains(Object)</td>
</tr>
<tr>
<td>removeAll(Iterable removeFrom, Collection toRemove)</td>
<td>Collection.removeAll(Collection)</td>
<td></td>
</tr>
<tr>
<td>retainAll(Iterable removeFrom, Collection toRetain)</td>
<td>Collection.retainAll(Collection)</td>
<td></td>
</tr>
<tr>
<td>size(Iterable)</td>
<td>Collection.size()</td>
<td>FluentIterable.size()</td>
</tr>
<tr>
<td>toArray(Iterable, Class)</td>
<td>Collection.toArray(T[])</td>
<td>FluentIterable.toArray(Class)</td>
</tr>
<tr>
<td>isEmpty(Iterable)</td>
<td>Collection.isEmpty()</td>
<td>FluentIterable.isEmpty()</td>
</tr>
<tr>
<td>get(Iterable, int)</td>
<td>List.get(int)</td>
<td>FluentIterable.get(int)</td>
</tr>
<tr>
<td>toString(Iterable)</td>
<td>Collection.toString()</td>
<td>FluentIterable.toString()</td>
</tr>
</tbody>
</table>
<h4 id="FluentIterable"><a href="#FluentIterable" class="headerlink" title="FluentIterable"></a>FluentIterable</h4><p>FluentIterable也有几个拷贝到不可变集合的简洁的方法:</p>
<p>ImmutableSet toImmutableSet()<br>ImmutableSortedSet toImmutableSortedSet(Comparator)</p>
<h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h3><p>除了静态构造方法和函数式编程方法，Lists提供了很多实用的工具方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>partition(List, int)</td>
<td>返回一个list视图，将原List分为指定大小的块</td>
</tr>
<tr>
<td>reverse(List)</td>
<td>返回指定List的反转（倒序）视图，若果list不可变，请使用 ImmutableList.reverse()</td>
</tr>
</tbody>
</table>
<pre><code>List&lt;Integer&gt; countUp = Ints.asList(1, 2, 3, 4, 5);
List&lt;Integer&gt; countDown = Lists.reverse(theList); // {5, 4, 3, 2, 1}

List&lt;List&lt;Integer&gt;&gt; parts = Lists.partition(countUp, 2); // {{1, 2}, {3, 4}, {5}}
</code></pre><h3 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h3><h4 id="Set理论上的操作"><a href="#Set理论上的操作" class="headerlink" title="Set理论上的操作"></a>Set理论上的操作</h4><p>We provide a number of standard set-theoretic operations, implemented as views over the argument sets. These return a SetView, which can be used:<br>Guava支持set理论上的操作，均返回SetView，其支持：</p>
<ul>
<li>直接作为一个Set，因为SetView实现了Set接口</li>
<li>拷贝到另一个不可变的集合通过copyInto(set)</li>
<li>通过immutableCopy()得到一个不可变的拷贝</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>union(Set, Set)</td>
</tr>
<tr>
<td></td>
<td>intersection(Set, Set)</td>
</tr>
<tr>
<td></td>
<td>difference(Set, Set)</td>
</tr>
<tr>
<td></td>
<td>symmetricDifference(Set, Set)</td>
</tr>
</tbody>
</table>
<p>如：</p>
<pre><code>Set&lt;String&gt; wordsWithPrimeLength = ImmutableSet.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;);
Set&lt;String&gt; primes = ImmutableSet.of(&quot;two&quot;, &quot;three&quot;, &quot;five&quot;, &quot;seven&quot;);

SetView&lt;String&gt; intersection = Sets.intersection(primes, wordsWithPrimeLength); // contains &quot;two&quot;, &quot;three&quot;, &quot;seven&quot;
// 可以直接使用intersection作为Set，但是如果使用很多次则拷贝更高效
return intersection.immutableCopy();
</code></pre><p>其他Set工具方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>参照</th>
</tr>
</thead>
<tbody>
<tr>
<td>cartesianProduct(List<set>)</set></td>
<td>笛卡尔乘积，返回从每个Set选取的每个元素可能组成的list</td>
<td>cartesianProduct(Set…)</td>
</tr>
<tr>
<td>powerSet(Set)</td>
<td>返回指定set的子set的set集合</td>
<td></td>
</tr>
</tbody>
</table>
<pre><code>Set&lt;String&gt; animals = ImmutableSet.of(&quot;gerbil&quot;, &quot;hamster&quot;);
Set&lt;String&gt; fruits = ImmutableSet.of(&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;);

Set&lt;List&lt;String&gt;&gt; product = Sets.cartesianProduct(animals, fruits);
// {{"gerbil", "apple"}, {"gerbil", "orange"}, {"gerbil", "banana"},
    //  {"hamster", "apple"}, {"hamster", "orange"}, {"hamster", "banana"}}

Set&lt;Set&lt;String&gt;&gt; animalSets = Sets.powerSet(animals);
// {{}, {"gerbil"}, {"hamster"}, {"gerbil", "hamster"}}
</code></pre><h3 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h3><h4 id="uniqueIndex方法"><a href="#uniqueIndex方法" class="headerlink" title="uniqueIndex方法"></a>uniqueIndex方法</h4><p>Maps.uniqueIndex(Iterable, Function) 解决的是拥有一组对象，每个对象的某个属性是唯一的，我们想通过这个唯一的属性来找到这个对象。</p>
<p>如我们有一组string，每个string长度不一样，想通过指定的长度来找到某个对象：</p>
<pre><code>ImmutableMap&lt;Integer, String&gt; stringsByIndex = Maps.uniqueIndex(strings, new Function&lt;String, Integer&gt; () {
    public Integer apply(String string) {
      return string.length();
    }
  });
</code></pre><h4 id="difference方法"><a href="#difference方法" class="headerlink" title="difference方法"></a>difference方法</h4><p>Maps.difference(Map, Map)比较的是2个map的所有不同点，返回一个MapDifference对象:</p>
<ul>
<li>entriesInCommon() 在2个map里都有的entry，key和values都相等。</li>
<li>entriesDiffering()    key相同，但是有不同的values，可以通过MapDifference.ValueDifference来得到左边和右边的values</li>
<li>entriesOnlyOnLeft()    key在左边的map里存在但是在右边的map里没有</li>
<li><p>entriesOnlyOnRight()    key在右边的map存在，左边没有</p>
<p>  Map&lt;String, Integer&gt; left = ImmutableMap.of(“a”, 1, “b”, 2, “c”, 3);<br>  Map&lt;String, Integer&gt; right = ImmutableMap.of(“b”, 2, “c”, 4, “d”, 5);<br>  MapDifference&lt;String, Integer&gt; diff = Maps.difference(left, right);</p>
<p>  diff.entriesInCommon(); // {“b” =&gt; 2}<br>  diff.entriesDiffering(); // {“c” =&gt; (3, 4)}<br>  diff.entriesOnlyOnLeft(); // {“a” =&gt; 1}<br>  diff.entriesOnlyOnRight(); // {“d” =&gt; 5}</p>
</li>
</ul>
<h3 id="BiMap的工具方法"><a href="#BiMap的工具方法" class="headerlink" title="BiMap的工具方法"></a>BiMap的工具方法</h3><p>The Guava针对BiMap的工具方法在Maps里，因为BiMap也是一个Map</p>
<table>
<thead>
<tr>
<th>BiMap utility</th>
<th>Corresponding Map utility</th>
</tr>
</thead>
<tbody>
<tr>
<td>synchronizedBiMap(BiMap)</td>
<td>Collections.synchronizedMap(Map)</td>
</tr>
<tr>
<td>unmodifiableBiMap(BiMap)</td>
<td>Collections.unmodifiableMap(Map)</td>
</tr>
</tbody>
</table>
<h3 id="Multisets"><a href="#Multisets" class="headerlink" title="Multisets"></a>Multisets</h3><p>标准的集合操作，如containsAll忽略了multiset中元素出现的次数，只关心元素是否在multiset中存在与否。Multisets则提供了许多重视元素多样性的操作：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>和Collection方法的区别</th>
</tr>
</thead>
<tbody>
<tr>
<td>containsOccurrences(Multiset sup, Multiset sub)</td>
<td>如果sub.count(o)&lt;=super.count(o)对于所有的o成立，则返回true，否则false</td>
<td>Collection.containsAll忽略了出现次数，仅仅测试元素是否被包含</td>
</tr>
<tr>
<td>removeOccurrences(Multiset removeFrom, Multiset toRemove)</td>
<td>移除removeFrom中的一次出现针对toRemove元素的每一次出现</td>
<td>Collection.removeAll移除了所有元素的所有出现次数，虽然toremove中仅仅出现一次</td>
</tr>
<tr>
<td>retainOccurrences(Multiset removeFrom, Multiset toRetain)</td>
<td>确保对于所有的o，removeFrom.count(o) &lt;= toReatin.count(o)</td>
<td>Collection.retainAll保留了所有元素的所有出现次数，虽然toReatin中仅仅出现一次。</td>
</tr>
<tr>
<td>intersection(Multiset, Multiset)</td>
<td>返回2个multisets的交集视图，retainOccurrences的一种非破坏性方法</td>
<td></td>
</tr>
</tbody>
</table>
<pre><code>Multiset&lt;String&gt; multiset1 = HashMultiset.create();
multiset1.add(&quot;a&quot;, 2);

Multiset&lt;String&gt; multiset2 = HashMultiset.create();
multiset2.add(&quot;a&quot;, 5);

multiset1.containsAll(multiset2); // returns true: all unique elements are contained,
  // even though multiset1.count(&quot;a&quot;) == 2 &lt; multiset2.count(&quot;a&quot;) == 5
Multisets.containsOccurrences(multiset1, multiset2); // returns false

multiset2.removeOccurrences(multiset1); // multiset2 now contains 3 occurrences of &quot;a&quot;

multiset2.removeAll(multiset1); // removes all occurrences of &quot;a&quot; from multiset2, even though multiset1.count(&quot;a&quot;) == 2
multiset2.isEmpty(); // returns true
</code></pre><p>其他Multisets中的工具方法包括：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>copyHighestCountFirst(Multiset)</td>
<td>返回出现频次倒序的Multiset的不可变拷贝</td>
</tr>
<tr>
<td>unmodifiableMultiset(Multiset)</td>
<td>返回Multiset的不可变视图</td>
</tr>
<tr>
<td>unmodifiableSortedMultiset(SortedMultiset)</td>
<td>返回排序Multiset的不可变视图</td>
</tr>
</tbody>
</table>
<pre><code>Multiset&lt;String&gt; multiset = HashMultiset.create();
multiset.add(&quot;a&quot;, 3);
multiset.add(&quot;b&quot;, 5);
multiset.add(&quot;c&quot;, 1);

ImmutableMultiset&lt;String&gt; highestCountFirst = Multisets.copyHighestCountFirst(multiset);

// highestCountFirst, 类似它的entrySet和elementSet, 以顺序{&quot;b&quot;, &quot;a&quot;, &quot;c&quot;}遍历元素
</code></pre><h3 id="Multimaps"><a href="#Multimaps" class="headerlink" title="Multimaps"></a>Multimaps</h3><h4 id="index"><a href="#index" class="headerlink" title="index"></a>index</h4><p>对比Maps.uniqueIndex, Multimaps.index(Iterable, Function)解决的是当你想要找到某个属性上相同的所有对象时，也有可能是唯一的单独对象.<br>假如想通过长度来进行分组：<br>    ImmutableSet<string> digits = ImmutableSet.of(“zero”, “one”, “two”, “three”, “four”,<br>      “five”, “six”, “seven”, “eight”, “nine”);<br>    Function&lt;String, Integer&gt; lengthFunction = new Function&lt;String, Integer&gt;() {<br>      public Integer apply(String string) {<br>        return string.length();<br>      }<br>    };<br>    ImmutableListMultimap&lt;Integer, String&gt; digitsByLength = Multimaps.index(digits, lengthFunction);<br>    `/*</string></p>
<pre><code>* digitsByLength maps:
*  3 =&gt; {&quot;one&quot;, &quot;two&quot;, &quot;six&quot;}
*  4 =&gt; {&quot;zero&quot;, &quot;four&quot;, &quot;five&quot;, &quot;nine&quot;}
*  5 =&gt; {&quot;three&quot;, &quot;seven&quot;, &quot;eight&quot;}
*/`
</code></pre><h4 id="invertFrom"><a href="#invertFrom" class="headerlink" title="invertFrom"></a>invertFrom</h4><p>由于Multimap可以映射许多key到某个value，以及一个key到多个values，所有反转一个multimap会很有用。Guava提供invertFrom(Multimap toInvert, Multimap dest)来实现该功能。</p>
<p>NOTE: 如果使用ImmutableMultimap，则考虑使用ImmutableMultimap.inverse()替换.</p>
<pre><code>ArrayListMultimap&lt;String, Integer&gt; multimap = ArrayListMultimap.create();
multimap.putAll(&quot;b&quot;, Ints.asList(2, 4, 6));
multimap.putAll(&quot;a&quot;, Ints.asList(4, 2, 1));
multimap.putAll(&quot;c&quot;, Ints.asList(2, 5, 3));

TreeMultimap&lt;Integer, String&gt; inverse = Multimaps.invertFrom(multimap, TreeMultimap.&lt;String, Integer&gt; create());
// 注意我们自己选择实现，所有如果用TreeMultimap会得到如下有序的结果：
`/*
 * inverse maps:
 *  1 =&gt; {&quot;a&quot;}
 *  2 =&gt; {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}
 *  3 =&gt; {&quot;c&quot;}
 *  4 =&gt; {&quot;a&quot;, &quot;b&quot;}
 *  5 =&gt; {&quot;c&quot;}
 *  6 =&gt; {&quot;b&quot;}
 */`
</code></pre><h4 id="forMap方法"><a href="#forMap方法" class="headerlink" title="forMap方法"></a>forMap方法</h4><p>假如想对一个Map使用Multimap的方法该怎么办？forMap(map)视图将一个Map当做SetMultiMap。这会很有用，如，和Multimaps.invertFrom结合使用：</p>
<pre><code>Map&lt;String, Integer&gt; map = ImmutableMap.of(&quot;a&quot;, 1, &quot;b&quot;, 1, &quot;c&quot;, 2);
SetMultimap&lt;String, Integer&gt; multimap = Multimaps.forMap(map);
// multimap maps [&quot;a&quot; =&gt; {1}, &quot;b&quot; =&gt; {1}, &quot;c&quot; =&gt; {2}]
Multimap&lt;Integer, String&gt; inverse = Multimaps.invertFrom(multimap, HashMultimap.&lt;Integer, String&gt; create());
// inverse maps [1 =&gt; {&quot;a&quot;, &quot;b&quot;}, 2 =&gt; {&quot;c&quot;}]
</code></pre><h4 id="Wrappers包装"><a href="#Wrappers包装" class="headerlink" title="Wrappers包装"></a>Wrappers包装</h4><h3 id="Tables"><a href="#Tables" class="headerlink" title="Tables"></a>Tables</h3><p>与Multimaps.newXXXMultimap(Map, Supplier)工具方法类似， Tables.newCustomTable(Map, Supplier<map>)允许你指定一个你喜欢的row或者column map的Table实现。</map></p>
<pre><code>// use LinkedHashMaps instead of HashMaps
Table&lt;String, Character, Integer&gt; table = Tables.newCustomTable(
  Maps.&lt;String, Map&lt;Character, Integer&gt;&gt;newLinkedHashMap(),
  new Supplier&lt;Map&lt;Character, Integer&gt;&gt; () {
    public Map&lt;Character, Integer&gt; get() {
      return Maps.newLinkedHashMap();
    }
  });
</code></pre><h4 id="transpose变换"><a href="#transpose变换" class="headerlink" title="transpose变换"></a>transpose变换</h4><p>The transpose(Table&lt;R, C, V&gt;) 方法允许你将Table&lt;R, C, V&gt;变换成Table&lt;C, R, V&gt;.</p>
<h4 id="Wrappers"><a href="#Wrappers" class="headerlink" title="Wrappers"></a>Wrappers</h4><p>大多数情形使用ImmutableTable</p>

        
        <br>
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
