<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="一块学习">
    <meta name="keyword" content="undefined">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        guava的新集合类型 - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> progress everyday </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.png">
        </div>
        <div class="name">
            <i>zhangxiangnan</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li>
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li>
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Multiset"><span class="toc-text">Multiset</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Multiset不是一个Map"><span class="toc-text">Multiset不是一个Map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现类"><span class="toc-text">实现类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SortedMultiset"><span class="toc-text">SortedMultiset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Multimap"><span class="toc-text">Multimap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Modifying-修改API"><span class="toc-text">Modifying 修改API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#views视图"><span class="toc-text">views视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Multimap不仅仅是map"><span class="toc-text">Multimap不仅仅是map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现类-1"><span class="toc-text">实现类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BiMap-双向Map"><span class="toc-text">BiMap 双向Map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实现"><span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#表格Table"><span class="toc-text">表格Table</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ClassToInstanceMap-类型到实例的映射Map"><span class="toc-text">ClassToInstanceMap 类型到实例的映射Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RangeSet"><span class="toc-text">RangeSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#视图"><span class="toc-text">视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查询"><span class="toc-text">查询</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RangeMap"><span class="toc-text">RangeMap</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input">
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> progress everyday </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        guava的新集合类型
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2016-10-21 13:20:15</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#guava" title="guava">guava</a>
        <span>/</span>
        
        <a class="tag" href="/tags/#newCollectionsTypes" title="newCollectionsTypes">newCollectionsTypes</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>

    </div>
    <div class="post-content ">
        <p>guava的新集合类型Multiset、Multimap、BiMap、Table、ClassToInstanceMap、RangeSet<br><a id="more"></a><br>Guava介绍了许多jdk中没有的但是很有用处的新集合类型，这些新集合类型和JDK集合框架和平共处，并且没有硬塞进任何东西到JDK集合抽象类中。<br>一般来说，Guava的集合实现严格遵循了JDK接口契约。</p>
<h3 id="Multiset"><a href="#Multiset" class="headerlink" title="Multiset"></a>Multiset</h3><p>传统的JAVA惯例手法来统计一文档中的单词出现频率，类似如下：</p>
<pre><code>Map&lt;String, Integer&gt; counts = new HashMap&lt;String, Integer&gt;();
for (String word : words) {
  Integer count = counts.get(word);
  if (count == null) {
    counts.put(word, 1);
  } else {
    counts.put(word, count + 1);
  }
}
</code></pre><p>这种方式笨拙，容易出错，且不支持收集各种有用的统计信息，如单词总数，而Guava做的更好。<br>Guava提供一个新集合类型，Multiset，支持元素的多次添加，数学中的multiset定义为元素可以出现不止一次的set。在multiset中，类似sets和tuples，元素是无序的，如multisets {a, a, b} 和 {a, b, a} 是equal的。</p>
<p>有2种方式理解这个概念：</p>
<ul>
<li>类似一个没元素顺序的约束的ArrayList<e></e></li>
<li>类似一个Map&lt;E, Integer&gt;,key、value分别表示元素和元素出现的次数</li>
</ul>
<p>Guava的Multiset API结合了这2种方式，如下：</p>
<ul>
<li>当以正常集合对待它，Multiset表现的更像是一个无序的ArrayList：<ul>
<li>调用add(E),则该元素出现的次数加1.</li>
<li>Multiset的iterator()方法迭代每一个元素的每一次出现。</li>
<li>size()方法是所有元素的所有出现次数的总和。</li>
</ul>
</li>
<li>额外的query操作，及性能特性，比较像一个Map&lt;E, Integer&gt;.<ul>
<li>count(Object)方法返回指定元素的出现次数。HashMultiset的count方法效率是O(1)，TreeMultiset的count方法效率是O(log n)等。</li>
<li>entrySet() 类似Map的entrySet。</li>
<li>elementSet()返回multiset的一个去重的元素集合<code>Set&lt;E&gt;</code>，类似于Map的keySet()</li>
<li>针对不重复的元素来说，Multiset实现类内存消耗（空间复杂度）随着不重复元素的数目线性增长,即重复存储相同对象。</li>
</ul>
</li>
</ul>
<p>尤其需要注意，Multiset是和JDK集合Collection的接口规范完全一致的，除了JDK自身的早期版本的极少见情形 – 特别的，TreeMultiset，类似TreeSet，使用comparison来比较是否相等，而不是Object的equals方法. 特别地，Multiset.addAll(Collection)在集合中的每个元素每出现一次，该元素的出现次数加一，该方式比上面的使用Map+for循环更简便。</p>
<p>其他方法说明如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>count(E)</td>
<td>对添加到multiset的元素出现次数进行计数</td>
</tr>
<tr>
<td>elementSet()</td>
<td>返回Multiset<e>的去重元素的集合(一个<code>Set&lt;E&gt;</code>)</e></td>
</tr>
<tr>
<td>entrySet()</td>
<td>类似于Map.entrySet(),返回<code>Set&lt;Multiset.Entry&lt;E&gt;&gt;</code>，一个包含支持getElement()和getCount()方法的entries的set集合</td>
</tr>
<tr>
<td>add(E, int)</td>
<td>给指定元素添加指定数目的出现次数</td>
</tr>
<tr>
<td>remove(E, int)</td>
<td>移除指定元素的指定数目的出现次数</td>
</tr>
<tr>
<td>setCount(E, int)</td>
<td>设置指定元素的出现次数为非负值</td>
</tr>
<tr>
<td>size()</td>
<td>返回Multiset中所有元素的总共的出现次数和。</td>
</tr>
</tbody>
</table>
<h4 id="Multiset不是一个Map"><a href="#Multiset不是一个Map" class="headerlink" title="Multiset不是一个Map"></a>Multiset不是一个Map</h4><p>注意Multiset<e>不是一个Map&lt;E, Integer&gt;，尽管Multiset实现有这部分的功能。Multiset是一个真正的集合类型， 符合所有的相关的接口协议，其他值得注意的区别如下：</e></p>
<ul>
<li>一个Multiset<e>的元素只能有正数的count计数，不能是负数。计数0不认为在multiset中，在elementSet()、entrySet视图中计数为0的元素会被过滤。</e></li>
<li>multiset.size() 返回集合的大小，就是集合中所有元素的计数的总和。如果想要得到去重后元素的数目（不重复元素的数目），使用elementSet().size()得到。(所以，例如，add(E)方法会使multiset.size()的数目加一)</li>
<li>multiset.iterator() 会遍历每一个元素的每一次出现，所以迭代的次数等于multiset.size()</li>
<li><code>Multiset&lt;E&gt;</code> 支持添加元素，移除元素，或者直接设置元素的计数count。setCount(elem, 0)等价于移除该元素的所有次数的出现。</li>
<li>multiset.count(elem) 对于不在multiset中的元素始终返回0</li>
</ul>
<h4 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h4><p>Guava提供许多Multiset的实现，大体上对应于JDK的map实现类。</p>
<table>
<thead>
<tr>
<th>Map</th>
<th>Corresponding Multiset</th>
<th>Supports null elements</th>
</tr>
</thead>
<tbody>
<tr>
<td>HashMap</td>
<td>HashMultiset</td>
<td>Yes</td>
</tr>
<tr>
<td>TreeMap</td>
<td>TreeMultiset</td>
<td>Yes (if the comparator does)</td>
</tr>
<tr>
<td>LinkedHashMap</td>
<td>LinkedHashMultiset</td>
<td>Yes</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td>ConcurrentHashMultiset</td>
<td>No</td>
</tr>
<tr>
<td>ImmutableMap</td>
<td>ImmutableMultiset</td>
<td>No</td>
</tr>
</tbody>
</table>
<h3 id="SortedMultiset"><a href="#SortedMultiset" class="headerlink" title="SortedMultiset"></a>SortedMultiset</h3><p>SortedMultiset<br>SortedMultiset是Multiset接口的一个变种，支持高效地获取指定范围的子multisets。例如你可以使用latencies.subMultiset(0, BoundType.OPEN, 100, BoundType.OPEN).size()来获取你的网站100ms下的延迟的请求的子集，然后和latecies.size()比较来获取百分比。</p>
<p>TreeMultiset实现了SortedMultiset接口。ImmutableSortedMultiset目前正在测试GWT的兼容性。</p>
<h3 id="Multimap"><a href="#Multimap" class="headerlink" title="Multimap"></a>Multimap</h3><p>每一个有经验的java程序员很可能自己实现了<code>Map&lt;K, List&lt;V&gt;&gt;</code>或者<code>Map&lt;K, Set&lt;V&gt;&gt;</code>，或者直接使用那种笨拙的结构。Guava的Multimap框架使处理从keys到多个值得映射关系变得简单。一个Multimap是一个普遍的方式来关联keys和任意多values。</p>
<p>从概念上有2种方式来理解Multimap：单个key到单个value的映射集合：</p>
<pre><code>a -&gt; 1 a -&gt; 2 a -&gt; 4 b -&gt; 3 c -&gt; 5
</code></pre><p>或者是唯一的单个key到values集合的映射关系：</p>
<pre><code>a -&gt; [1, 2, 4] b -&gt; [3] c -&gt; [5]
</code></pre><p>一般来说, Multimap接口是理解这种观念最好的视图，但是也允许你使用asMap()以另一种方式来看，asMap()返回<code>Map&lt;K, Collection&lt;V&gt;&gt;</code>。<br>最重要的是， 不会出现一个key对应一个空集合的情况：一个key要么映射到至少一个value，要么在Multimap中该key不存在。<br>如果你想区分key存在但是没对应的values和key就不存在这2种情况，更适合的数据结构很可能是Graph图（支持孤立点）。</p>
<p>我们很少直接使用Multimap接口，更多的是，我们会使用ListMultimap或者SetMultimap，相应地keys映射到List和Set。</p>
<h4 id="Modifying-修改API"><a href="#Modifying-修改API" class="headerlink" title="Modifying 修改API"></a>Modifying 修改API</h4><p>Multimap.get(key)返回和给定key相关联的values视图，即时目前什么也没有。对于ListMultiMap返回一个list，SetMultimap返回一个set。</p>
<p>修改操作直接对底层的Multimap进行写。如：    </p>
<pre><code>Set&lt;Person&gt; aliceChildren = childrenMultimap.get(alice);
aliceChildren.clear();
aliceChildren.add(bob);
aliceChildren.add(carol);
</code></pre><p>对底层的MultiMap直接进行写。</p>
<p>其他修改multimap的方式（更直接）包括：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>等同于</th>
</tr>
</thead>
<tbody>
<tr>
<td>put(K, V)</td>
<td>添加key到value的映射</td>
<td>multimap.get(key).add(value)</td>
</tr>
<tr>
<td><code>putAll(K, Iterable&lt;V&gt;</code>)</td>
<td>依次添加key到每一个value的映射</td>
<td>Iterables.addAll(multimap.get(key), values)</td>
</tr>
<tr>
<td>remove(K, V)</td>
<td>移除key到value的映射，若multimap改变了则返回true，否则false</td>
<td>multimap.get(key).remove(value)</td>
</tr>
<tr>
<td>removeAll(K)</td>
<td>移除所有与key映射的所有value，返回的集合可以修改，但是修改它不会影响multimap (返回适合的集合类型)</td>
<td>multimap.get(key).clear()</td>
</tr>
<tr>
<td><code>replaceValues(K, Iterable&lt;V&gt;</code>)</td>
<td>清空key到所有value的映射，然后设置key到每个给定value的映射。返回被清空的key关联的vlaues集合</td>
<td>multimap.get(key).clear(); Iterables.addAll(multimap.get(key), values)</td>
</tr>
</tbody>
</table>
<h4 id="views视图"><a href="#views视图" class="headerlink" title="views视图"></a>views视图</h4><p>MultiMap支持一系列强大的视图：</p>
<ul>
<li>asMap方法将所有的<code>Multimap&lt;K,V&gt;当做一个Map&lt;K,Collection&gt;&gt;</code>，其返回值支持remove、并且对返回集合的改变会影响到multimap，但是其不支持put或者putall。更关键的是，当你想要对于不存在的key返回null时你可以使用asMap().get(key)，而不是返回一个干净的空集合。(你应当强转asMap.get(key)的返回值到合适的集合类型– 对应SetMultiMap的是set，ListMultiMap的List – 但是JDK的类型系统不允许ListMultiMap返回<code>Map&lt;K, List&lt;V&gt;&gt;</code>)</li>
<li>entries方法返回MultiMap所有的entries为一个<code>Collection&lt;Map.Entry&lt;K, V&gt;&gt;</code>（对SetMultiMap来说，Collection实际上是个Set)</li>
<li>keySet将MultiMap中所有的key去重，返回一个set。</li>
<li>keys方法将MultiMap中的所有keys看成一个MultiSet，并且和key相关联的values有着相同的多样性。 元素可以从MultiSet移除，但是不能添加；改变会导致原MultiMap改变。</li>
<li>values()方法返回MultiMap里所有的values为一个多重集的<code>Collection&lt;V&gt;</code>，所有的value都在这一个Collection。类似于Iterables.concat(multimap.asMap.values())</li>
</ul>
<h4 id="Multimap不仅仅是map"><a href="#Multimap不仅仅是map" class="headerlink" title="Multimap不仅仅是map"></a>Multimap不仅仅是map</h4><p>A <code>Multimap&lt;K, V&gt;</code> 不仅仅是一个<code>Map&lt;K, Colleciton&lt;V&gt;&gt;</code>，尽管这样的一个map可能被Multimap的某个实现使用，显著区别如下：</p>
<ul>
<li>Multimap.get(key) 始终返回一个非null的，可能的空集合. 这并不意味着multimap花费了任何内存关联那个key，相反，返回的集合是一个允许你添加key映射的视图。</li>
<li>如果更倾向于类似Map的行为，如对于multimap中不存在的key返回null，可以使用asMap()视图来得到一个<code>Map&lt;K,Collection&lt;V&gt;&gt;</code>。（或者，从ListMultiMap得到一个<code>Map&lt;K,List&lt;v&gt;&gt;</code>，使用静态Multimaps.asMap()方法，类似方法适用于SetMultimap、SetMultimap、SortedSetMultimap)</li>
<li>Multimap.containsKey(key)仅仅当有任何元素和key相关联时才返回true。特别地，如果一个k以前在multimap存在映射关系，但是后来移除映射关系了，该方法返回false</li>
<li>Multimap.entries()返回multimap中的所有key的所有entries。如果想要得到所有key-collection entires，使用asMap.entrySet().</li>
<li>Multimap.size()返回MultiMap中所有的entries数目，不是对key去重后的数目。使用 Multimap.keySet().size() 可以得到去重后的key数目</li>
</ul>
<h4 id="实现类-1"><a href="#实现类-1" class="headerlink" title="实现类"></a>实现类</h4><p>Multimap提供很多实现，可以在大多数想使用<code>Map&lt;K, Colleciton&lt;V&gt;&gt;</code>的场合使用。</p>
<table>
<thead>
<tr>
<th>实现</th>
<th>Key行为类似</th>
<th>Values行为类似</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrayListMultimap</td>
<td>HashMap</td>
<td>ArrayList，同key对应values有顺序可重复</td>
</tr>
<tr>
<td>HashMultimap</td>
<td>HashMap</td>
<td>HashSet,同key对应values不可重复</td>
</tr>
<tr>
<td>LinkedListMultimap</td>
<td>LinkedHashMap</td>
<td>LinkedList 同key对应value有顺序可重复</td>
</tr>
<tr>
<td>LinkedHashMultimap</td>
<td>LinkedHashMap</td>
<td>LinkedHashSet 同key对应value有顺序不重复</td>
</tr>
<tr>
<td>TreeMultimap</td>
<td>TreeMap</td>
<td>TreeSet，同key对应的value有顺序</td>
</tr>
<tr>
<td>ImmutableListMultimap</td>
<td>ImmutableMap</td>
<td>ImmutableList</td>
</tr>
<tr>
<td>ImmutableSetMultimap</td>
<td>ImmutableMap</td>
<td>ImmutableSet</td>
</tr>
</tbody>
</table>
<p>每一个实现，除了不可变的那些，都支持key和value为null。</p>
<ul>
<li><p>LinkedListMultimap.entries()，对于不重复的key value保持了迭代时的顺序。</p>
</li>
<li><p>LinkedHashMultimap，保持了映射项entries的插入顺序，包括键keys的插入顺序、和任意一个key关联的values所有值的插入顺序。</p>
</li>
</ul>
<p>要知道以上的所有实现中并不是所有的实现都通过<code>Map&lt;K, Collection&lt;V&gt;&gt;</code>（特别的，几个MultiMap实现使用了自定义hash表来最小化开销）</p>
<p>如果你想要更多自定义，使用MultiMaps.newMultimap(Map, Supplier&lt;Collection)或者list、set自定义实现来支撑自定义multimap。</p>
<h3 id="BiMap-双向Map"><a href="#BiMap-双向Map" class="headerlink" title="BiMap 双向Map"></a>BiMap 双向Map</h3><p>传统映射values到key的方式是维护2个独立的map，保持他们同步，但是这种方式当一个value已经在map里存在时令人极度困惑且感觉像是bug。如：   </p>
<pre><code>Map&lt;String, Integer&gt; nameToId = Maps.newHashMap();
Map&lt;Integer, String&gt; idToName = Maps.newHashMap();

nameToId.put(&quot;Bob&quot;, 42);
idToName.put(42, &quot;Bob&quot;);
// 如果“Bob”或42已经存在，当我们刚好又忘记保持他们同步的时候，就会发生奇怪的错误。
</code></pre><p>A <code>BiMap&lt;K, V&gt;</code> 是一个<code>Map&lt;K,V&gt;</code>：</p>
<ul>
<li>允许你使用inverse()方法来得到反转视图BiMap&lt;V,K&gt;</li>
<li>确保values是不重复的，使values类似一个Set</li>
</ul>
<p>所有，BiMap的特点是key、value都不能重复。<br>若尝试添加一个key到已经存在的value映射会报参数异常。若想删除预先存在的entry（指定的value），则使用BiMap.forcePut(key, value)。</p>
<pre><code>public static void main(String[] args) {
       BiMap&lt;String, String&gt; biMap = HashBiMap.create();
       biMap.put(&quot;1&quot;, &quot;2&quot;);
       biMap.put(&quot;2&quot;, &quot;2&quot;);
       System.out.println(biMap);
   }
   #报参数异常

   public static void main(String[] args) {
           BiMap&lt;String, String&gt; biMap = HashBiMap.create();
           biMap.put(&quot;1&quot;, &quot;2&quot;);
           String s = biMap.inverse().get(&quot;1&quot;);
           System.out.println(s);
           System.out.println(biMap.inverse().get(&quot;2&quot;));
       }
       #null
       #1
</code></pre><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><table>
<thead>
<tr>
<th>Key-Value Map实现类</th>
<th>Value-Key Map 实现类</th>
<th>对应BiMap</th>
</tr>
</thead>
<tbody>
<tr>
<td>HashMap</td>
<td>HashMap</td>
<td>HashBiMap</td>
</tr>
<tr>
<td>ImmutableMap</td>
<td>ImmutableMap</td>
<td>ImmutableBiMap</td>
</tr>
<tr>
<td>EnumMap</td>
<td>EnumMap</td>
<td>EnumBiMap</td>
</tr>
<tr>
<td>EnumMap</td>
<td>HashMap</td>
<td>EnumHashBiMap</td>
</tr>
</tbody>
</table>
<p>Note: BiMap的工具方法如synchronizedBiMap在Maps里实现。</p>
<h3 id="表格Table"><a href="#表格Table" class="headerlink" title="表格Table"></a>表格Table</h3><pre><code>Table&lt;DateOfBirth, LastName, PersonalRecord&gt; records = HashBasedTable.create();
records.put(someBirthday, &quot;Schmo&quot;, recordA);
records.put(someBirthday, &quot;Doe&quot;, recordB);
records.put(otherBirthday, &quot;Doe&quot;, recordC);

records.row(someBirthday); // returns a Map mapping &quot;Schmo&quot; to recordA, &quot;Doe&quot; to recordB
records.column(&quot;Doe&quot;); // returns a Map mapping someBirthday to recordB, otherBirthday to recordC
</code></pre><p>通常，当你想同一时间对不止一个的key检索的时候，你会想出使用类似<code>Map&lt;FirstName, Map&lt;LastName, Person&gt;&gt;</code>，这种方式丑陋难以使用。 Guava提供一个新的集合类型，表格Table，支持“行row”类型，和“column”列类型。表格Table支持很多种视图来让你可以使用从任何角度的数据，包括：</p>
<ul>
<li>rowMap(), 该方法将<code>Table&lt;R,C,V&gt;</code>视作<code>Table&lt;R,Map&lt;C,V&gt;&gt;</code>。类似rowKeySet返回一个Set<r>.</r></li>
<li>row(r)返回一个非null的Map&lt;C,V&gt;，对这个Map的写操作将穿透到底层Table。</li>
<li>相似的列方法提供如下： columnMap(), columnKeySet(), column(c). (基于column的访问稍微比基于行的访问效率低)</li>
<li>cellSet() 返回一个Table.Cell&lt;R,C,V&gt;的set集合，Cell很像Map.Entry，但是区分row和column key。</li>
</ul>
<p>几种Table实现如下：</p>
<ul>
<li>HashBasedTable, 底层使用<code>HashMap&lt;R,HashMap&lt;C,V&gt;&gt;</code>（Guava20.0使用LinkedHashMap&lt;R, LinkedHashMap&lt;C,V&gt;&gt;实现）。</li>
<li>TreeBasedTable,底层使用<code>TreeMap&lt;R, TreeMap&lt;C, V&gt;&gt;</code>.</li>
<li>ImmutableTable,底层使用<code>ImmutableMap&lt;R, ImmutableMap&lt;C, V&gt;&gt;</code>. (Note: ImmutableTable针对稀疏和稠密的数据集有单独的优化实现)</li>
<li>ArrayTable, 需要在构建的时候传递全部的row和column数据，当数据是紧密的数据时通过2维数组来提高速度、内存利用率。ArrayTable和其他实现原理有稍微不同.</li>
</ul>
<h3 id="ClassToInstanceMap-类型到实例的映射Map"><a href="#ClassToInstanceMap-类型到实例的映射Map" class="headerlink" title="ClassToInstanceMap 类型到实例的映射Map"></a>ClassToInstanceMap 类型到实例的映射Map</h3><p>有时，map的key并不都是相同的类型，可能有多个类型，你可能想映射类型到values，可以使用ClassToInstanceMap.<br>除了扩展Map接口，ClassToInstanceMap提供方法T <code>getInstance(Class&lt;T&gt;</code>) 和T putInstance(Class<t>, T)，省去了手动进行类型转换。</t></p>
<p>ClassToInstanceMap只有一个名称为B的类型参数，代表map管理的类型的上层限制，如：</p>
<pre><code>ClassToInstanceMap&lt;Number&gt; numberDefaults = MutableClassToInstanceMap.create();
numberDefaults.putInstance(Integer.class,Integer.valueOf(0);
</code></pre><p>严格说，ClassToInstanceMap<b>实现了接口<code>Map&lt;Class&lt;? extends B&gt;, B&gt;</code> – 或者是从B的子类型class到B的映射的一个map，这会令ClassToInstanceMap的反省类型有些令人困惑，但记住B始终是map中类型的上层限制（上界）–通常，B就是Object类。</b></p>
<p>Guava提供MutableClassToInstanceMap、ImmutableClassToInstanceMap。</p>
<p>注意: 像其他Map&lt;Class, Object&gt;，一个ClassToInstanceMap可能包含基本类型，基本类型和对应包装类型可能对应不同的values。</p>
<h3 id="RangeSet"><a href="#RangeSet" class="headerlink" title="RangeSet"></a>RangeSet</h3><p>A RangeSet描述了一个不连续的、非空的范围集合，当往一个可变的RangeSet添加一个范围的时候，任何可连续的范围都被合并到一起，空范围被忽略，如下：</p>
<pre><code>RangeSet&lt;Integer&gt; rangeSet = TreeRangeSet.create();
 rangeSet.add(Range.closed(1, 10)); // {[1, 10]}
 rangeSet.add(Range.closedOpen(11, 15)); // disconnected range: {[1, 10], [11, 15)}
 rangeSet.add(Range.closedOpen(15, 20)); // connected range; {[1, 10], [11, 20)}
 rangeSet.add(Range.openClosed(0, 0)); // empty range; {[1, 10], [11, 20)}
 rangeSet.remove(Range.open(5, 10)); // splits [1, 10]; {[1, 5], [10, 10], [11, 20)}
</code></pre><p>记住想要合并范围如Range.closed(1, 10) and Range.closedOpen(11, 15), 必须首先使用Range.canonical(DiscreteDomain)预处理范围，如使用DiscreteDomain.integers().</p>
<pre><code>RangeSet&lt;Integer&gt; rangeSet = TreeRangeSet.create();
    rangeSet.add(Range.closed(1, 10).canonical(DiscreteDomain.integers())); // {[1, 10]}
    rangeSet.add(Range.closedOpen(11, 15)); // disconnected range: {[1, 10], [11, 15)}
    System.out.println(rangeSet);//[[1‥15)]

    // canonical可以理解为规范化，效果如下：
    System.out.println(Range.closed(1, 10).canonical(DiscreteDomain.integers()));[1‥11)
    System.out.println(Range.closed(1, 10));[1‥10]
</code></pre><p>注意: RangeSet 在GWT下和JDK1.5之下都不被支持；RangeSet需要全部NavigableMap的特征在JDK1.6中。</p>
<h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>RangeSet实现支持很多视图：</p>
<ul>
<li>complement(): 返回补集视图，也是一个RangeSet，它包含不连续的、非空范围.</li>
<li>subRangeSet(<code>Range&lt;C&gt;</code>): 返回RangeSet和指定范围的range的交叉集合，这会返回惯例的排序的headSet、subSet、tailSet视图。</li>
<li>asRanges():将RangeSet视作<code>Set&lt;Range&lt;C&gt;&gt;</code>，可以迭代遍历。</li>
<li>asSet(<code>DiscreteDomain&lt;C&gt;</code>) (仅仅对ImmutableRangeSet而言): 将<code>RangeSet&lt;C&gt;</code>当做<code>ImmutableSortedSet&lt;C&gt;</code>看待ranges中的元素而非range自己. (这个操作如果DiscreteDomain和RangeSet同时是无穷大或无穷小时不支持)</li>
</ul>
<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>除了视图，RangeSet还直接支持几种查询操作 ，最常用的：</p>
<ul>
<li>contains(C): RangeSet的最基本的方法，查询RangeSet中的任意一个range是否包含指定元素。</li>
<li>rangeContaining(C): 返回包含指定元素的Range，无返回null。</li>
<li>encloses(<code>Range&lt;C&gt;</code>): 测试RangeSet中的任意Range是否包围指定Range</li>
<li>span(): 返回包围RangeSet中任意的Range的最小Range。</li>
</ul>
<h3 id="RangeMap"><a href="#RangeMap" class="headerlink" title="RangeMap"></a>RangeMap</h3><p>RangeMap是描述不相交、非空范围到values的映射关系。不同于RangeSet，RangeMap不合并相邻映射，即使相邻的Ranges映射到相同的values。如：</p>
<pre><code>RangeMap&lt;Integer, String&gt; rangeMap = TreeRangeMap.create();
rangeMap.put(Range.closed(1, 10), &quot;foo&quot;); // {[1, 10] =&gt; &quot;foo&quot;}
rangeMap.put(Range.open(3, 6), &quot;bar&quot;); // {[1, 3] =&gt; &quot;foo&quot;, (3, 6) =&gt; &quot;bar&quot;, [6, 10] =&gt; &quot;foo&quot;}
rangeMap.put(Range.open(10, 20), &quot;foo&quot;); // {[1, 3] =&gt; &quot;foo&quot;, (3, 6) =&gt; &quot;bar&quot;, [6, 10] =&gt; &quot;foo&quot;, (10, 20) =&gt; &quot;foo&quot;}
rangeMap.remove(Range.closed(5, 11)); // {[1, 3] =&gt; &quot;foo&quot;, (3, 5) =&gt; &quot;bar&quot;, (11, 20) =&gt; &quot;foo&quot;}
Views
</code></pre><p>RangeMap提供2中视图：</p>
<ul>
<li>asMapOfRanges(): 将RangeMap当做一个<code>Map&lt;Range&lt;K&gt;,V&gt;</code>，当想要迭代RangeMap时可以使用</li>
<li>subRangeMap(<code>Range&lt;K&gt;</code>) 将RangeMap和指定Range的交集当做一个RangeMap，惯例返回headMap, subMap, and tailMap.</li>
</ul>

        
        <br>
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
